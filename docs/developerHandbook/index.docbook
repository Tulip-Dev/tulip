<?xml version='1.0'?>
<!DOCTYPE book SYSTEM "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<book><title>Tulip Developer Handbook</title>
<chapter id="introduction"><title>Introduction</title>
    <para></para>
</chapter>
<chapter id="installation"><title>Installation</title>
   <para>The <quote>configure</quote> shell script attempts to guess correct values for
various system-dependent variables used during compilation.  It uses
those values to create a <filename>Makefile</filename> in each directory of the package.
It may also create one or more <filename>.h</filename> files containing system-dependent
definitions.  Finally, it creates a shell script <filename>config.status</filename> that
you can run in the future to recreate the current configuration, a file
<filename>config.cache</filename> that saves the results of its tests to speed up
reconfiguring, and a file <filename>config.log</filename> containing compiler output
(useful mainly for debugging <code>configure</code>).</para>

   <para>If you need to do unusual things to compile the package, please try
to figure out how <code>configure</code> could check whether to do them, and mail
diffs or instructions to the address given in the <code>README</code> so they can
be considered for the next release.  If at some point <code>config.cache</code>
contains results you don't want to keep, you may remove or edit it.</para>

   <para>The file <filename>configure.in</filename> is used to create <filename>configure</filename> by a program
called <code>autoconf</code>.  You only need <quote>configure.in</quote> if you want to change
it or regenerate <code>configure</code> using a newer version of <code>autoconf</code>.</para>

<para><orderedlist><title>The simplest way to compile this package is:</title>

  <listitem><para><code>cd</code> to the directory containing the package's source code and type
     <code>./configure</code> to configure the package for your system.  If you're
     using <code>csh</code> on an old version of System V, you might need to type
     <code>sh ./configure</code> instead to prevent <code>csh</code> from trying to execute
     <code>configure</code> itself.</para>

     <para>Running <code>configure</code> takes awhile.  While running, it prints some
     messages telling which features it is checking for.</para></listitem>

  <listitem><para>Type <code>make</code> to compile the package.</para></listitem>

  <listitem><para>Optionally, type <code>make check</code> to run any self-tests that come with
     the package.</para></listitem>

  <listitem><para>Type <code>make install</code> to install the programs and any data files and
     documentation.</para></listitem>

  <listitem><para>You can remove the program binaries and object files from the
     source code directory by typing <code>make clean</code>.  To also remove the
     files that <filename>configure</filename> created (so you can compile the package for
     a different kind of computer), type <code>make distclean</code>.  There is
     also a <code>make maintainer-clean</code> target, but that is intended mainly
     for the package's developers.  If you use it, you may have to get
     all sorts of other programs in order to regenerate files that came
     with the distribution.</para></listitem></orderedlist>
</para>

<para>If you don't find the <filename>configure</filename> shell, you have to generate it with <filename>gen-conf.sh</filename>. The processing using the GNU build sytem gives a <filename>configure</filename> shell.</para>

    <caution><para>Verify <code>QTDIR</code> is properly set : <code>QTDIR/bin</code> should contain moc, qtconfig... , <code>QTDIR/lib</code> the libs and <code>QTDIR/include</code> the Qt headers ...</para></caution>
    <sect1 id="options"><title>Options</title>
        <para>In this section, you can find the most used options. To know all of the possible options, type <code>./configure --help</code></para>
        <variablelist>
            <varlistentry>
                <term><code>--prefix</code> = <emphasis>value</emphasis></term>
                <listitem><para>The <emphasis>value</emphasis> is the path where you want to install Tulip. <filename>bin, include, lib</filename> directories was created in this location. By default, it is <filename>/usr/local/</filename>.</para></listitem>
            </varlistentry>
        </variablelist>
        <variablelist>
            <varlistentry>
                <term><code>--enable-debug</code></term>
                <listitem><para>Add compilation flags to allow debugging.</para></listitem>
            </varlistentry>
        </variablelist>
        <variablelist>
            <varlistentry>
                <term><code>--enable-maintainer-mode</code></term>
                <listitem><para>Enable make rules and dependencies not useful (and sometimes confusing) to the casual installer. For example, if you modify a <filename>Makefile.am</filename> file, it is detected and the <filename>Makefile</filename> is updated.</para></listitem>
            </varlistentry>
        </variablelist>
    </sect1>

</chapter>
<chapter id="data-structure"><title>Data Structure</title>
<para>Efficient visualization of graphs implies to manipulate the structure of 
the graph but also to extract part of this structure. Moreover, if one 
wants to visualize graphs and to use graphs for data analysis, one must
take into account the values associated to the element (node or edge) of the 
graph. One other central point in a visualization system is to provide a 
way to compute parameters based on the intrinsic (or extrinsic) parameters
of a given graph. We call intrinsic parameters those calculated by using the
structure of the graph and extrinsic parameters those calculated using external
information. For instance, if we consider a file system, the size of a file is
an extrinsic parameter and the number of file in a directory is an intrinsic parameter 
because in can be computed by analyzing the structure of the tree representing the file system.  
</para>
<para>
This chapter describes the Tulip data structure that takes into account all the requirement
of a graph visualization system. For each part we describe precisely the general principle and
then we give several examples explaining how it can be done using the Tulip library.
</para>

<sect1 id="graphs"><title>Graphs</title>
    <para>The core of the Tulip library provides an interface for the manipulation of graphs. This interface enables
to access and to modify the structure of a graph. The objective of this library is to be the more general 
as possible and thus this interface enables to manipulate a general class of graphs called directed pseudo-graph. 
In a pseudo graph, it can exists several edges between two nodes and it can exists several loops. A loop is an
edge that links a node to itself. Furthermore, the link are directed, thus an edge linking a node u to a node v is
different from an edge linking a node v to a node u. 
    </para>
    <para>
    Using of pseudo-graph implies that it can exist two edge between a node u and a node v. Thus, it is not possible to
distinguish an edge using only its source and its target (u,v). To enable such a distinction, all the element in Tulip
are entities (objects). Thus, even if two edges have the same source and the same target they are different.    
    </para>
    <para>
Another important point to consider is that it is not possible to access to the structure of a graph through elements 
(node or edge). Thus, all operations on the graph structure must be done by querying the graph. For instance, if one
wants to know the source of an edge e of graph G, one must ask to G what is the source of e. This characteristic makes
the use of the library a little bit less intuitive but, it enables to store entities using the minimum space and to 
share them between sub-graphs. When using the Tulip data structure one must always keep in mind that building a container 
of elements corresponds to store a container of integers in memory. For instance, a std::vector&lt;node&gt; is 
equivalent to a std::vector&lt;unsigned int&gt;. 
    </para>
    <para>
The library support access and modification of the graph structure. The access to the structure are made by using iterators,
one very important point is that the iterator are not persistent. Thus, if one modify the graph structure all the iterators
on the graph structure can be invalid. This property enables to prevent from cloning the data structure and thus enables 
better access to it. For ease of use, Tulip includes mechanism that enables to transform an iterator into stable iterator,
one must keep in mind that it corresponds to clone the data structure and thus, it should be use only if it is necessary.
    </para>
    <para>
If one use Tulip only for the manipulation of one graph (no hierarchy), the list of available operations on the 
graph is given afterward. In the next section we will enhance the set of operations and the actions that they perform 
in order to manage a hierarchy of sub graphs
    <itemizedlist>
    <title>List of available modification operations</title>
    <listitem><para><methodname>node addNode()</methodname> : it enables to create a new node in the graph.</para></listitem>
    <listitem><para>    
        <methodname>edge addEdge(node,node)</methodname> : it enables to create a new edge in the graph. </para></listitem>
    <listitem><para><methodname>void delNode(node)</methodname> : it enables to delete a node in the graph.</para></listitem>
    <listitem><para><methodname>void delEdge(edge)</methodname> : it enables to delete an edge in the graph.</para></listitem>
    <listitem><para><methodname>void reverse(edge)</methodname> : it enables to reverse an edge (swap source and target).</para></listitem>
    </itemizedlist>
    <itemizedlist>
    <title>List of available access operations</title>
    <listitem><para><methodname>unsigned int deg(node)</methodname> : returns the degree of a node.</para></listitem>
    <listitem><para><methodname>unsigned int indeg(node)</methodname> : returns the in degree of a node.</para></listitem>
    <listitem><para><methodname>unsigned int outdeg(node)</methodname> : returns the out degree of a node.</para></listitem>
    <listitem><para><methodname>node source(edge)</methodname> : it returns the source of an edge.</para></listitem>
    <listitem><para><methodname>node target(edge)</methodname> : it returns the target of an edge.</para></listitem>
    <listitem><para><methodname>void opposite(edge,node)</methodname> : it enables to obtain the opposite of a node of an edge.</para></listitem>
    <listitem><para><methodname>Iterator * getInNodes(node)</methodname> : returns an iterator on the ancestors of a node.</para></listitem>
    <listitem><para><methodname>Iterator * getOutNodes(node)</methodname> : returns an iterator on the successors of a node.</para></listitem>
    <listitem><para><methodname>Iterator * getInOutNodes(node)</methodname> : returns an iterator on the neighborhood of a node.</para></listitem>
    <listitem><para><methodname>Iterator * getInEdges(node)</methodname> : returns an iterator on the ancestors of a node.</para></listitem>
    <listitem><para><methodname>Iterator * getOutEdges(node)</methodname> : returns an iterator on the successors of a node.</para></listitem>
    <listitem><para><methodname>Iterator * getInOutEdges(node)</methodname> : returns an iterator on the neighborhood of a node.</para></listitem>
    </itemizedlist>
    </para>
</sect1>

<sect1 id="hierarchy-graphs"><title>Hierarchy of graphs</title>
    <para> The Tulip library integrates the management of sub graphs. By definition a sub graph G' of a graph G is part of 
the elements of G such that G' is a graph. This implies that all sources and target of the edges of G' are in G'. 
Thus a sub graph can be manipulated exactly like a graph and so in Tulip one will only manipulates graphs that
we call SuperGraph because they could be or not sub graphs. As a sub graph is a graph one can need to obtain 
a sub graph of this sub graph and so on. Such an operation consists in building of a hierarchy of graphs. In this 
hierarchy if a graph G" is a descendant of a graph G, G" is a sub graph of G.
    </para>
    <para> One of the strong point of Tulip is to ensure efficiently that all elements are shared between graphs in a hierarchy
of graph. Thus, if a node n is element of a graph G and of a graph G' the entity n is the same in both graphs. Off course,
the information about the entity can changed between graphs. For instance, the degree of n can be different according to
the graph that we manipulate.
    </para>
    <para> One of the other feature in Tulip is that the sub graph relation in the hierarchy is preserved when one
makes modification of a graph. This requirement implies some change on the modification operations described above.
If one add a node in a graph, this node is automatically added to all the ancestor of this graph. If one delete a
node, this node is automatically deleted in all the descendant of the graph. If one reverse an edge, this edge is 
automatically reversed in all the hierarchy of graphs.
    </para>
    <para> In order to manipulate a hierarchy of graphs, a set of functions have been added to graph function introduced
above. This function enables to navigate in the hierarchy and also to modify the hierarchy of graphs. As for the
graph structure the access to the hierarchy structure is done by using iterators. One should remember that iterators
are not persistent and thus, if the hierarchy is modified, the iterators are invalid.
    <itemizedlist>
    <title>List of available modification operations</title>
    <listitem><para><methodname>SuperGraph *addSubGraph()</methodname> : return an empty sub graph of this graph.</para></listitem>
    <listitem><para><methodname>SuperGraph *delSubGraph(SuperGraph *)</methodname> : delete a sub graph, the descendant of this sub graph 
    continue to be sub graphs of the graph.</para></listitem>
    <listitem><para><methodname>SuperGraph *delAllSubGraph(SuperGraph *)</methodname> : delete a sub graph and all its descendant.</para></listitem>
    <listitem><para><methodname>edge addEdge(edge)</methodname> : add an edge element of another graph in the hierarchy.</para></listitem>
    <listitem><para><methodname>void addNode(node)</methodname> : add a node element of another graph in the hierarchy.</para></listitem>
    </itemizedlist>
    <itemizedlist>
    <title>List of available access operations</title>
    <listitem><para><methodname>Iterator * getSubGraphs()</methodname> : returns an iterator on the sub graphs.</para></listitem>
    <listitem><para><methodname>SuperGraph * getFather()</methodname> : returns the ancestor of the graph if the graph haven't got
    ancestor, it returns itself.</para></listitem>
    </itemizedlist>
    </para>
</sect1>

<sect1 id="attributes"><title>Attributes</title><para></para></sect1>

<sect1 id="properties"><title>Properties</title>
    <para> The Tulip property enables to store attribute on the elements of a graph. In Tulip we call it Property in 
order to prevent confusion with the graph attribute. Thus, the properties are for the elements and attributes are
for the graphs. The main idea in Tulip is that a property is always define for all kind (node and edge) of elements
in the graph. Thus we can always query for the value of an edge or a node to a property.
    </para>
    <para> As for the graph structure, to access the value of an elements one must query a property. This characteristic makes
the use of the library a little bit less intuitive but, it enables to store efficiently the properties. 
    </para>
    <para>
In general properties
can be seen as an associative table where you can set or get the value of an element. In order to prevent having a lot of cast 
in the code all the properties have type and thus there is no need to cast your result when you query a property. The standard
operation of a property are given below :
    <itemizedlist>
    <title>List of available modification operations</title>
    <listitem><para><methodname>void setNodeValue(node,TYPE)</methodname> : set the value of a node.</para></listitem>
    <listitem><para><methodname>void setAllNodeValue(TYPE)</methodname> : set the value of all nodes.</para></listitem>
    <listitem><para><methodname>void setEdgeValue(edge,TYPE)</methodname> : set the value of an edge.</para></listitem>
    <listitem><para><methodname>void setAllEdgeValue(TYPE)</methodname> : set the value of all edges.</para></listitem>
    </itemizedlist>
    <itemizedlist>
    <title>List of available access operations</title>
    <listitem><para><methodname>TYPE getNodeValue(node)</methodname> : return the value of a node.</para></listitem>
    <listitem><para><methodname>TYPE getEdgeValue(edge)</methodname> : return the value of an edge.</para></listitem>
    </itemizedlist>
    </para>
    <para> For each kind of properties it exists a specific implementation (inheritance) that enables to obtain
    specific operations (see developer documentation) depending of the Type. For instance, it is possible to obtain 
    the maximum value of a property if it a double. 
    </para>
    <para> One of the most important things is to know how to create a property or to access to an existing property
in the graph. To do this a graph includes a set of functions that enables to obtain/create/delete a Property. Because
the C++ signature of function does not include the TYPE of the returned argument, the syntax for this call is not 
very simple. For instance, if one wants to obtain a property containing double (called MetricProxy in Tulip) one must use
the following syntax : <methodname> MetricProxy *metric=graph->getProperty&lt;MetricProxy&gt;("name of the property");</methodname>
In the graph each properties are identified by their name which a std::string, when one ask for a property the type of this 
property is checked using the run time type interrogation mechanism of the C++. Warning, this test is only done when one 
compile its sources in DEBUG mode (default mode). In order to facilitate the navigation/edition of the set of properties, a
set of function is accessible through the graph interface.
    <itemizedlist>
    <title>List of available operations</title>
    <listitem><para><methodname>Iterators * getLocalProperties()</methodname> : return an iterator on all existing properties.</para></listitem>
    <listitem><para><methodname>void delLocalProperty(std::string)</methodname> : delete a property.</para></listitem>
    <listitem><para><methodname>bool existLocalProperty(std::string)</methodname> : return true if the property exists.</para></listitem>
    <listitem><para><methodname>Proxytype * getLocalProperty (std::string)</methodname> : return the property or if it does not exist create 
    a new one and return it </para></listitem>
    </itemizedlist>
    </para>
    <para> The mechanism described above works well for graphs. However, in Tulip we are working with a hierarchy of graphs. 
Thus a special mechanism have been added in order to enable to share easily properties between graphs. This mechanism use
the fact that if a property exists in an ancestor of a graph, it can be use on the graph. This looks like an inheritance 
mechanism of properties between graphs. As in object oriented language, in Tulip, it is possible to inherit a property
or to have it defined locally. In order to facilitate the navigation/edition of the set of properties, a
set of function is accessible through the graph interface.
    <itemizedlist>
    <title>List of available operations</title>
    <listitem><para><methodname>Iterators * getInheritedProperties()</methodname> : return an iterator on all the inherited properties.</para></listitem>
    <listitem><para><methodname>bool existProperty(std::string)</methodname> : return true if the property exists (inherited or locally).</para></listitem>
    <listitem><para><methodname>Proxytype * getProperty(std::string)</methodname> : return the property (inherited or local) or if it does not exist create 
    a new one (locally) and return it </para></listitem>
    </itemizedlist>
    </para>
</sect1>

<sect1 id="code-exemples"><title>Examples of code</title>
    <sect2 id="code-exemples-graphs"><title>Graphs</title>
        <para></para>
    </sect2>

    <sect2 id="code-exemples-properties"><title>Properties</title>
        <para></para>
    </sect2>
</sect1>
</chapter>

<chapter id="opengl-library"><title>Tulip Open GL Library</title>
    <sect1 id="gl-intro"><title>Introduction</title>
        <para></para>
    </sect1>
    <sect1 id="augm-disply"><title>Augmented Displays for Tulip</title>
	<sect2 id="glAugmentedDisplay-main"><title>Augmented Displays with GlAD</title>
	    <para>GlAD(GlAugmentedDisplay) is a library for OpenGL allowing the developper to add augmented displays on the graph. The objective of this class was to be as modular as possible, giving the user a full scalable and Tulip-compatible engine to render custom augmented displays. Based upon the now obsolete GlDrawable system this library offers more efficient services.
	    </para>
	</sect2>
    
	<sect2 id="glAugmentedDisplay"><title>GlAugmentedDisplay</title>
	    <para> GlAugmentedDisplay is the mother-class of every augmented display. It provides one important virtual function : draw. By generalizing this class, you can have classes making calls to OpenGL functions within the draw function. The only real implementation in this class is the link with the rendering options. You can recognize the other classes of the library with the prefix "GlAD".
	    </para>
	</sect2>
    
	<sect2 id="glADRenderOptions"><title>GlADRenderOptions</title>
	    <para>GlADRenderOptions is a class used to store the rendering options of every GlAugmentedDisplay instances. It is working on a basis of 32-bits integer where every bit represent a different render state.</para>
		
	    <sect3 id="glADRenderOptions-List"><title>List of available render states</title>
		<para> These are the different available render states you can use with GlADRenderOptions. It is to note that some of these render states are only descriptive and have no use in the <emphasis>setup()</emphasis> function.</para>
    
		<itemizedlist>
		    <listitem><para><emphasis>GlAD_Wireframe</emphasis> : Enables the rendering with wireframe. This option can be combined with <emphasis>GlAD_Solid</emphasis> in order to render Wired-Solid geometry. <emphasis>At least one of these two options must be activated.</emphasis> Default = off.</para></listitem>
		    <listitem><para><emphasis>GlAD_Solid</emphasis> : Enables the rendering of solid geometry. This option can be combines with <emphasis>GlAD_Wireframe</emphasis> in order to render Wired-Solid geometry. <emphasis>At least one of these two options must be activated.</emphasis> Default = on.</para></listitem>
		    <listitem><para><emphasis>GlAD_AlphaBlending</emphasis> : Enables the use of Alpha-Blending. The Blendinf functions are the responsibility of the developer in the draw function of the considered GlAugmentedDisplay. Default = off; Default AlphaBlending : src=<emphasis>GL_SRC_ALPHA</emphasis>; dest=<emphasis>GL_ONE_MINUS_SRC_ALPHA</emphasis></para></listitem>
		    <listitem><para><emphasis>GlAD_ZEnable</emphasis> : Enables the Depth Test during the rendering. Default = on.</para></listitem>
		    <listitem><para><emphasis>GlAD_Lighting</emphasis> : Enables the basic OpenGL Per Vertex Lighting (PVL). Default = off.</para></listitem>
		    <listitem><para><emphasis>GlAD_Culling</emphasis> : Enables the backface culling during the render. Default = on.</para></listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
    
	<sect2 id="glAD3D-basic"><title>Basic GlAD 3D classes</title>
	    <para>There are 3 basic GlAD classes which are displaying in 3D. Each of them represent a different primitive.</para>
	    <itemizedlist>
		<listitem><para><emphasis>GlADPoint</emphasis> : Describes a point according to a position and a color.</para></listitem>
		<listitem><para><emphasis>GlADLine</emphasis> : Describes a line according to a start position, a start color, an end position and an end color.</para></listitem>
		<listitem><para><emphasis>GlADQuad</emphasis> : Describes a quad according to a position and a size, or according to four points.</para></listitem>
	    </itemizedlist>
	</sect2>
    
	<sect2 id="glAD3D-advanced"><title>Advanced GlAD 3D classes</title>
	    <para>Based upon the basic GlAD 3D classes, there are 3 other classes in the default GlAD package.</para>
	    <itemizedlist>
		<listitem><para><emphasis>GlADAxisPoint</emphasis> : Displays a point with three axis (aligned with the world axis) according to a position, a color and a length. This augmented display is built with a GlADPoint and 6 GlADLine</para></listitem>
		<listitem><para><emphasis>GlADBox</emphasis> : Displays a box. This augmented display is built with 6 GlADQuad.</para></listitem>
		<listitem><para><emphasis>GlADGrid</emphasis> : Displays a 3D or a 2D projection of a grid. This augmented display is built with GlADLine.</para></listitem>
	    </itemizedlist>
	</sect2>
    
	<sect2 id="glAD2D-basic"><title>Basic GlAD 2D classes(GlHud)</title>
	    <para>Based upon the general GlHud class, there are 3 HUD classes in the default GlHud package.</para>
	    <itemizedlist>
		<listitem><para><emphasis>GlHudLine</emphasis> : Displays a line according to a start position and an end position (and a color). The coordinates of the position must be given in screen space !</para></listitem>
		<listitem><para><emphasis>GlHudRect</emphasis> : Displays a rectangle according to two position, the TopLeft corner and the BottomRight corner. These positions are in screen coordinates. Color must also be specified per corner.</para></listitem>
		<listitem><para><emphasis>GlHudCircle</emphasis> : Displays a circle according to a center position, a radius and a number of segment. The position and the radius must be given in screen coordinates. The color must also be specified in the constructor.</para></listitem>
	    </itemizedlist> 
	</sect2>
    
	<sect2 id="glAD-Examples"><title>Examples of GlAD uses</title>
	    <para>This section contains three small examples of use of the augmented displays with tulip. We admitt the user has a GlGraphWidget already defined in the variable <emphasis>glGraphWidget</emphasis>.</para>
	    <para>In the given screenshots, the scene is composed of two nodes placed at positions (-1, -1, -1) and (1, 1, 1). Their sizes are (1, 1, 1)</para>
	    <para>Here is the base screenshot of the scene :</para>
	    <graphic fileref="images/GlADBaseScene.png"/>
	
	    <sect3 id="glAD3D-BasicExample"><title>Example of Basic GlAD 3D uses : GlADLine</title>
		<para>This simple example shows how to add a Line from the position (-1, -1, -1) to the position (1, 1, 1) as an augmented display in a GlGraphWidget, the line will be starting Blue and will finish transparent Red; the thickness of the line will be set to 1 pixel.</para>
		<programlisting>Coord startPos(-1, -1, -1);
Coord endPos(1, 1, 1);
Color startCol(0, 0, 255, 255);
Color endCol(255, 0, 0, 0);

// We create the line, the last parameter is the thickness of the line (note : you can't exceed 10)
GlADLine* line = new GlADLine(startPos, endPos, startCol, endCol, 1);

// We set 2 render states : Firstly we activate Alpha-Blending so that transparency can we computed, 
// and then we deactivate the z buffer, in order to see the line even if it crosses a node.
line->setRenderState(GlAD_AlphaBlending, true);
line->setRenderState(GlAD_ZEnable, false);

// Finally we add the line to the GlGraphWidget, naming it "The famous tutorial line"
glGraphWidget->addGlAugmentedDisplay(line, "The famous tutorial Line");	
		</programlisting>
	
		<para>Here is the screenshow of the result :</para>
		<graphic fileref="images/GlADLineTut.png"/>
	    </sect3>
	    <sect3 id="glAD3D-AdvancedExample"><title>Example of Advanced GlAD 3D uses : GlADBox</title>
		<para>This example shows how to add a Box from the position (-1.5, -1.5, -1.5) to the position (1.5, 1.5, 1.5) as an augmented display in a GlGraphWidget. The box will be blue and semi transparent (220, 220, 255, 80).</para>
	
		<programlisting>Coord topLeft(-1.5, -1.5, -1.5);
Coord bottomRight(1.5, 1.5, 1.5);
Color boxColor(220, 220, 255, 80);

// We create the box by giving to the constructor the bounding box (topLeft and bottomRight) and the color of the box.
GlADBox *box = new GlADBox(topLeft, bottomRight, boxColor);

// We activate Alpha-Blending so that transparency can be computed and we deactivate culling in order to avoid backface removal.
box->setRenderState(GlAD_AlphaBlending, true);
box->setRenderState(GlAD_Culling, false);

// Finally we add the box to the GlGraphWidget, naming it "GlAD Tutorial 2 : Box"
glGraphWidget->addGlAugmentedDisplay(box, "GlAD Tutorial 2 : Box");
		</programlisting>
	
		<para>Here is the screenshot of the result :</para>
		<graphic fileref="images/GlADBoxTut.png"/>
	    </sect3>
	
	    <sect3 id="glAD2D-BasicExample"><title>Example of GlAD 2D (GlHud) uses : GlHudCircle</title>
		<para>This example shows how to add a Circle centered at the middle of the screen, of a radius of 256 pixels(The screenshot has been scaled). The circle will be light blue and will have 50 segments</para>
	
		<programlisting>//We firstly get the viewport to guess the center of the window
int viewport[4];
glGetIntegerv(GL_VIEWPORT, viewport);

// This is the position of the center of the circle (ScreenWidth / 2, ScreenHeight / 2, 1)
Coord circleCenter(viewport[2] / 2, viewport[3] / 2, 1);
Color circleColor(220, 220, 255, 255);

// We create the circle giving it's center position, it's color, it's radius and the number of segments
GlHudCircle* circle = new GlHudCircle(circleCenter, circleColor, 256, 50);

// Then we deactivate Z buffer : this is very important for GlHud classes !
circle->setRenderState(GlAD_ZEnable, false);

// Finally we add the circle to the GlGraphWidget.
glGraphWidget->addGlAugmentedDisplay(circle, "GlAD Tutorial 3 : Circle");
		</programlisting>
	
		<para>Here is the screenshot of the result (the screenshot has been shrinked so the radius is not of 256 pixels) :</para>
		<graphic fileref="images/GlADCircleTut.png"/>
	    </sect3>
	
	    <sect3 id="glAD-Compositing"><title>Compositing with GlAD</title>
		<para>This example show how to use GlADComposite to compose multiple effects in a scene. The scene will be composed of a sphere and 4 rectangles, to simulate an ArcBall</para>
	
		<para>The circle will be positionned at the center of the screen. It will have a radius of 256 pixels and will be of a medium grey (128, 128, 128, 255).</para>
		<para>The four squares will be positionned every 90Â° on the circle. They will also be in medium gray, and only wired</para>
	
		<programlisting>// We firstly create a new composite to store the final Augmented display :
GlADComposite *composite = new GlADComposite();

// This is the medium grey color that will be applied to every GlHud :
Color hudColor(128, 128, 128, 255);

// We get the viewport for the circle :
int viewport[4];
glGetIntegerv(GL_VIEWPORT, viewport);

// This is the position of the center of the circle (ScreenWidth / 2, ScreenHeight / 2, 1)
Coord circleCenter(viewport[2] / 2, viewport[3] / 2, 1);

// We create the circle. It still have 50 segments
GlHudCircle* circle = new GlHudCircle(circleCenter, hudColor, 256, 50);

// We deactivate the Z buffer for the rendering of the circle
circle->setRenderState(GlAD_ZEnable, false);

// A 4 entries table for the squares
GlHudRect* rects[4];

Coord center, topLeft, bottomRight;

for(int i=0; i &lt; 4; i++)
  {
    // We calculate the position of the center of each square
    center[0] = cos((double)i * 3.14/2.0) * 256;
    center[1] = sin((double)i * 3.14/2.0) * 256;
    center[2] = 0;
    center = center + circleCenter;

    // Then we find the position of the topLeft and the bottomRight corner
    topLeft     = center - Coord(16, 16, 1);
    bottomRight = center + Coord(16, 16, 0);

    rects[i] = new GlHudRect(bottomRight, topLeft, hudColor, hudColor);

    // We deactivate Backface culling and Z-buffer
    rects[i]->setRenderState(GlAD_ZEnable, false);
    rects[i]->setRenderState(GlAD_Culling, false);

    // Then we activate Wireframe rendering
    rects[i]->setRenderState(GlAD_Wireframe, true);
    rects[i]->setRenderState(GlAD_Solid, false);
  }

// We add the circle and the 5 squares to the composite
composite->addGlAugmentedDisplay(rects[0], "GlAD Tutorial 4 : Rect1");
composite->addGlAugmentedDisplay(rects[1], "GlAD Tutorial 4 : Rect2");
composite->addGlAugmentedDisplay(rects[2], "GlAD Tutorial 4 : Rect3");
composite->addGlAugmentedDisplay(rects[3], "GlAD Tutorial 4 : Rect4");
composite->addGlAugmentedDisplay(circle, "GlAD Tutorial 4 : Circle");

// Finally we add the composite to the GlGraphWidget
glGraphWidget->addGlAugmentedDisplay(composite, "Composite");
	    </programlisting>
    
		<para>Here is a screenshot of the result :</para>
		<graphic fileref="images/GlADCompositeTut.png"/>
	    </sect3>
	</sect2>
    </sect1>
</chapter>


<chapter id="qt-library"><title>Tulip QT Library</title><para></para></chapter>

<chapter id="plugins-mechanism"><title>Plug-ins mechanism</title>
<para>Tulip has been built to be easily extensible. Therefore a mechanism of plug-ins has been set-up. It enables
to directly add new functionalities into the Tulip kernel. One must keep in mind that a plug-in have access to 
all the part of Tulip. Thus, one must write plug-ins very carefully to prevent memory leak and also 
errors. A bug in plug-in can result in a "core dump" in the software that uses it. To
enable the use of plug-ins, a program must call the initialization functions of the plug-ins. This function
parse all the Tulip plug-ins directory and load dynamically all the plug-ins and register them into 
a factory that will enables to access to it directly.</para>

<sect1 id="available-plugin"><title>Available plug-ins</title><para></para>
</sect1>

</chapter>

<chapter id="graph-format"><title>Tulip graph format</title>
    <sect1 id="nodes-def"><title>Nodes</title>
        <para>The nodes are stored with a list of index. The index must be integers (Greater than 0).</para>
        <para>Syntax<programlisting>(nodes id_node1 id_node2 ...)</programlisting>
           Sample :<programlisting>(nodes 1 2 3 4 5 )</programlisting>
        </para>
    </sect1>
    <sect1 id="edges-def"><title>Edges</title>
        <para>An edge is defined by providing three integers (greater than 0). The first is the id of the edge, the second is the id of source node of the edge and the third is the id of target node of the edge.</para>
        <para>Syntax<programlisting>(edge id id_source id_target)</programlisting>
        Sample<programlisting>(edge 2 2 1)</programlisting>It defines one edge with the node that has the id 2 as source and the node that has the id 1 as target.
        </para>
    </sect1>
    <sect1 id="clusters-def"><title>Clusters</title>
        <para>A cluster is defined by on integer which represent the cluster id, one string which is the name of the cluster(Two cluster can have the same name). Then it is define with a list of nodes and a list of edges. To define a subcluster we use the same method. One important point is that the id zero is reserved for the root graph (this it cannot be used).</para>
        <para>Syntax<programlisting>
(cluster id name
  (nodes id_node1 id_node2 ...)
  (edges id_edge1 id_edge2 ...)
  (cluster id name
    (nodes id_node1 id_node2 ...)
    (edges id_edge1 id_edge2 ...)
  )
)
            </programlisting>Sample<programlisting>
(cluster 3 "cluster"
  (nodes 1 2 3 )
  (edges 2 8 )
  (cluster 4 "Sub Cluster"
    (nodes 1 2 )
    (edges 2 )
  )
)       </programlisting>
        </para>
    </sect1>
    <sect1 id="pro-def"><title>Definitions of properties</title>
        <para>The defintion of properties is the following:</para>
        <para>Syntax <programlisting>
(property cluster_id property_type "property_name"
  (default "default_node_value" "default_edge_value" )
  (node id value)
  ...
  (edge id value)
  ...
)        
</programlisting>Sample<programlisting>
(property  0 bool "viewSelection"
  (default "false" "false" )
  (node 1 "true")
  (node 2 "true")
  (node 3 "true")
  (edge 2 "true")
  (edge 8 "true")
)
</programlisting>
        </para>
        <sect2 id="type-pro"><title>Property Type</title>
        <para>  
        <itemizedlist>
            <listitem><para>layout : This type enables to strore nodes position in 3D. The position of nodes is defined by a set of 3 doubles <code>(x_coord,y_coord,z_coord)</code>. The position of edges is a list of 3D points. These points are the bends of edges. <code>((x_coord1,y_coord1,z_coord1)(x_coord2,y_coord2,z_coord2))</code></para></listitem>
            <listitem><para>size : This type enables to store the size of elements. The size is defined with a sequence of three double. <code>(width,heigth,depth)</code>"</para></listitem>
            <listitem><para>color : This type enables to store the color of elements. The color is defined with a sequence of four integer from 0 to 255. <code>(red,green,blue,alpha)</code></para></listitem>
            <listitem><para>string : This enables to store text on elements.</para></listitem>
            <listitem><para>metric : This enables to store real on elements.</para></listitem>
            <listitem><para>bool : This type enabes to store boolean on elements.</para></listitem>
            <listitem><para>int : This type enabes to store integers on elements.</para></listitem>  
        </itemizedlist>
        </para>
        </sect2>
    </sect1>
    <sect1 id="pro-tlp"><title>Properties of Tulip</title>
        <para>
        <variablelist>
            <varlistentry>
                <term><code>viewSelection</code></term>
                <listitem><para>type : bool, this property is the one used for selected elements in Tulip.<programlisting>
(property  0 bool "viewSelection"
  (default "false" "false" )
  (node 1 "true")
  (node 2 "true")
  (node 3 "true")
  (edge 2 "true")
  (edge 8 "true")
)
</programlisting></para></listitem>
            </varlistentry>
            <varlistentry>
                <term><code>viewLayout</code></term>
                <listitem><para>type : layout, this property is the one used for displaying graph in Tulip.<programlisting>
(property  0 layout "viewLayout"
  (default "(0,0,0)" "()" )
  (node 1 "(10,10,10)")
  (node 2 "(20,20,20)")
  (edge 1 "(15,15,15)(25,25,25)")
)
</programlisting></para></listitem>
            </varlistentry>
            <varlistentry>
                <term><code>viewColor</code></term>
                <listitem><para>type : color, this property is the one used for coloring graphs in Tulip.<programlisting>
(property  0 color "viewColor"
  (default "(235,0,23,255)" "(0,0,0,0)" )
  (node 1 "(200,0,200,255)")
  (node 2 "(100,100,0,255)")
  (node 3 "(100,100,0,255)")
  (edge 2 "(200,100,100)")
)
</programlisting></para></listitem>
            </varlistentry>
            <varlistentry>
                <term><code>viewLabel</code></term>
                <listitem><para>type : string, this property is the one used for labeling the graphs in Tulip(in label mode).<programlisting>
(property  0 string "viewLabel"
  (default "" "" )
  (node 1 "Hello")
  (node 2 "Bonjour")
  (node 3 "Bye")
  (edge 2 "Aurevoir")
)
</programlisting></para></listitem>
            </varlistentry>
            <varlistentry>
                <term><code>viewSize</code></term>
                <listitem><para>type : size, this property is the one used for the size of elements displayed.<programlisting>
(property  0 size "viewSize"
  (default "(0,0,0)" "(1,1,1)" )
  (node 1 "(10,10,10)")
  (node 2 "(20,20,20)")
)
</programlisting></para></listitem>
            </varlistentry>
            <varlistentry>
                <term><code>viewShape</code></term>
                <listitem><para>type : int, this property is used for defining the shape of elements.<programlisting>
(property  0 int "viewShape"
  (default "0" "0" )
  (node 1 "1")
  (node 2 "2")
)
</programlisting></para></listitem>
            </varlistentry>
            <varlistentry>
                <term><code>viewTexture</code></term>
                <listitem><para></para></listitem>
            </varlistentry>
            <varlistentry>
                <term><code>viewMetaGraph</code></term>
                <listitem><para></para></listitem>
            </varlistentry>
            <varlistentry>
                <term><code>viewRotation</code></term>
                <listitem><para></para></listitem>
            </varlistentry>
        </variablelist>
        </para>
    </sect1>
</chapter>

<chapter id="prog-guidelines"><title>Programming Guidelines</title>
    <!--======  GENERALITES   ========================================================    -->
    <sect1 id="generalites"><title>Generalities</title>
        <para>The presentation of a program indicates the quality of programming. This section relates to the common recommendations for the Tulip project. Each new programmer has to follow the expressed rules.</para>
        <para>In the header files, the programmer should write a headline containing : his name with personal  email adress (for students), the date of the last modifications, a reminder of the licence <acronym>GPL</acronym> and the references of the code (for example, an algorithm). Header files must include a construction that prevents multiple inclusions. The convention is an all uppercase construction of the file name, the h suffix and prefixed by <quote>Tulip</quote>, separated by an underscore.
<programlisting>
#ifndef Tulip_MYTYPE_H
#define Tulip_MYTYPE_H

...

#endif // Tulip_MYTYPE_H
</programlisting></para>
        <para>The organisation of files must be comprehensible. New module leads to a new set of files :  a <filename>*.cpp</filename> and a <filename>*.h</filename> named with the name of the type. If the structure implicates that all methods are inline, the creation of a <code>.cxx</code> file is better than a <filename>.cpp</filename> file. The <filename>cxx</filename> should be included at the bottom of the header file. None implementation is in the header file. In the Tulip hiearchy, the cxx files are in a directory <quote>cxx</quote> in the header location. </para>

        <para>The indentation is an important part for a easy reading in a file and a best understanding. Code must be properly indented to show the syntactic structure of the program. It is useless to space out excessively the code. A conventionnal indentation is just necessary. None useless <keycap>TAB</keycap> or spaces. The <keysym>{</keysym> caracter for the opening of a method or a function must be at the end of the line, not in following line. Each new fitted block of program implies a new shift for the indentation.</para>
        
        <para>Each new module inserted in the Tulip library must be included in the namespace <code>tlp</code>. It is necessary in order to prevent eventually incompatibilities.
<programlisting>
namespace tlp{

/* code inserted */

}
</programlisting>
</para>

        <para>Tulip is dependent of the Standard Template Library, <acronym>STL</acronym>. It provides a set of performing objects that you should use : vector, map, string, ... It exists two ways to use it. In the <filename>.h</filename> or <filename>.cxx</filename> files, you should preface them with the <code>std</code> namespace (e.g. <code>std::string s;</code>). You will refer them with the fullname : namespace and class name. For the <filename>.cpp</filename> files, you can use the short name if you insert the line at the top of your document <code>using namespace std;</code>.</para>
<para>
In a header file (<filename>.h</filename> or <filename>.cxx</filename>) :
<programlisting>
class MyClasse{
  public:
    Myclasse();
    ~MyClasse(){}
    void draw();

  private:
    std::string mystring;
};
</programlisting>
In a source file (<filename>.cpp</filename>) :
<programlisting>
using namespace std;

MyClasse::MyClasse(){
    mystring = "Hello world";
}
void MyClasse::draw(){
    cout&lt;&lt;mystring&lt;&lt;endl;
}
</programlisting>
        </para>
     </sect1>
<!--=================================================================================    -->

<!--======  NAMMING   ===============================================================    -->
    <sect1 id="namming"><title>Namming conventions</title>
	<para> Programmer of Tulip has to follow some rules for choosing Type, Functions, or Variables names. Each names must be in English and choose to an easy understanding, descriptive and accurate. Each important word must be found in the name.
	    <itemizedlist><title>List of Rules</title>
		<listitem><para>Types (struct, class, ...) : Names must be in mixed case starting with upper case. Each word should have first letter in upper case. Don't use underscore to separate words. (e.g. <code>SortedVector, OrientedList, RedBird, ...</code>)</para></listitem>
		<listitem><para>Functions and Methods : Names must be in mixed case like for Types, but starting with lowercase. After the first one, each important word has first letter in upper case. Don't use underscore to separate words. (e.g <code>drawString(), computeFormulas(), ...</code>)</para></listitem>
		<listitem><para>Variables : Names must be in lower case. (e.g. <code>instances, nodes, tableofcontents, ...</code>)</para></listitem>
		<listitem><para>Constants : Names must be in upper case. (e.g. <code>MAXSIZE, BLACKCOLOR, ... </code>)</para></listitem>
		<listitem><para>Macro and Enumeration constans : Names must be defined in upper case with an underscore between words. (e.g. <code>LAYOUTPLUGIN(C, N, A, D, I, V, R), ...</code>)</para></listitem>
		<listitem><para>Namespaces : Names must be in lower case. (e.g. <code>tlp</code>)</para></listitem>
	    </itemizedlist>

           The <emphasis>setter</emphasis> and <emphasis>getter</emphasis> must begin with the keyword <methodname>set</methodname> or <methodname>get</methodname>. All of the methods or functions should begin with a verb for understanding its goal. The prefix of a boolean variables or methods should be <emphasis>is, can, has, should</emphasis> : <methodname>bool isValid(const edge e) const</methodname>, function specified if the edge is valid.
	</para>
    </sect1>
<!--=====================================================================================    -->

<!--======= COMMENTAIRES ================================================================    -->
    <sect1 id="commentaires"><title>Code Comments</title>
	<para>
	    All of the comments in the source and the header files must be written in the English language. Lots of comments is a simple way to leave a clear code for the next programmer who will receive your work. A part of comments must be written with several rules to help the documentation of your work generating automatically with <emphasis>Doxygen</emphasis>. Choose a part of your comments to describe your work. See <xref linkend="doxygen"/>. It is important that a programmer can understand the using of your work and how to use your work.
	</para>
	<para>
	    Before a declaration of a class, you should write a little description to explain it. The role, the pre-requisites, the post-requisites, the return values and the parameters should be written before the declaration of the function or method. It is the minimum for an easy comprehension of your work.
	    In the code, it is useless to comment each line because the comments are often a paraphrase of the code. It just is essential to write a comment for strong parts that you have thought.
	</para>
    </sect1>
    <!--===================================================================================    -->

    <!--======= INTEGRATION ================================================================    -->
    <sect1 id="integration"><title>Integration in Tulip project</title>
        <para>The build of Tulip uses a mecanism of the GNU operating system. <acronym>GNU</acronym> has several tools used for the management of the configuration files. It modifies the <filename>makefile</filename> to adapt their to the distribution you have and the tools you need : the most important tools are <application>autoconf</application>, <application>automake</application> and <application>libtool</application>.
        <application>Tulip</application> generates three libraries : <filename>libtulip, libtulip-ogl, libtulip-qt</filename>, a software : <filename>tulip</filename> and a script : <filename>tulip-config</filename>. In a thirdparty, <application>Tulip</application> compiles several external libraries needed by the software : ftgl, gle, gzstream, triangle.
        </para>
        <sect2 id="build-sys"><title>GNU Build system</title>
            <sect3 id="presentation"><title>Presentation</title>
                <para>The goals of this system is to simplify the development of portable programs and the building of programs thaht are distributed as source code.</para>
                <para><application>Autoconf</application> is a tool of GNU producing shell scripts that automtically configure software packages to adapt to many kinds of UNIX systems. It is not the unique tool, it runs with others to solve all problems to making portable software. It generates configurations files : specially the <code>configure</code> script from a <filename>configure.in</filename> or <filename>configure.ac</filename> file. Running this script, you produce the customized Makefiles, and other files. It checks for the presence of each feature that the software need. Autoconf requires <application>GNU M4</application> in order to generate the scripts. </para>
                <para>To this end, GNU has developed a set of integrated utilities to finish the job of <application>Autoconf</application>. <application>Automake</application> is the next in run. It is a tool for generating <filename>Makefile.in</filename> from files called <filename>Makefile.am</filename>. Each <filename>Makefile.am</filename> is basically a series of <code>make</code> variable definitions, with the GNU Makefile standards. <application>Automake</application> requires <application>Autoconf</application> in order to be used properly.
                </para>
                <para>The last is <application>Libtool</application>. It makes it possible to compile position indepedent code and build shared libraries in a portable manner. It does not require either Autoconf, or Automake and can be used indepedently. Automake however supports libtool and interoperates with it in a seamless manner.</para>

            </sect3>
            <sect3 id="simple-example"><title>A simple example</title>
                <para>... to understand the basic mecanism.</para>
                <para>To create a <filename>configure</filename> script with autoconf, you need so to write an autoconf input file <filename>configure.ac</filename> (or <filename>configure.in</filename>, use in previous versions of <application>Autoconf</application>). In this example, it is created a <filename>configure.ac</filename> file but Tulip contains <filename>configure.in</filename>. The both files are correct.
<programlistingco>
<areaspec>
    <area id="programs" coords='9 30'/>
    <area id="sources" coords='10 30' />
    <area id="acinit" coords='13 30'/>
    <area id="acsrcdir" coords='14 30'/> 
    <area id="acinitmake" coords='15 30'/>
    <area id="progcc" coords='16 30'/>
    <area id="output" coords='17 30'/>
</areaspec>
<programlisting>
`hello.c` 
  #include &lt;stdio.h>
  main(){
     printf("Hello world!\n");
  }

`Makefile.am` 
  bin_PROGRAMS = hello
  hello_SOURCES = hello.c

`configure.ac`
  AC_INIT(hello, 1.0)
  AC_CONFIG_SRCDIR(hello.c)
  AM_INIT_AUTOMAKE()
  AC_PROG_CC
  AC_OUTPUT(Makefile)
</programlisting>
<calloutlist>
    <callout arearefs="programs"><para><code>bin_PROGRAMS</code> : specifies the name of programs that are building.</para></callout>
    <callout arearefs="sources"><para><code>hello_SOURCES</code> : specifies the sources code that composed the program <quote>hello</quote>.</para></callout>
    <callout arearefs="acinit"><para><code>AC_INIT</code> : initializes the <filename>configure</filename> script. It must be passed as argument the name of the package and the version.</para></callout>
    <callout arearefs="acsrcdir"><para><code>AC_CONFIG_SRCDIR</code> : specifies a file in the source directory. <filename>configure</filename> script checks for the existence of this file to make sur that directory that it is told contains the source code in fact does. Any source file could do.</para></callout>
    <callout arearefs="acinitmake"><para><code>AC_INIT_AUTOMAKE</code> : performs some further initializations that are related to the fact that we are using <application>Automake</application>. If you are writing your <filename>Makefile.in</filename> by hand, then you do not need to call this command.</para></callout>
    <callout arearefs="progcc"><para><code>AC_PROG_CC</code> : checks to see which C compiler you have</para></callout>
    <callout arearefs="output"><para><code>AC_OUTPUT</code> : tells the configure script to generate <filename>Makefile</filename> from <filename>Makefile.in</filename></para></callout>
 </calloutlist>
</programlistingco> 
Create the files and Run :
<screen>
$ aclocal
$ autoconf
</screen>
                The <code>aclocal</code> command installs a file called `aclocal.m4'. It contains the knowed <application>Autoconf</application> macros to be in use in <filename>configure.ac</filename>, like <code>AC_PROG_CC</code>. If you want to include your macros, you can create an <filename>acinclude.m4</filename> file. An other cache directory is created to store the traces of the runs of <code>m4</code>. It is called <filename>autom4te.cache</filename>.</para>
                
                <para>The <code>autoconf</code> command create the <filename>configure</filename> script. Then, Run :
<programlisting>
$ automake -a 
</programlisting>
It displays :
<screen>
configure.ac: installing `./install-sh'
configure.ac: installing `./missing'
Makefile.am: installing `./INSTALL'
Makefile.am: required file `./NEWS' not found
Makefile.am: required file `./README' not found
Makefile.am: required file `./AUTHORS' not found
Makefile.am: required file `./ChangeLog' not found
Makefile.am: installing `./COPYING'
Makefile.am: installing `./depcomp'
</screen>
                This creates copies of <filename>install-sh</filename>, <filename>missing</filename>, <filename>COPYING</filename>, <filename>depcomp</filename>. These files are required to be present by the GNU coding standards. But <filename>NEWS</filename>, <filename>README</filename>, <filename>AUTHORS</filename>, <filename>ChangeLog</filename> are not generated. You have to create them. If you have not them and you attempt to do <code>make distcheck</code>, then it will deliberately fail. To create it :
<screen>
$ touch NEWS README AUTHORS ChangeLog
</screen> 
            Then, you have to run <code>automake -a</code> a second time. This one has created a <filename>Makefile.in</filename> file from <filename>Makefile.am</filename>. In this file, we have specify what are building and the used sources. For a library, you should define the <filename>lib_LIBRARIES</filename> variable. 
            </para>
            <para>Now the package is exactly in the state that the end-user will find it when person unpacks it from a source code distribution. To test you program, you can write :
<screen>
$ ./configure
$ make
$ ./hello

and ...

$ make install
$ make uninstall
$ make dist
...
</screen>
            </para>
            </sect3>
        </sect2>
        <sect2 id="files-adds"><title>File adds</title>
	   <para> To integrate a new module, set of types, in the Tulip project, you must to know which library is concerned : General library, OpenGL library, QT library, ... For each case, the procedure is the same. <filename>tulip/library/tulip-ogl/</filename> is the directory to intergate a library attached to the Opengl library. All of the <filename>.cpp</filename> files are pasted in the <filename>src</filename> subdirectory, the <filename>.h</filename> files in <filename>include/tulip</filename> and <filename>cxx</filename> files in <filename>include/tulip/cxx</filename>. Some modifications of your code shoud be necessary. The inclusion of files of Tulip project (included your work) is made with &lt; and &gt; because the compiler knows the path. For Tulip, the header files is in a special directory : <filename>tulip</filename>.</para>
            <para><code>#include &lt;tulip/TheFile.h></code> is an exemple of the inclusion. </para>
           <para>So, you have to modify two files in the directory of your library to indicate the new files. <filename>include/Makefile.am</filename> is the first. You have to complete a variable containing all <filename>.h</filename> and <filename>.cxx</filename> files with your header files named <code>nobase_include_HEADERS</code>. This name is a choice for the processing of the GNU build system. The second one is <filename>src/Makefile.am</filename> and so, you complete the variable containing all <filename>.cpp</filename> files with your source files : <code>libtulip_ogl_la_SOURCES</code>, <code>libtulip_la_SOURCES</code> or <code>libtulip_qt_la_SOURCES</code> depending of the librairie you complete. You have modified the both <filename>Makefile.am</filename> but the Makefile not. To update it, you have to recreate the <filename>configure</filename> file at the root directory and run it again. To do it, run <code>./gen-conf</code> and <code>./configure</code>. To avoid this procedure at each modification of the <filename>Makefile.am</filename>, you can specify an option when you use <filename>configure</filename> script : <code>--enable-maintainer-mode</code>. See <xref linkend="options"/>, for more details about the options. Now, the next compilation includes your work.
           </para>
        </sect2>
        <sect2 id="directive"><title>Compilation directives : Makefile.am</title>
            <para>If you want to change the directive of compilation for a program or a library, then you have to complete or modify the variables attached to the program or library. This section gives the essential variables (with their forms) in order to a customize compilation.</para>
            <para> <filename>Makefile.am</filename> can use the same syntax as with ordinary makefiles. General variable can be defined, available for all your building objects.
            <variablelist>
                <varlistentry><term><code>INCLUDES = -I/dir1 -I/dir2 -I$(top_srcdir)/src...</code></term>
                <listitem><para>Insert the -I flags that you want to pass to your compiler when it builds executables.</para></listitem>
                </varlistentry>
                
                <varlistentry><term><code>LDFLAGS = -L/dir1 -L/dir2 ...</code></term>
                <listitem><para> Lists all the library files that will be compiled with make and installed with <code>make install</code> under <code>prefix/lib</code>.</para></listitem>
                </varlistentry>

                <varlistentry><term><code>LDADD = MyClasse.o ... $(top_builddir)/dir1/libmylib.la ... -lmylib ...</code></term>
                <listitem><para>List a set of object files, uninstalled libraries and installed libraries that you want to link in with all of your executables. Please refer to uninstalled libraries with absolute pathnames. Because uninstalled libraries are built files, you should start your path with <code>$(top_builddir)</code>.</para><para> There is a set of variables like <code>top_builddir</code> which are defined by <code>configure</code> when it processes a <code>Makefile</code> and they can be used in all others variables presented here. 
                        <variablelist>
                            <varlistentry><term><code>srcdir</code></term>
                                <listitem><para>The relative path to the directory that contains the source code for that <code>Makefile</code>.</para></listitem>
                            </varlistentry>

                            <varlistentry><term><code>abs_srcdir</code></term>
                                <listitem><para>Absolute path of <code>srcdir</code>.</para></listitem>
                            </varlistentry>

                            <varlistentry><term><code>top_srcdir</code></term>
                                <listitem><para>The relative path to the top-level of the current build tree. In the top-level directory, this is the same as <code>srcdir</code>.</para></listitem>
                            </varlistentry>
                            
                            <varlistentry><term><code>abs_top_srcdir</code></term>
                                <listitem><para>Absolute path of <code>top_srcdir</code>.</para></listitem>
                            </varlistentry>
                            <varlistentry><term><code>builddir</code></term>
                                <listitem><para>Rigorously equal to <quote>./</quote>. Added for the symmetry only.</para></listitem>
                            </varlistentry>

                            <varlistentry><term><code>abs_builddir</code></term>
                                <listitem><para>Absolute path of <code>builddir</code>.</para></listitem>
                            </varlistentry>

                            <varlistentry><term><code>top_builddir</code></term>
                                <listitem><para>The relative path to the top-level of the current build tree. In the top-level directory, this is the same as <code>builddir</code>.</para></listitem>
                            </varlistentry>
                            
                            <varlistentry><term><code>abs_top_builddir</code></term>
                                <listitem><para>Absolute path of <code>top_builddir</code>.</para></listitem>
                            </varlistentry>

                            </variablelist>
                </para></listitem>
                </varlistentry>
           </variablelist>
                The follownig targets are used for a special directory or for special buildings:
            <variablelist>
                <varlistentry><term><code>bin_PROGRAMS = prog1 prog2 ...</code></term>
                <listitem><para> Lists the executable files that will be compiled with <code>make</code> and installed with <code>make install</code> under <code>prefix/bin</code>, where <code>prefix</code> is usually <code>/usr/local</code> but you can specify to an other value.</para></listitem>
                </varlistentry>
                
                <varlistentry><term><code>lib_LIBRARIES = lib1.la lib2.la ...</code></term>
                <listitem><para> Lists all the library files that will be compiled with make and installed with <code>make install</code> under <code>prefix/lib</code>.</para></listitem>
                </varlistentry>

                <varlistentry><term><code>SUBDIRS = dir1 dir2 ...</code></term>
                <listitem><para> Lists all the subdirectories that we want to build before building this directory. <code>make</code> will recursively invoke itself in each subdirectory before doing anything on the current directory. If you mention the current directory <quote>.</quote> in <code>SUBDIRS</code> then the current directory will be built first, and the subdirectories will be build afterwords.</para></listitem>
                </varlistentry>

                <varlistentry><term><code>EXTRA_DIST = file1 file2 ...</code></term>
                <listitem><para> Lists any files that you want to include into your source code distribution. </para></listitem>
                </varlistentry>

                <varlistentry><term><code>include_HEADERS = fich1.h fich2.h ...</code></term>
                <listitem><para> Lists all the public header files in this directory that you want to install to <code>prefix/include</code>. If you change the keyword <code>include</code> by <code>noinst</code>, then you can specify headers that will not be installed.</para></listitem>
                </varlistentry>
           </variablelist>
                For each progam, a set of variables should be declared : 
            <variablelist>
                <varlistentry><term><code>prog_SOURCES = fich1.c fich2.c ...</code></term>
                <listitem><para> Lists all the files that compose the source code of the program. Header files can be specified here.</para></listitem>
                </varlistentry>

                <varlistentry><term><code>prog_LDADD = $(top_builddir)/dir1/lib1.a -lext1 -lext2 ...</code></term>
                <listitem><para> Lists the libraries that need to be linked with your source code. Installed libraries should be mentioned using `-l' flags. Uninstalled libraries must be mentioned using absolute pathnames. <code>Please use $(top_buiddir) to build a path to a directory. </code></para></listitem>
                </varlistentry>

                <varlistentry><term><code>prog_LDFLAGS = -L/dir1 -L/dir2 -L/dir3 ...</code></term>
                <listitem><para> Adds the `-L' flags that are needed to find the installed libraries that you want to link in <code>prog_LDADD</code>.</para></listitem>
                </varlistentry>

                <varlistentry><term><code>prog_DEPENDENCIES = dep1 dep2 dep3 ...</code></term>
                <listitem><para>Lists any targets that you want to build before building this program..</para></listitem>
                </varlistentry>
            </variablelist>
            In the same way, you can specify variable for a specialy library or shared library by prefixing the variable by the name of the library.</para>
            <para>
            Occasionally it is useful to know which Makefile variables that Automake uses for compilations. For instance you might need to do your own compilation in some special cases. Some variables are inherited from Autoconf; these are CC, CFLAGS, CPPFLAGS, DEFS, LDFLAGS, LIBS, CXX, CXXFLAGS, ... There are some additional variables which Automake itself defines: 
            <variablelist>
                <varlistentry><term><code>AM_CPPFLAGS</code></term>
                <listitem><para>The contents of this variable are passed to every compilation which invokes the C preprocessor; it is a list of arguments to the preprocessor. For instance, <code>-I</code> and <code>-D</code> options should be listed here. Automake already provides some <code>-I</code> options automatically. <code>AM_CPPFLAGS</code> is ignored in preference to a per-executable (or per-library) <code>_CPPFLAGS</code> variable if it is defined. </para></listitem>
                </varlistentry>

                <varlistentry><term><code>INCLUDES</code></term>
                <listitem><para>This does the same job as <code>AM_CPPFLAGS</code>. It is an older name for the same functionality. This variable is deprecated; we suggest using <code>AM_CPPFLAGS</code> instead.</para></listitem>
                </varlistentry>

                <varlistentry><term><code>AM_CFLAGS</code></term>
                <listitem><para>This is the variable which the Makefile.am author can use to pass in additional C compiler flags. It is more fully documented elsewhere. In some situations, this is not used, in preference to the per-executable (or per-library) <code>_CFLAGS</code>.</para></listitem>
                </varlistentry>

                <varlistentry><term><code>COMPILE</code></term>
                <listitem><para>This is the command used to actually compile a C source file. The filename is appended to form the complete command line.</para></listitem>
                </varlistentry>

                <varlistentry><term><code>AM_LDFLAGS</code></term>
                <listitem><para>This is the variable which the Makefile.am author can use to pass in additional linker flags. In some situations, this is not used, in preference to the per-executable (or per-library) <code>_LDFLAGS</code>.</para></listitem>
                </varlistentry>

                <varlistentry><term><code>LINK</code></term>
                <listitem><para>This is the command used to actually link a C program. It already includes -o $@ and the usual variable references (for instance, <code>CFLAGS</code>); it takes as <quote>arguments</quote> the names of the object files and libraries to link in.</para></listitem>
                </varlistentry>
            </variablelist>
           </para>
        </sect2>
        <sect2 id="prefix"><title>Variable prefix</title>
            <variablelist>
                <varlistentry><term><code>nobase_</code></term>
                <listitem><para>e.g. <code>nobase_include_HEADERS</code>, mentionned that all the headers files will not be installed in the same place. It is possible to make subdirectories. <code>nobase_</code> should be specified first when used in conjunction with either <code>dist_</code> or <code>nodist_</code>.</para></listitem>
                </varlistentry>
            </variablelist>
            <variablelist>
                <varlistentry><term><code>noinst_</code></term>
                <listitem><para>denotes data which do not need to be installed.</para></listitem>
                </varlistentry>
            </variablelist>
            <variablelist>
                <varlistentry><term><code>dist_ /nodist_</code></term>
                <listitem><para>denotes files or data that will be included to the distribution (or not with <code>nodist_</code>).</para></listitem>
                </varlistentry>
            </variablelist>
        </sect2>
        <sect2 id="gnu-ref"><title>References</title>
            <para>Developing software with GNU : the GNU build system - <ulink url="http://www.amath.washington.edu/~lf/tutorials/autoconf/toolsmanual.html#SEC30"/></para>
            <para>Autoconf Manual - <ulink url="http://www.gnu.org/software/autoconf/manual/"/></para>
            <para>Automake Manual - <ulink url="http://www.gnu.org/software/automake/manual/"/></para>
        </sect2>
    </sect1>
    <!--===================================================================================    -->
</chapter>


<chapter id="doc-guidelines"><title>Documentation Guidelines</title>
    <!--======  DEFINITIONS   ========================================================    -->
    <sect1 id="definitions"><title>Definitions</title>
	<orderedlist>
	<listitem id="docbook"><para>Docbook is a collection of standards and tools for technical publishing. A Docbook file is composed of SGML(<xref linkend="sgml"/>) tags and is also dependant of a Document Type Definition(<xref linkend="dtd"/>). Docbook has defined standard DTD that you can find in the docbook tools.</para></listitem>

	<listitem id="dtd"><para>DTD : Document Type Definition. The DTD defines the vocabulary of content elements that an author can use and how they relate to each other. For example, a book element can contain a title element, any number of para elements for paragraphs, and any number of chapter elements. </para></listitem>

	<listitem id="sgml"><para>SGML : Standard Generalized Markup Language, XML : Extensible Markup Language</para></listitem>
    
        <listitem id="xsl"><para>XSL (Extensible Stylesheet Language) is a language of description used for the transformation of the sgml file into formatted ouput: XSL processors like xsltproc, saxon or xalan, ... do that.</para></listitem>
        <listitem id="cata"><para>Catalog : In XML, it provides a mapping from generic addresses to specific local directories on a given machine. A catalog can be used to locate the DocBook DTD, system entity files, and stylesheet files during processing.</para></listitem>
	</orderedlist>
    </sect1>
    <!--==============================================================================    -->

    <!--======= Tools installation  ==================================================    -->
    <sect1 id="tools-install"><title>Tools installation</title>
        <sect2 id="duck-install"><title>Docbook XSL Stylesheet</title>
            <para> There is a great reference for installing tools : <ulink url="http://www.sagehill.net/docbookxsl/ToolsSetup.html">Docbook XSL : the guide</ulink>.</para>
            <para>To write a manual using Docbook and the XSL stylesheets, we need four tools : 
            <itemizedlist>
            <listitem>
                <para>Docbook DTD</para>
            </listitem>
            <listitem><para>Docbook XSL stylesheets</para></listitem>
            <listitem><para>XSL processor</para></listitem>
            <listitem><para>XSL-FO processor (optional)</para></listitem>
            </itemizedlist>
            There are RPM (docbook-dtds, docbook-style-xsl), Debian (docbook-xml, docbook-xsl) packages for Linux systems, Fink packages for Mac systems, and Cygwin and other packages for Windows systems. The installation of Docbook and the XSL stylesheet create a file named <filename>/etc/xml/catalog</filename>. It contains the informations about all others catalogs to resole the path of the DTDs and the stylsheets from the URI.</para>
            <sect3 id="xsl-install"><title>Manual Installation : Docdoob XSL stylesheet</title>
                <para>As we have some problems with the DTD providing by the distributions, Tulip gives the DTD 4.4 of Docbook XML and is located in <filename>$TULIPDIR/docs/common/dtd</filename>. So, this section is for informations. The XSL packages seem to have great catalog resolutions, but if you have problems, this section can help you.</para>
                <para>If you need another solution or you have problems for the compilation, you can download the source package on oasis <ulink url="http://www.oasis-open.org/docbook/xml/">web site</ulink> for Docbook and on the <ulink url="http://sourceforge.net/projects/docbook/">SourceForge page</ulink> of XSL stylesheets. The Docbook sources are in a <code>zip</code> file. Unzip your package in a directory in the place you prefer. The Docbook XML DTD consists of a main file <filename>docbookx.dtd</filename>, several module files and a catalog file, named <filename>catalog.xml</filename>. To update the changes of location of your DTD, edit the file <filename>CatalogManager.properties</filename> in <filename>$TULIPDIR/docs/common/</filename>. Add the catalog file with its asbolute path to the <code>catalogs</code> variable.
<programlisting>
CatalogManager.properties :

catalogs=/etc/xml/catalog<emphasis>;/home/bardet/docbook-4.4/catalog.xml</emphasis>
relative-catalogs=false
static-catalog=yes
catalog-class-name=org.apache.xml.resolver.Resolver
verbosity=1
</programlisting>

                Concerning the XSL stylesheet package, you just have to do the same thing. You can execute the script of intallation. You have to add the reference of the catalog too. Edit the file <filename>catalog.xml</filename> and complete the <code>catalogs</code> variable with the reference of the catalog of your XSL stylesheet.
                This catalog resolution make sure that the path, the differences could be find in all Operation Systems. </para>
                </sect3>


                <sect3 id="xsl-proc"><title>XSL processor</title>
                <para>Currently, there are three to do XSL Transform processing with the recommendations of XSL : saxon (<ulink url="http://saxon.sourceforge.net/"/>), xalan (<ulink url="http://xml.apache.org/xalan-j/"/>), and xsltproc (<ulink url="http://xmlsoft.org/XSLT/xsltproc2.html"/>). For the Tulip project, we have decides to use <application>Saxon</application> for the XSL processor. <application>Xsltproc</application> is the xslt c library for gnome. This program is a way to use the library <emphasis>libxslt</emphasis> with a command line tool for applying XSLT stylesheets to XML documents. This application runs quickly but does not include the implementation of the extensions. <application>Xalan</application> is an other solution but <application>Saxon</application> is the most recommanded.</para>

                <para><application>Saxon</application> is a free processor written in Java, so it can be run on any operating system with a modern Java interpreter. To install it, you have to download on sourceforge the last release 6.5.4. for debian, it exists a deb package. This is the full version that implements the XSLT 1.0 standard. It runs on Java system and provides opportunities for extensions. For Windows, it exists the <application>Instant Saxon</application> a precompiled version that runs only on Microsoft Windows. Saxon is distributed as a zip package. You have to unzip it into a suitable location. It gives three <filename>.jar</filename> files ; <filename>saxon.jar</filename> contains the XSLT processor. In according to the location, you have to update your CLASSPATH. You need to include the full path to the necessary .jar files in the CLASSPATH environment variable. To update it :
<screen>
CLASSPATH=$CLASSPATH:/usr/saxon/saxon.jar:\
/usr/docbook-xsl/extensions/saxon653.jar
export CLASSPATH
</screen>
                If your CLASSPATH is incorrect, you get an error message about <methodname>NoClassDefFoundError</methodname>. To generalize it, you have to change your <filename>.bashrc</filename> or <filename>.bash_profile</filename>. In this example, a second package is included : <filename>/usr/docbook-xsl/extensions/saxon653.jar</filename>, in Fedora Core 4, it is located in <filename>/usr/share/sgml/docbook/xsl-stylesheets/extensions/</filename>. It contains the implementation of the extensions of XSL Transformations. This extensions are necessary for the manage of certain tags and are included in the docbook tools. The general syntax for compilation is like followed :

                <cmdsynopsis><command>java com.icl.saxon.StyleSheet </command>
                        <arg><option>options</option></arg>
                        <arg>file.docbook</arg>
                        <arg>file.xsl</arg>
                        <arg><option>param=value</option></arg>
                </cmdsynopsis>
               
               However, Tulip provides the sources of saxon and you do not worry to this installation to avoid the complicated installation.</para>
               <warning><para> This system of catalog resolution is made for finding located files. With the packages of Fedora and perhaps with others distribution, the catalogs include a declaration with URL adresses. So the catalog resolving processor try to connect on the Net.  
<programlisting>
&lt;!DOCTYPE catalog PUBLIC "-//OASIS//DTD XML Catalogs V1.0//EN"
"http://www.oasis-open.org/commitees/entity/release/1.0/catalog.dtd">
</programlisting>
                It should be erased in all catalog files which blocks the offline compilation (/etc/xml/catalog, /usr/shar/sgml/docbook/xmlcatalog, ...).</para>
            </warning>
               </sect3>
                <sect3 id="xsl-fo"><title>XSL-FO processor for PDF output</title>
                <para>To transform the docbook sources in pdf documents, we need to use an other format FO. It is running with a stylsheet in docbook-xsl package. The role of the XSF-Fo processor is to transform FO files in printable files, like pdf. You have to install <application>passivetex</application>. Fedora and Debian includes this package, but you can download and install it with its web site, <ulink url="http://www.tei-c.org.uk/Software/passivetex/"/>. It exists a program named <code>pdfxmltex</code> giving tex macros for the XSL-Fo processing.</para>
            </sect3>
        </sect2>
        <sect2 id="dox-install"><title>Doxygen</title>
            <para>It can already be in your distribution. For distributions like Debian or Fedora Core, you can used : <cmdsynopsis><command>yum</command><arg><option>install</option> doxygen</arg></cmdsynopsis><cmdsynopsis><command>apt-get</command><arg><option>install</option> doxygen</arg></cmdsynopsis> For another solution, you can find source files and <application>CVS</application> repository in the web site of Doxygen.</para>
        </sect2>
    </sect1>
    <!--==============================================================================    -->

    <!--======= Handwriting for the manuals  =========================================    -->
    <sect1 id="written"><title>Handwriting for the manuals</title>
        <para>Some works on the Tulip project lead to make a part of a handbook for developer or users. Docbook utilities are used to create them. </para>

        <para>Docbook is a DTD (Document Type Definition) for XML or SGML document that define elements. It is a kind of grammar of the source document. This is in relation with stylesheets (DSSSL or XSL) which allow you to publish on the Web ( in HTML, XHTML) on a printable documentation (PS, PDF, RTF...) with your Docbook documents. The principal advantages of the dobook format is the possibility to seperate the contents of the forms. The tools which can transform the source documents are generic and can pratically run on all Operation Systems. Docbook is the successor of LinuxDoc.</para>

        <para>For Tulip documentation, the source documents are in XML, because XML leads to take the place of SGML to alleviate compatibility problems with browser software. It's a new, easier version of the standard rules that govern the markup itself. To find all of the xml elements to composed your own document, you can see : <ulink url="http://www.docbook.org/tdg5/en/html/pt02.html">http://www.docbook.org/tdg5/en/html/pt02.html</ulink></para>

	<para>For each document, a set of XML files should be created. To help the editing of the handbook, it is possible to use general editors like kate, emacs, quanta. See <ulink  url="http://i18n.kde.org/doc/doc-primer/docbook-editors.html"> Docbook Editors</ulink>. To configure Kate, select <filename>Configure Kate</filename> -> <filename>Settings</filename> -> <filename>Configure Kate</filename>. Select the plugin item from the application tree and check the <filename>Kate XML Completion</filename>, and the <filename>Kate XML Validation</filename> boxes. </para>
    
        <para>To compile the handbooks, you just have to type <code>make html</code>. If you want to test the validation of the sources of the handbooks, type <code>make check</code>. The lsat command is <code>make pdf</code>, it produces the printable output.</para>

        <sect2 id="tricks"><title>Some Tricks</title>
	    <para>
	    <programlistingco>
	    <areaspec>
		<area id="xml" coords='2'/> <area id="comments" coords='3'/><area id="doctype" coords='4'/>
            </areaspec>
<programlisting>
&lt;?xml version='1.0'?&gt;
<emphasis>&lt;!-- My first Docbook file --></emphasis>
&lt;!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook XML V4.4//EN"
    "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd"&gt;
	    </programlisting>
	    <calloutlist>
		<callout arearefs="xml"> <para>defined that it is a XML document</para></callout>
		<callout arearefs="comments"> <para>the comments are writing between &lt;!-- and --&gt;</para></callout>
		<callout arearefs="doctype"> <para>DTD, Document Type Declaration with pulic identifier</para> </callout>
	    </calloutlist>
	    </programlistingco>
            The identification of the DTD is used by the document to know which root element is. The declaration could have a different aspect if you use the system identifier : <code>&lt;!DOCTYPE book SYSTEM "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd"></code> Here, <quote>OASIS</quote> is the owner, the declaration is <quote>DTD Docbook XML V4.4</quote> and the language is English <quote>EN</quote>. The keyword <quote>book</quote> specifies that the root element is <emphasis>book</emphasis>. An example of the structure of a Docbook file is like followed.
<programlisting>  <!--    84 caracters max   -->
&lt;!DOCTYPE book SYSTEM 
    "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
&lt;book> 
    &lt;bookinfo> 
    &lt;title>My First Book&lt;/title>

        &lt;author>&lt;firstname>Jean-Pierre&lt;/firstname>&lt;surname>DUPONT
                    &lt;/surname>&lt;/author>
        &lt;copyright>&lt;year>2005&lt;/year>
                      &lt;holder>Jean-Pierre DUPONT&lt;/holder>
          &lt;/copyright>
    &lt;/bookinfo>
    &lt;preface> ... &lt;/preface>
    &lt;chapter> ... &lt;/chapter>
        &lt;sect1> &lt;title>..&lt;/title>
            &lt;para> ...&lt;/para>
        &lt;/sect1>
    &lt;chapter> ... &lt;/chapter>
    &lt;chapter> ... &lt;/chapter>
    &lt;appendix> ... &lt;/appendix>
    &lt;appendix> ... &lt;/appendix>
    &lt;index> ... &lt;/index>
&lt;/book>
</programlisting> Each blocks of text is in a <emphasis>para</emphasis> element.</para>
        <sect3 id="valid"><title>Validation</title>
        <para>
        The validity of a document is very difficult to detect, so we use a program to do that. A validating parser is a program that can read the DTD and determine whether the exact order of elements in the document is valid according to the DTD. </para>
        <para>To determinate if the XML code is valid, the program <application>xmllint</application> can be used with the option --valid. This program is a parser dependent of the library <emphasis>libxml2</emphasis>.<cmdsynopsis><command>xmllint</command><arg><option>--valid  --noout</option> myfile.docbook</arg></cmdsynopsis> 
        When there are errors in the document, <application> xmllint </application> detects the number line and displays the form that it should be.
<screen>
index.docbook:485: element sect2: validity error : Element sect2 
content does not follow the DTD, expecting (sect2info? , (title , 
subtitle? , titleabbrev?) , (toc | lot | index | glossary | 
bibliography)* , (((calloutlist | glosslist | bibliolist | itemizedlist
| orderedlist | segmentedlist | simplelist | variablelist | caution |
important | note | tip | warning | literallayout | programlisting |
programlistingco | screen | screenco | screenshot | synopsis |
cmdsynopsis | funcsynopsis | classsynopsis | fieldsynopsis | 
constructorsynopsis | destructorsynopsis | methodsynopsis | formalpara
| para | simpara | address | blockquote | graphic | graphicco | 
mediaobject | mediaobjectco | informalequation | informalexample | 
informalfigure | informaltable | equation | example | figure | table |
msgset | procedure | sidebar | qandaset | task | anchor | bridgehead |
 remark | highlights | abstract | authorblurb | epigraph |indexterm | 
beginpage)+ , (refentry* | sect3* | simplesect*)) | refentry+ | sect3+ |
 simplesect+) , (toc | lot | index | glossary | bibliography)*), got (
refentry)
&lt;/sect2>
                   ^
make: *** [check] Erreur 1
</screen>

        It exists several attempts to produce an print or web publishing. Recently, the XML workgroup has made a standard Extensible Style Language (XSL). It provides s set of stylesheet able to transform the Docbook documents. DSSSL is an other possibility, but we use the XSL stylesheet for the Tulip project. This stylesheet is an argument for the compilation with an XSL processor for the XSL transformations.</para>
        </sect3>
	</sect2>
        <sect2 id="duck-faq"><title>Docbook FAQ</title>
            <qandaset>
                <qandaentry>
                    <question><para>how to separate the work in several files ?</para></question>
                    <answer><para>
                    The first solution to write a part of a handbook is to complete the main document. To avoid that several persons work on the same file, it exists a solution to cut the docbook file. You can write a section or a chapter and you just have to include your part in the main file. To create a valid file for the compiler, you shoud modify the head of a docbook file and specify the kind of document you do. For a chapter, your file is like followed :
<programlisting>
&lt;!DOCTYPE chapter PUBLIC "-//OASIS//DTD Docbook XML V4.4//EN">
&lt;chapter> 
    &lt;title>My personal Chapter&lt;/title>
    &lt;sect1> ... &lt;/sect1>
&lt;/chapter>
</programlisting>
           The identification gives the kind of file you write. For including your work, you just have to complete the declaration of the main file and insert a special tag located at the place that you want the inclusion. Don't forget to erase the declaration of your work. The file must begin with the markup <quote>chapter</quote>.
<programlisting>
&lt;!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook V4.4//EN" [
  &lt;!ENTITY myPersonalFile SYSTEM "myFile.xml"
]&gt;
&lt;book>
...
&lt;/chapter>
&#038;myPersonalFile;
&lt;chapter>
...
</programlisting>
                      </para></answer>
                </qandaentry>
                <qandaentry>
                    <question><para>How to insert a figure ?</para></question>
                    <answer><para>the element uses for the insert of a figure is <quote>&lt;figure></quote>. It enable the numerotation of the figures. Warning, the width of the figures should not exceed a certain value to avoid that it is truncated in the pdf transform. You can specify a title and other parameter in the limits of the DTD. 
<programlisting>
&lt;figure> &lt;title>Screenshot of the result&lt;/title>&lt;graphic
fileref="doxygen-ex.png"/>&lt;/figure></programlisting></para></answer>
                </qandaentry>
                <qandaentry>
                    <question><para>How to make annontation in a program listing (or in a console listing) ?</para></question>
                    <answer><para>See <ulink url="http://www.sagehill.net/docbookxsl/AnnotateListing.html#Callouts">DocBook XSL : the complete guide</ulink></para>
                    <para>To do that, you use the set of tags <code>programlisting, co, calloutlist, callout</code>.
<programlisting>
&lt;programlisting>
class MyClasse{ &lt;co id="myid" linkends="mylink"/>
};    
&lt;/programlisting>
&lt;calloutlist>
    &lt;callout arearefs="myid" id="mylink">
        &lt;para>... comments ...&lt;/para>
    &lt;/callout>
&lt;/calloutlist>
</programlisting>
                The <code>programlisting</code> contains the program that you want to display. It is a verbatim mode. Warning, special caracters could be not allow : &lt;, for example. The <code>code</code> element represents the callout you want to place. The location of the insertion is important because it is the location on display. Two attributes are essential : <code>id</code> for the identification and <code>linkends</code> for indicate which comments is linked with the callout. After the <code>programlisting</code> element, we use a <code>calloutlist</code> element to define a list of comments. each comment is contained in a <code>callout</code> element. It has attributes whose <code>arearefs</code> to make a reference to callouts and id for the identification.</para>
                
                <para>It exists an other solution but it is more difficult. You have to specify coordinates of place where you want a callout. This solution is a esay and quicky way to comment your program listing.
<programlisting>
class MyClasse{ <co id="myid" linkends="mylink"/>
};    
</programlisting>
<calloutlist>
    <callout arearefs="myid" id="mylink"><para>... comments ...</para></callout>
</calloutlist>
                To adapt the case to the console listing, you should use the <code>screenco, screen, callout, ...</code> elements.</para></answer>
                </qandaentry>
            </qandaset>
        </sect2>
    </sect1>
    <!--==============================================================================    -->

    <!--======= Code documentation  ==================================================    -->
    <sect1 id="doxygen"><title>Code documentation</title>
        <sect2 id="presentation_dox"><title>Presentation</title>
	<para><application>Doxygen</application> is a documentation system for several languages like C++. It can generate an on-line documentation browser (in HTML), a set of manpages, an off-line reference manual (in LaTeX) and/or others from the set of documented source files of your project. This kind of documentation is a necessary tool for developers to find informations about the code. It is not a way to explain how it is imagined but which possibilities you have. It is available for several distributions like Fedora Core, Debian, Gentoo and others,..  Windows, MacOs and Sun Solaris too.
	</para>
	<para>To create your first <application>Doxygen</application> documentation, you need a config file .cfg or .doxygen. To generate it :
	<cmdsynopsis><command>doxygen</command><arg><option>-g</option> myfile.doxygen</arg></cmdsynopsis>
        The file contains the options you can choose for the documentation generation. Comments indicates how to use this variables. The INPUT variable contains the files or directories to find the source files. When you have set all tags with good values, you can generate the documentation. <application>Doxygen</application> checks the source files to extract the informations in special comments and tags. See this page for the informations about the variables : <ulink url="http://www.stack.nl/~dimitri/doxygen/config.html">http://www.stack.nl/~dimitri/doxygen/config.html</ulink>. To create it :
	<cmdsynopsis><command>doxygen</command><arg>myfile.doxygen</arg></cmdsynopsis>
        By default, it creates directories : html, latex, and/or man, ...
	</para>
        <para>For the <application>Tulip</application> project, the configuration files are still created and are located in the subdirectory of the special library, for example in <filename>$TULIPDIR/docs/doxygen/tulip-lib</filename>.</para>
        </sect2>
	<sect2 id="dx-comments"><title>Developer comments</title>
	    <para>The code documentation, generated by <application>Doxygen</application> is completely dependant of the developer comments. It is important that developers follow the grammar rules. </para>
	    <para>So the blocks of documentation in the sources files are the C++ comment blocks. For each item of code, there are two types of descriptions, which together form the documentation : a brief description and detailed description. A detail description is used to explain generously the existence of an item.
	    <screen>
/**
* detailed description
*/

or 

/*!
* detailed description
*/

or 

/*!
 detailed description
*/

or others ....
		</screen>
	    To make a brief description, you can use the command <methodname>\brief</methodname>. This command ends at the end of a paragraph, so the detailed description follows after an empty line. An other option is to use a special C++ style comment which does not span more than one line.
<screen>
/*! \brief Brief description.............
*         ...............
*
*  Detailed description
*/

or 

/// Brief description 
/** Detailed description. */

or 

//! Brief descripion.

//! Detailed description 
//! starts here.

or others ....
	    </screen>
	    For more details, the web site of <ulink url="http://www.doxygen.org/docblocks.html">Doxygen</ulink> explains it. 
	    In general, the comments must be before the declaration or definition of a type, a function or a member. If you want to putting the documention after, you have to add a marker &lt;. Note that you can place your comment at other places using some tags like \class, \union, \fn, \var, ... or @class, @union, @fn, @var, ...
	    </para>
	    <para>
	    It exists several tags to help you for commenting and writing a description : all of it begin with a backflash <symbol>\</symbol> or an at-sign<symbol>@</symbol>.
	    <itemizedlist>
		<listitem><para>@author, <emphasis>name of the author</emphasis>. </para></listitem>
		<listitem><para>@param, <emphasis>to write a special comment on a parameter of a method or function</emphasis> </para></listitem>
		<listitem><para>@see, <emphasis>to make a reference to an other object or function</emphasis></para></listitem>
		<listitem><para>@return, <emphasis>to indicate the exit of a function</emphasis></para></listitem>
		<listitem><para>@date, <emphasis>date of creation</emphasis></para></listitem>
		<listitem><para>@note, <emphasis>desribe a role</emphasis></para></listitem>
		<listitem><para>@attention, <emphasis>write a caution</emphasis></para></listitem>
		<listitem><para>@warning</para></listitem>
		<listitem><para>@pre, <emphasis>write a prerequisite</emphasis></para></listitem>
		<listitem><para>@remark</para></listitem>
	    </itemizedlist>
            The complete list is on this <ulink url="http://www.stack.nl/~dimitri/doxygen/commands.html">page</ulink> in the <application>Doxygen</application> web site.
	    </para>

            <para><example><title>Doxygen : A simple source file</title>
<para><programlisting>
// ... comments not include  ...
///  A example of class : MyClass. 
/**
    a more detail class description :
    \author Me
    \date 29/07/2005
*/
#include &lt;string>
class MyClass
{


    /* ... comments not include ... */
    public:
        /** the constructor of the class */

        /**  the detail description of the constructor. */
        MyClass(){i=0;}
 
        //! A destructor.
        ~MyClass(){}

        /// drawing of a string
        /**
            \param s the string to display
            \return there is no return
            @sa MyClass(), ~MyClass()
        */
        void draw(const char *s="Hello World");

        /* exemple of doc comments not before the declaration */
        unsigned int getI(){return i;} /**&lt;@return the number 
                                                the value of i */
    private:
        unsigned int i;


    /** @var i
        @brief, you can put the comments where you want 
                                    with the special tags */
};
</programlisting>

</para></example></para>

            <para>To update the Documentation of Tulip, you just have to use the makefile and so write : <filename>make docs</filename>.</para>
	</sect2>

        <sect2 id="dow-faqs"><title>Doxygen FAQ</title>
	<qandaset>
	    <qandaentry>
		<question><para>How to insert a block of code ?</para></question>
		<answer><para> To illustrate your documentation, you can insert a block of code in a description between <quote>\code</quote> and <quote>\endcode</quote>. This code is written in the documentation with highlighting syntax. </para></answer>
	    </qandaentry>
            <qandaentry>
		<question><para>How to force an end of line ?</para></question>
		<answer><para>Use the tag <methodname>\n</methodname>.</para></answer>
	    </qandaentry>
            <qandaentry>
		<question><para>How to make doxygen ignore code fragment ?</para></question>
		<answer><para>It exists two ways to resolve this questions. The first one is to use the tags <quote>\cond</quote> and <quote>\endcond</quote> to skip the internal code. The second way is to use the preprocessor of Doxygen. In the configuration file, you specify the MACRO and you verify if the value of PREPROCESSING is to yes. Then, you set PREDEFINED to DOXYGEN_SHOULD_SKIP_THIS.

<programlisting>
#ifndef DOXYGEN_SHOULD_SKIP_THIS

 /* code that must be skipped by Doxygen */

#endif /* DOXYGEN_SHOULD_SKIP_THIS */
</programlisting>
</para></answer>
	    </qandaentry>
            <qandaentry>
                    <question><para>How to insert a equation ?</para></question>
                    <answer><para>See the <ulink url="http://www.stack.nl/~dimitri/doxygen/formulas.html">Doxygen web site</ulink></para><para>Doxygen allos you to put Latex formulas in the ouput (just for HTML and latex format). Three ways are avaible. If you want to include formulas in-text, you have to put formulas between a pair of <quote>\f$</quote>
                    <screen>
\f$ AB = \sqrt{BC^2 + CA^2} \f$
                    </screen> 
                    The second way is for a centerd display on a seperate line. These formulas should be put between <quote>\f[</quote> and <quote>\f]</quote> commands.</para>
                    <para>The third way is to used formulas or other latex elements that are not in a math environment. It can be specified using \f{<emphasis>environment</emphasis>}, where <emphasis>environment</emphasis> is the latex environment, the corresponding end commands is <quote>\f}</quote></para></answer>
                </qandaentry>
	</qandaset>
        </sect2>
    </sect1>
    <sect1 id="docs-ref"><title>References</title>
        <para>Docbook XSL : the complete Guide <ulink url="http://www.sagehill.net/docbookxsl/index.html">http://www.sagehill.net/docbookxsl/index.html</ulink></para>

        <para>The Duck Book - <ulink url="http://www.oreilly.com/catalog/docbook/chapter/book/docbook.html">Docbook : the Definitive Guide </ulink></para>

        <para>The KDE documentation primer : recommandations to write correctly in Docbook - <ulink  url="http://i18n.kde.org/doc/doc-primer/index.html">http://i18n.kde.org/doc/doc-primer/index.html</ulink></para>

         <para>Doxygen web site - <ulink url="http://www.docbook.org/tdg/en/html/part2.html">http://www.docbook.org/tdg/en/html/part2.html </ulink></para>
    </sect1>
</chapter>
</book>


