
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Using SIP &#8212; SIP v4.19.17 Reference Guide</title>
    <link rel="stylesheet" href="_static/riverbank.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/logo_tn.png"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="The SIP Command Line" href="command_line.html" />
    <link rel="prev" title="Installation" href="installation.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="command_line.html" title="The SIP Command Line"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SIP v4.19.17 Reference Guide</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="using-sip">
<span id="ref-using"></span><h1>Using SIP<a class="headerlink" href="#using-sip" title="Permalink to this headline">¶</a></h1>
<p>Bindings are generated by the SIP code generator from a number of specification
files, typically with a <code class="docutils literal notranslate"><span class="pre">.sip</span></code> extension.  Specification files look very
similar to C and C++ header files, but often with additional information (in
the form of a <em>directive</em> or an <em>annotation</em>) and code so that the bindings
generated can be finely tuned.</p>
<div class="section" id="a-simple-c-example">
<span id="ref-simple-c-example"></span><h2>A Simple C++ Example<a class="headerlink" href="#a-simple-c-example" title="Permalink to this headline">¶</a></h2>
<p>We start with a simple example.  Let’s say you have a (fictional) C++ library
that implements a single class called <code class="docutils literal notranslate"><span class="pre">Word</span></code>.  The class has one constructor
that takes a <code class="docutils literal notranslate"><span class="pre">\0</span></code> terminated character string as its single argument.  The
class has one method called <code class="docutils literal notranslate"><span class="pre">reverse()</span></code> which takes no arguments and returns
a <code class="docutils literal notranslate"><span class="pre">\0</span></code> terminated character string.  The interface to the class is defined in
a header file called <code class="docutils literal notranslate"><span class="pre">word.h</span></code> which might look something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Define</span> <span class="n">the</span> <span class="n">interface</span> <span class="n">to</span> <span class="n">the</span> <span class="n">word</span> <span class="n">library</span><span class="o">.</span>

<span class="k">class</span> <span class="nc">Word</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">the_word</span><span class="p">;</span>

<span class="n">public</span><span class="p">:</span>
    <span class="n">Word</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">w</span><span class="p">);</span>

    <span class="n">char</span> <span class="o">*</span><span class="n">reverse</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The corresponding SIP specification file would then look something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Define</span> <span class="n">the</span> <span class="n">SIP</span> <span class="n">wrapper</span> <span class="n">to</span> <span class="n">the</span> <span class="n">word</span> <span class="n">library</span><span class="o">.</span>

<span class="o">%</span><span class="n">Module</span> <span class="n">word</span>

<span class="k">class</span> <span class="nc">Word</span> <span class="p">{</span>

<span class="o">%</span><span class="n">TypeHeaderCode</span>
<span class="c1">#include &lt;word.h&gt;</span>
<span class="o">%</span><span class="n">End</span>

<span class="n">public</span><span class="p">:</span>
    <span class="n">Word</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">w</span><span class="p">);</span>

    <span class="n">char</span> <span class="o">*</span><span class="n">reverse</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Obviously a SIP specification file looks very much like a C++ (or C) header
file, but SIP does not include a full C++ parser.  Let’s look at the
differences between the two files.</p>
<blockquote>
<div><ul class="simple">
<li>The <a class="reference internal" href="directives.html#directive-%Module"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Module</span></code></a> directive has been added <a class="footnote-reference" href="#id4" id="id1">[1]</a>.  This is used to
name the Python module that is being created, <code class="docutils literal notranslate"><span class="pre">word</span></code> in this example.</li>
<li>The <a class="reference internal" href="directives.html#directive-%TypeHeaderCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%TypeHeaderCode</span></code></a> directive has been added.  The text
between this and the following <a class="reference internal" href="directives.html#directive-%End"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%End</span></code></a> directive is included
literally in the code that SIP generates.  Normally it is used, as in
this case, to <code class="docutils literal notranslate"><span class="pre">#include</span></code> the corresponding C++ (or C) header file <a class="footnote-reference" href="#id5" id="id2">[2]</a>.</li>
<li>The declaration of the private variable <code class="docutils literal notranslate"><span class="pre">this_word</span></code> has been removed.
SIP does not support access to either private or protected instance
variables.</li>
</ul>
</div></blockquote>
<p>If we want to we can now generate the C++ code in the current directory by
running the following command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sip</span> <span class="o">-</span><span class="n">c</span> <span class="o">.</span> <span class="n">word</span><span class="o">.</span><span class="n">sip</span>
</pre></div>
</div>
<p>However, that still leaves us with the task of compiling the generated code and
linking it against all the necessary libraries.  It’s much easier to use the
<a class="reference internal" href="build_system.html#ref-build-system"><span class="std std-ref">SIP build system</span></a> to do the whole thing.</p>
<p>Using the SIP build system is simply a matter of writing a small Python script.
In this simple example we will assume that the <code class="docutils literal notranslate"><span class="pre">word</span></code> library we are wrapping
and it’s header file are installed in standard system locations and will be
found by the compiler and linker without having to specify any additional
flags.  In a more realistic example your Python script may take command line
options, or search a set of directories to deal with different configurations
and installations.</p>
<p>This is the simplest script (conventionally called <code class="docutils literal notranslate"><span class="pre">configure.py</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sipconfig</span>

<span class="c1"># The name of the SIP build file generated by SIP and used by the build</span>
<span class="c1"># system.</span>
<span class="n">build_file</span> <span class="o">=</span> <span class="s2">&quot;word.sbf&quot;</span>

<span class="c1"># Get the SIP configuration information.</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">sipconfig</span><span class="o">.</span><span class="n">Configuration</span><span class="p">()</span>

<span class="c1"># Run SIP to generate the code.</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">config</span><span class="o">.</span><span class="n">sip_bin</span><span class="p">,</span> <span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;-b&quot;</span><span class="p">,</span> <span class="n">build_file</span><span class="p">,</span> <span class="s2">&quot;word.sip&quot;</span><span class="p">]))</span>

<span class="c1"># Create the Makefile.</span>
<span class="n">makefile</span> <span class="o">=</span> <span class="n">sipconfig</span><span class="o">.</span><span class="n">SIPModuleMakefile</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">build_file</span><span class="p">)</span>

<span class="c1"># Add the library we are wrapping.  The name doesn&#39;t include any platform</span>
<span class="c1"># specific prefixes or extensions (e.g. the &quot;lib&quot; prefix on UNIX, or the</span>
<span class="c1"># &quot;.dll&quot; extension on Windows).</span>
<span class="n">makefile</span><span class="o">.</span><span class="n">extra_libs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;word&quot;</span><span class="p">]</span>

<span class="c1"># Generate the Makefile itself.</span>
<span class="n">makefile</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
</pre></div>
</div>
<p>Hopefully this script is self-documenting.  The key parts are the
<code class="docutils literal notranslate"><span class="pre">Configuration</span></code> and <code class="docutils literal notranslate"><span class="pre">SIPModuleMakefile</span></code> classes.  The build system contains
other Makefile classes, for example to build programs or to call other
Makefiles in sub-directories.</p>
<p>After running the script (using the Python interpreter the extension module is
being created for) the generated C++ code and <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> will be in the
current directory.</p>
<p>To compile and install the extension module, just run the following
commands <a class="footnote-reference" href="#id6" id="id3">[3]</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span>
<span class="n">make</span> <span class="n">install</span>
</pre></div>
</div>
<p>That’s all there is to it.</p>
<p>See <a class="reference internal" href="distutils.html#ref-distutils"><span class="std std-ref">Building Your Extension with distutils</span></a> for an example of how to build this example using
distutils.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>All SIP directives start with a <code class="docutils literal notranslate"><span class="pre">%</span></code> as the first non-whitespace
character of a line.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>SIP includes many code directives like this.  They differ in where the
supplied code is placed by SIP in the generated code.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>On Windows you might run <code class="docutils literal notranslate"><span class="pre">nmake</span></code> or <code class="docutils literal notranslate"><span class="pre">mingw32-make</span></code> instead.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="id7">
<h2>A Simple C Example<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>Let’s now look at a very similar example of wrapping a fictional C library:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Define</span> <span class="n">the</span> <span class="n">interface</span> <span class="n">to</span> <span class="n">the</span> <span class="n">word</span> <span class="n">library</span><span class="o">.</span> <span class="o">*/</span>

<span class="n">struct</span> <span class="n">Word</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">the_word</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">struct</span> <span class="n">Word</span> <span class="o">*</span><span class="n">create_word</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">w</span><span class="p">);</span>
<span class="n">char</span> <span class="o">*</span><span class="n">reverse</span><span class="p">(</span><span class="n">struct</span> <span class="n">Word</span> <span class="o">*</span><span class="n">word</span><span class="p">);</span>
</pre></div>
</div>
<p>The corresponding SIP specification file would then look something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Define</span> <span class="n">the</span> <span class="n">SIP</span> <span class="n">wrapper</span> <span class="n">to</span> <span class="n">the</span> <span class="n">word</span> <span class="n">library</span><span class="o">.</span> <span class="o">*/</span>

<span class="o">%</span><span class="n">Module</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">language</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>

<span class="n">struct</span> <span class="n">Word</span> <span class="p">{</span>

<span class="o">%</span><span class="n">TypeHeaderCode</span>
<span class="c1">#include &lt;word.h&gt;</span>
<span class="o">%</span><span class="n">End</span>

    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">the_word</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">struct</span> <span class="n">Word</span> <span class="o">*</span><span class="n">create_word</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span><span class="n">Factory</span><span class="o">/</span><span class="p">;</span>
<span class="n">char</span> <span class="o">*</span><span class="n">reverse</span><span class="p">(</span><span class="n">struct</span> <span class="n">Word</span> <span class="o">*</span><span class="n">word</span><span class="p">);</span>
</pre></div>
</div>
<p>Again, let’s look at the differences between the two files.</p>
<blockquote>
<div><ul class="simple">
<li>The <a class="reference internal" href="directives.html#directive-%Module"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Module</span></code></a> directive specifies that the library being
wrapped is implemented in C rather than C++.  Because we are now
supplying an optional argument to the directive we must also specify the
module name as an argument.</li>
<li>The <a class="reference internal" href="directives.html#directive-%TypeHeaderCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%TypeHeaderCode</span></code></a> directive has been added.</li>
<li>The <a class="reference internal" href="annotations.html#function-annotation-Factory"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">Factory</span></code></a> annotation has been added to the <code class="docutils literal notranslate"><span class="pre">create_word()</span></code>
function.  This tells SIP that a newly created structure is being
returned and it is owned by Python.</li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">configure.py</span></code> build system script described in the previous example can
be used for this example without change.</p>
</div>
<div class="section" id="a-more-complex-c-example">
<h2>A More Complex C++ Example<a class="headerlink" href="#a-more-complex-c-example" title="Permalink to this headline">¶</a></h2>
<p>In this last example we will wrap a fictional C++ library that contains a class
that is derived from a Qt class.  This will demonstrate how SIP allows a class
hierarchy to be split across multiple Python extension modules, and will
introduce SIP’s versioning system.</p>
<p>The library contains a single C++ class called <code class="docutils literal notranslate"><span class="pre">Hello</span></code> which is derived from
Qt’s <code class="docutils literal notranslate"><span class="pre">QLabel</span></code> class.  It behaves just like <code class="docutils literal notranslate"><span class="pre">QLabel</span></code> except that the text
in the label is hard coded to be <code class="docutils literal notranslate"><span class="pre">Hello</span> <span class="pre">World</span></code>.  To make the example more
interesting we’ll also say that the library only supports Qt v4.2 and later,
and also includes a function called <code class="docutils literal notranslate"><span class="pre">setDefault()</span></code> that is not implemented
in the Windows version of the library.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">hello.h</span></code> header file looks something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Define</span> <span class="n">the</span> <span class="n">interface</span> <span class="n">to</span> <span class="n">the</span> <span class="n">hello</span> <span class="n">library</span><span class="o">.</span>

<span class="c1">#include &lt;qlabel.h&gt;</span>
<span class="c1">#include &lt;qwidget.h&gt;</span>
<span class="c1">#include &lt;qstring.h&gt;</span>

<span class="k">class</span> <span class="nc">Hello</span> <span class="p">:</span> <span class="n">public</span> <span class="n">QLabel</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">needed</span> <span class="n">by</span> <span class="n">the</span> <span class="n">Qt</span> <span class="n">Meta</span><span class="o">-</span><span class="n">Object</span> <span class="n">Compiler</span><span class="o">.</span>
    <span class="n">Q_OBJECT</span>

<span class="n">public</span><span class="p">:</span>
    <span class="n">Hello</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">private</span><span class="p">:</span>
    <span class="o">//</span> <span class="n">Prevent</span> <span class="n">instances</span> <span class="kn">from</span> <span class="nn">being</span> <span class="n">copied</span><span class="o">.</span>
    <span class="n">Hello</span><span class="p">(</span><span class="n">const</span> <span class="n">Hello</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="n">Hello</span> <span class="o">&amp;</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">const</span> <span class="n">Hello</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">#if !defined(Q_OS_WIN)</span>
<span class="n">void</span> <span class="n">setDefault</span><span class="p">(</span><span class="n">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">def</span><span class="p">);</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p>The corresponding SIP specification file would then look something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Define the SIP wrapper to the hello library.

%Module hello

%Import QtGui/QtGuimod.sip

%If (Qt_4_2_0 -)

class Hello : public QLabel {

%TypeHeaderCode
#include &lt;hello.h&gt;
%End

public:
    Hello(QWidget *parent /TransferThis/ = 0);

private:
    Hello(const Hello &amp;);
};

%If (!WS_WIN)
void setDefault(const QString &amp;def);
%End

%End
</pre></div>
</div>
<p>Again we look at the differences, but we’ll skip those that we’ve looked at in
previous examples.</p>
<blockquote>
<div><ul class="simple">
<li>The <a class="reference internal" href="directives.html#directive-%Import"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Import</span></code></a> directive has been added to specify that we are
extending the class hierarchy defined in the file <code class="docutils literal notranslate"><span class="pre">QtGui/QtGuimod.sip</span></code>.
This file is part of PyQt4.  The build system will take care of finding
the file’s exact location.</li>
<li>The <a class="reference internal" href="directives.html#directive-%If"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%If</span></code></a> directive has been added to specify that everything
<a class="footnote-reference" href="#id11" id="id8">[4]</a> up to the matching <a class="reference internal" href="directives.html#directive-%End"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%End</span></code></a> directive only applies to Qt
v4.2 and later.  <code class="docutils literal notranslate"><span class="pre">Qt_4_2_0</span></code> is a <em>tag</em> defined in <code class="docutils literal notranslate"><span class="pre">QtCoremod.sip</span></code>
<a class="footnote-reference" href="#id12" id="id9">[5]</a> using the <a class="reference internal" href="directives.html#directive-%Timeline"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Timeline</span></code></a> directive.  <a class="reference internal" href="directives.html#directive-%Timeline"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Timeline</span></code></a>
is used to define a tag for each version of a library’s API you are
wrapping allowing you to maintain all the different versions in a single
SIP specification.  The build system provides support to <code class="docutils literal notranslate"><span class="pre">configure.py</span></code>
scripts for working out the correct tags to use according to which
version of the library is actually installed.</li>
<li>The <a class="reference internal" href="annotations.html#argument-annotation-TransferThis"><code class="xref std std-aanno docutils literal notranslate"><span class="pre">TransferThis</span></code></a> annotation has been added to the constructor’s
argument.  It specifies that if the argument is not 0 (i.e. the <code class="docutils literal notranslate"><span class="pre">Hello</span></code>
instance being constructed has a parent) then ownership of the instance
is transferred from Python to C++.  It is needed because Qt maintains
objects (i.e. instances derived from the <code class="docutils literal notranslate"><span class="pre">QObject</span></code> class) in a
hierarchy.  When an object is destroyed all of its children are also
automatically destroyed.  It is important, therefore, that the Python
garbage collector doesn’t also try and destroy them.  This is covered in
more detail in <a class="reference internal" href="#ref-object-ownership"><span class="std std-ref">Ownership of Objects</span></a>.  SIP provides many other
annotations that can be applied to arguments, functions and classes.
Multiple annotations are separated by commas.  Annotations may have
values.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">=</span></code> operator has been removed.  This operator is not supported by
SIP.</li>
<li>The <a class="reference internal" href="directives.html#directive-%If"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%If</span></code></a> directive has been added to specify that everything
up to the matching <a class="reference internal" href="directives.html#directive-%End"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%End</span></code></a> directive does not apply to Windows.
<code class="docutils literal notranslate"><span class="pre">WS_WIN</span></code> is another tag defined by PyQt4, this time using the
<a class="reference internal" href="directives.html#directive-%Platforms"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Platforms</span></code></a> directive.  Tags defined by the
<a class="reference internal" href="directives.html#directive-%Platforms"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Platforms</span></code></a> directive are mutually exclusive, i.e. only one
may be valid at a time <a class="footnote-reference" href="#id13" id="id10">[6]</a>.</li>
</ul>
</div></blockquote>
<p>One question you might have at this point is why bother to define the private
copy constructor when it can never be called from Python?  The answer is to
prevent the automatic generation of a public copy constructor.</p>
<p>We now look at the <code class="docutils literal notranslate"><span class="pre">configure.py</span></code> script.  This is a little different to the
script in the previous examples for two related reasons.</p>
<p>Firstly, PyQt4 includes a pure Python module called <code class="docutils literal notranslate"><span class="pre">pyqtconfig</span></code> that extends
the SIP build system for modules, like our example, that build on top of PyQt4.
It deals with the details of which version of Qt is being used (i.e. it
determines what the correct tags are) and where it is installed.  This is
called a module’s configuration module.</p>
<p>Secondly, we generate a configuration module (called <code class="docutils literal notranslate"><span class="pre">helloconfig</span></code>) for our
own <code class="docutils literal notranslate"><span class="pre">hello</span></code> module.  There is no need to do this, but if there is a chance
that somebody else might want to extend your C++ library then it would make
life easier for them.</p>
<p>Now we have two scripts.  First the <code class="docutils literal notranslate"><span class="pre">configure.py</span></code> script:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sipconfig</span>
<span class="kn">from</span> <span class="nn">PyQt4</span> <span class="k">import</span> <span class="n">pyqtconfig</span>

<span class="c1"># The name of the SIP build file generated by SIP and used by the build</span>
<span class="c1"># system.</span>
<span class="n">build_file</span> <span class="o">=</span> <span class="s2">&quot;hello.sbf&quot;</span>

<span class="c1"># Get the PyQt4 configuration information.</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">pyqtconfig</span><span class="o">.</span><span class="n">Configuration</span><span class="p">()</span>

<span class="c1"># Get the extra SIP flags needed by the imported PyQt4 modules.  Note that</span>
<span class="c1"># this normally only includes those flags (-x and -t) that relate to SIP&#39;s</span>
<span class="c1"># versioning system.</span>
<span class="n">pyqt_sip_flags</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">pyqt_sip_flags</span>

<span class="c1"># Run SIP to generate the code.  Note that we tell SIP where to find the qt</span>
<span class="c1"># module&#39;s specification files using the -I flag.</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">config</span><span class="o">.</span><span class="n">sip_bin</span><span class="p">,</span> <span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;-b&quot;</span><span class="p">,</span> <span class="n">build_file</span><span class="p">,</span> <span class="s2">&quot;-I&quot;</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">pyqt_sip_dir</span><span class="p">,</span> <span class="n">pyqt_sip_flags</span><span class="p">,</span> <span class="s2">&quot;hello.sip&quot;</span><span class="p">]))</span>

<span class="c1"># We are going to install the SIP specification file for this module and</span>
<span class="c1"># its configuration module.</span>
<span class="n">installs</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">installs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;hello.sip&quot;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">default_sip_dir</span><span class="p">,</span> <span class="s2">&quot;hello&quot;</span><span class="p">)])</span>

<span class="n">installs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;helloconfig.py&quot;</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">default_mod_dir</span><span class="p">])</span>

<span class="c1"># Create the Makefile.  The QtGuiModuleMakefile class provided by the</span>
<span class="c1"># pyqtconfig module takes care of all the extra preprocessor, compiler and</span>
<span class="c1"># linker flags needed by the Qt library.</span>
<span class="n">makefile</span> <span class="o">=</span> <span class="n">pyqtconfig</span><span class="o">.</span><span class="n">QtGuiModuleMakefile</span><span class="p">(</span>
    <span class="n">configuration</span><span class="o">=</span><span class="n">config</span><span class="p">,</span>
    <span class="n">build_file</span><span class="o">=</span><span class="n">build_file</span><span class="p">,</span>
    <span class="n">installs</span><span class="o">=</span><span class="n">installs</span>
<span class="p">)</span>

<span class="c1"># Add the library we are wrapping.  The name doesn&#39;t include any platform</span>
<span class="c1"># specific prefixes or extensions (e.g. the &quot;lib&quot; prefix on UNIX, or the</span>
<span class="c1"># &quot;.dll&quot; extension on Windows).</span>
<span class="n">makefile</span><span class="o">.</span><span class="n">extra_libs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;hello&quot;</span><span class="p">]</span>

<span class="c1"># Generate the Makefile itself.</span>
<span class="n">makefile</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>

<span class="c1"># Now we create the configuration module.  This is done by merging a Python</span>
<span class="c1"># dictionary (whose values are normally determined dynamically) with a</span>
<span class="c1"># (static) template.</span>
<span class="n">content</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># Publish where the SIP specifications for this module will be</span>
    <span class="c1"># installed.</span>
    <span class="s2">&quot;hello_sip_dir&quot;</span><span class="p">:</span>    <span class="n">config</span><span class="o">.</span><span class="n">default_sip_dir</span><span class="p">,</span>

    <span class="c1"># Publish the set of SIP flags needed by this module.  As these are the</span>
    <span class="c1"># same flags needed by the qt module we could leave it out, but this</span>
    <span class="c1"># allows us to change the flags at a later date without breaking</span>
    <span class="c1"># scripts that import the configuration module.</span>
    <span class="s2">&quot;hello_sip_flags&quot;</span><span class="p">:</span>  <span class="n">pyqt_sip_flags</span>
<span class="p">}</span>

<span class="c1"># This creates the helloconfig.py module from the helloconfig.py.in</span>
<span class="c1"># template and the dictionary.</span>
<span class="n">sipconfig</span><span class="o">.</span><span class="n">create_config_module</span><span class="p">(</span><span class="s2">&quot;helloconfig.py&quot;</span><span class="p">,</span> <span class="s2">&quot;helloconfig.py.in&quot;</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>
</pre></div>
</div>
<p>Next we have the <code class="docutils literal notranslate"><span class="pre">helloconfig.py.in</span></code> template script:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">PyQt4</span> <span class="k">import</span> <span class="n">pyqtconfig</span>

<span class="c1"># These are installation specific values created when Hello was configured.</span>
<span class="c1"># The following line will be replaced when this template is used to create</span>
<span class="c1"># the final configuration module.</span>
<span class="c1"># @SIP_CONFIGURATION@</span>

<span class="k">class</span> <span class="nc">Configuration</span><span class="p">(</span><span class="n">pyqtconfig</span><span class="o">.</span><span class="n">Configuration</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The class that represents Hello configuration values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_cfg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise an instance of the class.</span>

<span class="sd">        sub_cfg is the list of sub-class configurations.  It should be None</span>
<span class="sd">        when called normally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is all standard code to be copied verbatim except for the</span>
        <span class="c1"># name of the module containing the super-class.</span>
        <span class="k">if</span> <span class="n">sub_cfg</span><span class="p">:</span>
            <span class="n">cfg</span> <span class="o">=</span> <span class="n">sub_cfg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cfg</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">cfg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_pkg_config</span><span class="p">)</span>

        <span class="n">pyqtconfig</span><span class="o">.</span><span class="n">Configuration</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">HelloModuleMakefile</span><span class="p">(</span><span class="n">pyqtconfig</span><span class="o">.</span><span class="n">QtGuiModuleMakefile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The Makefile class for modules that %Import hello.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">finalise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finalise the macros.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure our C++ library is linked.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_libs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>

        <span class="c1"># Let the super-class do what it needs to.</span>
        <span class="n">pyqtconfig</span><span class="o">.</span><span class="n">QtGuiModuleMakefile</span><span class="o">.</span><span class="n">finalise</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>Again, we hope that the scripts are self documenting.</p>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[4]</a></td><td>Some parts of a SIP specification aren’t subject to version control.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[5]</a></td><td>Actually in <code class="docutils literal notranslate"><span class="pre">versions.sip</span></code>.  PyQt4 uses the <a class="reference internal" href="directives.html#directive-%Include"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Include</span></code></a>
directive to split the SIP specification for Qt across a large number of
separate <code class="docutils literal notranslate"><span class="pre">.sip</span></code> files.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[6]</a></td><td>Tags can also be defined by the <a class="reference internal" href="directives.html#directive-%Feature"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Feature</span></code></a> directive.  These
tags are not mutually exclusive, i.e. any number may be valid at a time.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="wrapping-enums">
<h2>Wrapping Enums<a class="headerlink" href="#wrapping-enums" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.19.4.</span></p>
</div>
<p>SIP wraps C/C++ enums using a dedicated Python type and implements behaviour
that mimics the C/C++ behaviour regqrding the visibility of the enum’s members.
In other words, an enum’s members have the same visibility as the enum itself.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">enum</span> <span class="n">MyEnum</span>
    <span class="p">{</span>
        <span class="n">Member</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In Python the <code class="docutils literal notranslate"><span class="pre">Member</span></code> member is referenced as <code class="docutils literal notranslate"><span class="pre">MyClass.Member</span></code>.  This
behaviour makes it easier to translate C/C++ code to Python.</p>
<p>In more recent times C++11 has introduced scoped enums and Python has
introduced the <code class="xref py py-mod docutils literal notranslate"><span class="pre">enum</span></code> module.  In both cases a member is only visible in
the scope of the enum.  In other words, the <code class="docutils literal notranslate"><span class="pre">Member</span></code> member is referenced as
<code class="docutils literal notranslate"><span class="pre">MyClass.MyEnum.Member</span></code>.</p>
<p>This version of SIP adds support for wrapping C++11 scoped enums and implements
them as Python <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code> objects.  For versions of Python that don’t
include the <code class="xref py py-mod docutils literal notranslate"><span class="pre">enum</span></code> module in the standrd library (i.e. versions earlier
than v3.4) then the <code class="docutils literal notranslate"><span class="pre">enum34</span></code> package must be installed from PyPI.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.19.9.</span></p>
</div>
<p>A disadvantage of the above is that the Python programmer needs to know the
nature of the C/C++ enum in order to access its members.  In order to avoid
this, this version of SIP makes the members of traditional C/C++ enums visible
from the scope of the enum as well.</p>
<p>It is recommended that Python code should always specify the enum scope when
referencing an enum member.</p>
</div>
<div class="section" id="ownership-of-objects">
<span id="ref-object-ownership"></span><h2>Ownership of Objects<a class="headerlink" href="#ownership-of-objects" title="Permalink to this headline">¶</a></h2>
<p>When a C++ instance is wrapped a corresponding Python object is created.  The
Python object behaves as you would expect in regard to garbage collection - it
is garbage collected when its reference count reaches zero.  What then happens
to the corresponding C++ instance?  The obvious answer might be that the
instance’s destructor is called.  However the library API may say that when the
instance is passed to a particular function, the library takes ownership of the
instance, i.e. responsibility for calling the instance’s destructor is
transferred from the SIP generated module to the library.</p>
<p>Ownership of an instance may also be associated with another instance.  The
implication being that the owned instance will automatically be destroyed if
the owning instance is destroyed.  SIP keeps track of these relationships to
ensure that Python’s cyclic garbage collector can detect and break any
reference cycles between the owning and owned instances.  The association is
implemented as the owning instance taking a reference to the owned instance.</p>
<p>The TransferThis, Transfer and TransferBack annotations are used to specify
where, and it what direction, transfers of ownership happen.  It is very
important that these are specified correctly to avoid crashes (where both
Python and C++ call the destructor) and memory leaks (where neither Python and
C++ call the destructor).</p>
<p>This applies equally to C structures where the structure is returned to the
heap using the <code class="docutils literal notranslate"><span class="pre">free()</span></code> function.</p>
<p>See also <a class="reference internal" href="c_api.html#c.sipTransferTo" title="sipTransferTo"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferTo()</span></code></a>, <a class="reference internal" href="c_api.html#c.sipTransferBack" title="sipTransferBack"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferBack()</span></code></a> and
<a class="reference internal" href="c_api.html#c.sipTransferBreak" title="sipTransferBreak"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferBreak()</span></code></a>.</p>
</div>
<div class="section" id="types-and-meta-types">
<span id="ref-types-metatypes"></span><h2>Types and Meta-types<a class="headerlink" href="#types-and-meta-types" title="Permalink to this headline">¶</a></h2>
<p>Every Python object (with the exception of the <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code> object itself)
has a meta-type and at least one super-type.  By default an object’s meta-type
is the meta-type of its first super-type.</p>
<p>SIP implements two super-types, <a class="reference internal" href="python_api.html#sip.simplewrapper" title="sip.simplewrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.simplewrapper</span></code></a> and
<a class="reference internal" href="python_api.html#sip.wrapper" title="sip.wrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.wrapper</span></code></a>, and a meta-type, <a class="reference internal" href="python_api.html#sip.wrappertype" title="sip.wrappertype"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.wrappertype</span></code></a>.</p>
<p><a class="reference internal" href="python_api.html#sip.simplewrapper" title="sip.simplewrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.simplewrapper</span></code></a> is the super-type of <a class="reference internal" href="python_api.html#sip.wrapper" title="sip.wrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.wrapper</span></code></a>.  The
super-type of <a class="reference internal" href="python_api.html#sip.simplewrapper" title="sip.simplewrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.simplewrapper</span></code></a> is <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code>.</p>
<p><a class="reference internal" href="python_api.html#sip.wrappertype" title="sip.wrappertype"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.wrappertype</span></code></a> is the meta-type of both <a class="reference internal" href="python_api.html#sip.simplewrapper" title="sip.simplewrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.simplewrapper</span></code></a>
and <a class="reference internal" href="python_api.html#sip.wrapper" title="sip.wrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.wrapper</span></code></a>.  The super-type of <a class="reference internal" href="python_api.html#sip.wrappertype" title="sip.wrappertype"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.wrappertype</span></code></a> is
<code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code>.</p>
<p><a class="reference internal" href="python_api.html#sip.wrapper" title="sip.wrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.wrapper</span></code></a> supports the concept of object ownership described in
<a class="reference internal" href="#ref-object-ownership"><span class="std std-ref">Ownership of Objects</span></a> and, by default, is the super-type of all the types
that SIP generates.</p>
<p><a class="reference internal" href="python_api.html#sip.simplewrapper" title="sip.simplewrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.simplewrapper</span></code></a> does not support the concept of object ownership but
SIP generated types that are sub-classed from it have Python objects that take
less memory.</p>
<p>SIP allows a class’s meta-type and super-type to be explicitly specified using
the <a class="reference internal" href="annotations.html#class-annotation-Metatype"><code class="xref std std-canno docutils literal notranslate"><span class="pre">Metatype</span></code></a> and <a class="reference internal" href="annotations.html#class-annotation-Supertype"><code class="xref std std-canno docutils literal notranslate"><span class="pre">Supertype</span></code></a> class annotations.</p>
<p>SIP also allows the default meta-type and super-type to be changed for a module
using the <a class="reference internal" href="directives.html#directive-%DefaultMetatype"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%DefaultMetatype</span></code></a> and <a class="reference internal" href="directives.html#directive-%DefaultSupertype"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%DefaultSupertype</span></code></a>
directives.  Unlike the default super-type, the default meta-type is inherited
by importing modules.</p>
<p>If you want to use your own meta-type or super-type then they must be
sub-classed from one of the SIP provided types.  Your types must be registered
using <a class="reference internal" href="c_api.html#c.sipRegisterPyType" title="sipRegisterPyType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipRegisterPyType()</span></code></a>.  This is normally done in code specified
using the <a class="reference internal" href="directives.html#directive-%InitialisationCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%InitialisationCode</span></code></a> directive.</p>
<p>As an example, PyQt4 uses <a class="reference internal" href="directives.html#directive-%DefaultMetatype"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%DefaultMetatype</span></code></a> to specify a new
meta-type that handles the interaction with Qt’s own meta-type system.  It also
uses <a class="reference internal" href="directives.html#directive-%DefaultSupertype"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%DefaultSupertype</span></code></a> to specify that the smaller
<a class="reference internal" href="python_api.html#sip.simplewrapper" title="sip.simplewrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.simplewrapper</span></code></a> super-type is normally used.  Finally it uses
<a class="reference internal" href="annotations.html#class-annotation-Supertype"><code class="xref std std-canno docutils literal notranslate"><span class="pre">Supertype</span></code></a> as an annotation of the <code class="docutils literal notranslate"><span class="pre">QObject</span></code> class to override the
default and use <a class="reference internal" href="python_api.html#sip.wrapper" title="sip.wrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.wrapper</span></code></a> as the super-type so that the parent/child
relationships of <code class="docutils literal notranslate"><span class="pre">QObject</span></code> instances are properly maintained.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is not possible to define new super-types or meta-types if the limited
Python API is enabled.</p>
</div>
</div>
<div class="section" id="lazy-type-attributes">
<span id="ref-lazy-type-attributes"></span><h2>Lazy Type Attributes<a class="headerlink" href="#lazy-type-attributes" title="Permalink to this headline">¶</a></h2>
<p>Instead of populating a wrapped type’s dictionary with its attributes (or
descriptors for those attributes) SIP only creates objects for those attributes
when they are actually needed.  This is done to reduce the memory footprint and
start up time when used to wrap large libraries with hundreds of classes and
tens of thousands of attributes.</p>
<p>SIP allows you to extend the handling of lazy attributes to your own attribute
types by allowing you to register an attribute getter handler (using
<a class="reference internal" href="c_api.html#c.sipRegisterAttributeGetter" title="sipRegisterAttributeGetter"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipRegisterAttributeGetter()</span></code></a>).  This will be called just before a
type’s dictionary is accessed for the first time.</p>
</div>
<div class="section" id="overflow-checking">
<h2>Overflow Checking<a class="headerlink" href="#overflow-checking" title="Permalink to this headline">¶</a></h2>
<p>By default SIP does not check for overflow when converting Python number
objects to C/C++ types.  Overflowed values are undefined - it cannot be assumed
that upper bits are simply discarded.</p>
<p>SIP v4.19.4 allowed overflow checking to be enabled and disabled by the wrapper
author (using :c:func`sipEnableOverflowChecking()`) or by the application
developer (using :py:func`sip.enableoverflowchecking()`).</p>
<p>It is recommended that wrapper authors should always enable overflow checking
by default.</p>
</div>
<div class="section" id="support-for-python-s-buffer-interface">
<h2>Support for Python’s Buffer Interface<a class="headerlink" href="#support-for-python-s-buffer-interface" title="Permalink to this headline">¶</a></h2>
<p>SIP supports Python’s buffer interface in that whenever C/C++ requires a
<code class="docutils literal notranslate"><span class="pre">char</span></code> or <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> type then any Python type that supports the buffer
interface (including ordinary Python strings) can be used.</p>
<p>If a buffer is made up of a number of segments then all but the first will be
ignored.</p>
</div>
<div class="section" id="support-for-wide-characters">
<h2>Support for Wide Characters<a class="headerlink" href="#support-for-wide-characters" title="Permalink to this headline">¶</a></h2>
<p>SIP v4.6 introduced support for wide characters (i.e. the <code class="docutils literal notranslate"><span class="pre">wchar_t</span></code> type).
Python’s C API includes support for converting between unicode objects and wide
character strings and arrays.  When converting from a unicode object to wide
characters SIP creates the string or array on the heap (using memory allocated
using <a class="reference internal" href="c_api.html#c.sipMalloc" title="sipMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipMalloc()</span></code></a>).  This then raises the problem of how this memory
is subsequently freed.</p>
<p>The following describes how SIP handles this memory in the different situations
where this is an issue.</p>
<blockquote>
<div><ul class="simple">
<li>When a wide string or array is passed to a function or method then the
memory is freed (using <a class="reference internal" href="c_api.html#c.sipFree" title="sipFree"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipFree()</span></code></a>) after that function or method
returns.</li>
<li>When a wide string or array is returned from a virtual method then SIP
does not free the memory until the next time the method is called.</li>
<li>When an assignment is made to a wide string or array instance variable
then SIP does not first free the instance’s current string or array.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="the-python-global-interpreter-lock">
<span id="ref-gil"></span><h2>The Python Global Interpreter Lock<a class="headerlink" href="#the-python-global-interpreter-lock" title="Permalink to this headline">¶</a></h2>
<p>Python’s Global Interpretor Lock (GIL) must be acquired before calls can be
made to the Python API.  It should also be released when a potentially
blocking call to C/C++ library is made in order to allow other Python threads
to be executed.  In addition, some C/C++ libraries may implement their own
locking strategies that conflict with the GIL causing application deadlocks.
SIP provides ways of specifying when the GIL is released and acquired to
ensure that locking problems can be avoided.</p>
<p>SIP always ensures that the GIL is acquired before making calls to the Python
API.  By default SIP does not release the GIL when making calls to the C/C++
library being wrapped.  The <a class="reference internal" href="annotations.html#function-annotation-ReleaseGIL"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">ReleaseGIL</span></code></a> annotation can be used to
override this behaviour when required.</p>
<p>If SIP is given the <a class="reference internal" href="command_line.html#cmdoption-sip-g"><code class="xref std std-option docutils literal notranslate"><span class="pre">-g</span></code></a> command line option then the default
behaviour is changed and SIP releases the GIL every time is makes calls to the
C/C++ library being wrapped.  The <a class="reference internal" href="annotations.html#function-annotation-HoldGIL"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">HoldGIL</span></code></a> annotation can be used to
override this behaviour when required.</p>
</div>
<div class="section" id="managing-incompatible-apis">
<span id="ref-incompat-apis"></span><h2>Managing Incompatible APIs<a class="headerlink" href="#managing-incompatible-apis" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.9.</span></p>
</div>
<p>Sometimes it is necessary to change the way something is wrapped in a way that
introduces an incompatibility.  For example a new feature of Python may
suggest that something may be wrapped in a different way to exploit that
feature.</p>
<p>SIP’s <a class="reference internal" href="directives.html#directive-%Feature"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Feature</span></code></a> directive could be used to provide two different
implementations.  However this would mean that the choice between the two
implementations would have to be made when building the generated module
potentially causing all sorts of deployment problems.  It may also require
applications to work out which implementation was available and to change
their behaviour accordingly.</p>
<p>Instead SIP provides limited support for providing multiple implementations
(of classes, mapped types and functions) that can be selected by an
application at run-time.  It is then up to the application developer how they
want to manage the migration from the old API to the new, incompatible API.</p>
<p>This support is implemented in three parts.</p>
<p>Firstly the <a class="reference internal" href="directives.html#directive-%API"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%API</span></code></a> directive is used to define the name of an API
and its default version number.  The default version number is the one used if
an application doesn’t explicitly set the version number to use.</p>
<p>Secondly the <a class="reference internal" href="annotations.html#class-annotation-API"><code class="xref std std-canno docutils literal notranslate"><span class="pre">API</span> <span class="pre">class</span></code></a>, <a class="reference internal" href="annotations.html#mapped-type-annotation-API"><code class="xref std std-manno docutils literal notranslate"><span class="pre">mapped</span> <span class="pre">type</span></code></a> or
<a class="reference internal" href="annotations.html#function-annotation-API"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">function</span></code></a> annotation is applied accordingly to specify the API
and range of version numbers that a particular class, mapped type or function
implementation should be enabled for.</p>
<p>Finally the application calls <a class="reference internal" href="python_api.html#sip.setapi" title="sip.setapi"><code class="xref py py-func docutils literal notranslate"><span class="pre">sip.setapi()</span></code></a> to specify the version number
of the API that should be enabled.  This call must be made before any module
that has multiple implementations is imported for the first time.</p>
<p>Note this mechanism is not intended as a way or providing equally valid
alternative APIs.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">API</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">MyAPI</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Foo</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">bar</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Baz</span> <span class="p">:</span> <span class="n">Foo</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">bar</span><span class="p">()</span> <span class="o">/</span><span class="n">API</span><span class="o">=</span><span class="n">MyAPI</span><span class="p">:</span><span class="mi">2</span><span class="o">-/</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If the following Python code is executed then an exception will be raised:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">Baz</span><span class="p">()</span>
<span class="n">b</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
</pre></div>
</div>
<p>This is because when version 1 of the <em>MyAPI</em> API (the default) is enabled
there is no <em>Baz.bar()</em> implementation and <em>Foo.bar()</em> will not be called
instead as might be expected.</p>
</div>
<div class="section" id="writing-converttosubclasscode">
<span id="ref-subclass-convertors"></span><h2>Writing <a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a><a class="headerlink" href="#writing-converttosubclasscode" title="Permalink to this headline">¶</a></h2>
<p>When SIP needs to wrap a C++ class instance it first checks to make sure it
hasn’t already done so.  If it has then it just returns a new reference to the
corresponding Python object.  Otherwise it creates a new Python object of the
appropriate type.  In C++ a function may be defined to return an instance of a
certain class, but can often return a sub-class instead.</p>
<p>The <a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> directive is used to specify
handwritten code that exploits any available real-time type information (RTTI)
to see if there is a more specific Python type that can be used when wrapping
the C++ instance.  The RTTI may be provided by the compiler or by the C++
instance itself.</p>
<p>The directive is included in the specification of one of the classes that the
handwritten code handles the type conversion for.  It doesn’t matter which
one, but a sensible choice would be the one at the root of that class
hierarchy in the module.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In a future version of SIP this use of the directive will be deprecated and
it will instead be placed outside any class specification.</p>
</div>
<p>If a class hierarchy extends over a number of modules then this directive
should be used in each of those modules to handle the part of the hierarchy
defined in that module.  SIP will ensure that the different pieces of code are
called in the right order to determine the most specific Python type to use.</p>
<p>A class has at least one convertor if it or any super-class defines
<a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a>.  A convertor has a base class.  If a class
that defines <a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> does not have a super-class
that defines <a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> then that class is the base
class.  Otherwise the base class is that of the right-most super-class that has
a convertor.  In this case the <a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> extends all
other convertors with the same base class.</p>
<p>Consider the following class hierarchy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>
  \
   <span class="n">B</span><span class="o">*</span>     <span class="n">C</span><span class="o">*</span>
     \  <span class="o">/</span>   \
      <span class="n">D</span>      <span class="n">E</span>
    <span class="o">/</span>   \
  <span class="n">F</span>       <span class="n">G</span><span class="o">*</span>
</pre></div>
</div>
<p>The classes marked with an asterisk define <a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a>.</p>
<p>Classes <code class="docutils literal notranslate"><span class="pre">A</span></code> to <code class="docutils literal notranslate"><span class="pre">F</span></code> are implemented in module <code class="docutils literal notranslate"><span class="pre">X</span></code>.  Class <code class="docutils literal notranslate"><span class="pre">G</span></code> is
implemented in module <code class="docutils literal notranslate"><span class="pre">Y</span></code>.</p>
<p>We can say the following:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">A</span></code> has no convertor, all other classes do.</li>
<li>The base class of <code class="docutils literal notranslate"><span class="pre">B</span></code>’s <a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> is <code class="docutils literal notranslate"><span class="pre">B</span></code>.</li>
<li>The base class of <code class="docutils literal notranslate"><span class="pre">C</span></code>’s <a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> is <code class="docutils literal notranslate"><span class="pre">C</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">D</span></code> and <code class="docutils literal notranslate"><span class="pre">F</span></code> have two convertors <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">E</span></code>’s convertor is <code class="docutils literal notranslate"><span class="pre">C</span></code>.</li>
<li>The base class of <code class="docutils literal notranslate"><span class="pre">G</span></code>’s <a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> is <code class="docutils literal notranslate"><span class="pre">C</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">B</span></code>’s <a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> must handle instances of <code class="docutils literal notranslate"><span class="pre">B</span></code>,
<code class="docutils literal notranslate"><span class="pre">D</span></code> and <code class="docutils literal notranslate"><span class="pre">F</span></code> (i.e. those sub-classes of its base class defined in the same
module).</li>
<li><code class="docutils literal notranslate"><span class="pre">C</span></code>’s <a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> must handle instances of <code class="docutils literal notranslate"><span class="pre">C</span></code>,
<code class="docutils literal notranslate"><span class="pre">D</span></code>, <code class="docutils literal notranslate"><span class="pre">E</span></code> and <code class="docutils literal notranslate"><span class="pre">F</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">G</span></code>’s <a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> must handle instances of <code class="docutils literal notranslate"><span class="pre">G</span></code>.</li>
</ul>
<p>A convertor is invoked when SIP needs to wrap a C++ instance and the type of
that instance is a sub-class of the convertor’s base class.  The convertor is
passed a pointer to the instance cast to the base class.  The convertor then,
if possible, casts that pointer to an instance of a sub-class of its original
class.  It also returns a pointer to the corresponding
<a class="reference internal" href="c_api.html#ref-type-objects"><span class="std std-ref">generated type object</span></a>.</p>
<p>It is possible for a convertor to switch to another convertor.  This can avoid
duplication of convertor code where there is multiple inheritance.</p>
<p>When more than one convertor may be invoked they are done so in the order that
reflects the module hierarchy.  When the convertors are defined in the same
module then the order is undefined.  Convertors must be written with this mind.</p>
<p>Given the class hierarchy shown above, lets say that SIP needs to wrap an
instance of known to be of class <code class="docutils literal notranslate"><span class="pre">D</span></code> but is actually of class <code class="docutils literal notranslate"><span class="pre">F</span></code>.  We want
the conversion mechanism to recognise that fact and return a Python object of
type <code class="docutils literal notranslate"><span class="pre">F</span></code>.  The following steps are taken:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">G</span></code>’s <a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> is invoked and passed the pointer
to <code class="docutils literal notranslate"><span class="pre">D</span></code> cast to <code class="docutils literal notranslate"><span class="pre">C</span></code>.  This convertor only recognises instances of class
<code class="docutils literal notranslate"><span class="pre">G</span></code> and so returns a value that indicates it was unable to perform a
conversion.</li>
<li>SIP will now invoke either <code class="docutils literal notranslate"><span class="pre">B</span></code>’s <a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> or
<code class="docutils literal notranslate"><span class="pre">C</span></code>’s <a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a>.  As they are defined in the same
module which is chosen is undefined.  Let’s assume it is the <code class="docutils literal notranslate"><span class="pre">C</span></code> convertor
that is invoked.</li>
<li>The convertor recognises that the instance is of class <code class="docutils literal notranslate"><span class="pre">D</span></code> (rather than
<code class="docutils literal notranslate"><span class="pre">C</span></code> or <code class="docutils literal notranslate"><span class="pre">E</span></code>).  It must also determine whether this really is <code class="docutils literal notranslate"><span class="pre">D</span></code> or
whether it is actually <code class="docutils literal notranslate"><span class="pre">F</span></code>.  Of course <code class="docutils literal notranslate"><span class="pre">B</span></code>’s
<a class="reference internal" href="directives.html#directive-%ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> must also make the same distinction.
Rather than possibly duplicating the required code in both convertors the
<code class="docutils literal notranslate"><span class="pre">C</span></code> convertor switches to the <code class="docutils literal notranslate"><span class="pre">B</span></code> convertor.  It does this by casting the
pointer it is trying to convert to <code class="docutils literal notranslate"><span class="pre">B</span></code> and returns <code class="docutils literal notranslate"><span class="pre">B</span></code>’s
<a class="reference internal" href="c_api.html#ref-type-objects"><span class="std std-ref">generated type object</span></a>.</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Using SIP</a><ul>
<li><a class="reference internal" href="#a-simple-c-example">A Simple C++ Example</a></li>
<li><a class="reference internal" href="#id7">A Simple C Example</a></li>
<li><a class="reference internal" href="#a-more-complex-c-example">A More Complex C++ Example</a></li>
<li><a class="reference internal" href="#wrapping-enums">Wrapping Enums</a></li>
<li><a class="reference internal" href="#ownership-of-objects">Ownership of Objects</a></li>
<li><a class="reference internal" href="#types-and-meta-types">Types and Meta-types</a></li>
<li><a class="reference internal" href="#lazy-type-attributes">Lazy Type Attributes</a></li>
<li><a class="reference internal" href="#overflow-checking">Overflow Checking</a></li>
<li><a class="reference internal" href="#support-for-python-s-buffer-interface">Support for Python’s Buffer Interface</a></li>
<li><a class="reference internal" href="#support-for-wide-characters">Support for Wide Characters</a></li>
<li><a class="reference internal" href="#the-python-global-interpreter-lock">The Python Global Interpreter Lock</a></li>
<li><a class="reference internal" href="#managing-incompatible-apis">Managing Incompatible APIs</a></li>
<li><a class="reference internal" href="#writing-converttosubclasscode">Writing <code class="docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="installation.html"
                        title="previous chapter">Installation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="command_line.html"
                        title="next chapter">The SIP Command Line</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="command_line.html" title="The SIP Command Line"
             >next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SIP v4.19.17 Reference Guide</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019 Riverbank Computing Limited.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.9.
    </div>
  </body>
</html>