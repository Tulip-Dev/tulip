
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>C API for Handwritten Code &#8212; SIP v4.19.24 Reference Guide</title>
    <link rel="stylesheet" href="_static/riverbank.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    
    <link rel="shortcut icon" href="_static/logo_tn.png"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Using the C API when Embedding" href="embedding.html" />
    <link rel="prev" title="Annotations" href="annotations.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="embedding.html" title="Using the C API when Embedding"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="annotations.html" title="Annotations"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SIP v4.19.24 Reference Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">C API for Handwritten Code</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="c-api-for-handwritten-code">
<span id="ref-c-api"></span><h1>C API for Handwritten Code<a class="headerlink" href="#c-api-for-handwritten-code" title="Permalink to this headline">¶</a></h1>
<p>In this section we describe the API that can be used by handwritten code in
specification files.</p>
<dl class="c macro">
<dt id="c.SIP_API_MAJOR_NR">
<code class="sig-name descname">SIP_API_MAJOR_NR</code><a class="headerlink" href="#c.SIP_API_MAJOR_NR" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a C preprocessor symbol that defines the major number of the SIP
API.  Its value is a number.  There is no direct relationship between this
and the SIP version number.</p>
</dd></dl>

<dl class="c macro">
<dt id="c.SIP_API_MINOR_NR">
<code class="sig-name descname">SIP_API_MINOR_NR</code><a class="headerlink" href="#c.SIP_API_MINOR_NR" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a C preprocessor symbol that defines the minor number of the SIP
API.  Its value is a number.  There is no direct relationship between this
and the SIP version number.</p>
</dd></dl>

<dl class="c macro">
<dt id="c.SIP_BLOCK_THREADS">
<code class="sig-name descname">SIP_BLOCK_THREADS</code><a class="headerlink" href="#c.SIP_BLOCK_THREADS" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a C preprocessor macro that will make sure the Python Global
Interpreter Lock (GIL) is acquired.  Python API calls must only be made
when the GIL has been acquired.  There must be a corresponding
<a class="reference internal" href="#c.SIP_UNBLOCK_THREADS" title="SIP_UNBLOCK_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_UNBLOCK_THREADS</span></code></a> at the same lexical scope.</p>
</dd></dl>

<dl class="c macro">
<dt id="c.SIP_NO_CONVERTORS">
<code class="sig-name descname">SIP_NO_CONVERTORS</code><a class="headerlink" href="#c.SIP_NO_CONVERTORS" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a flag used by various type convertors that suppresses the use of a
type’s <a class="reference internal" href="directives.html#std-directive-ConvertToTypeCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToTypeCode</span></code></a>.</p>
</dd></dl>

<dl class="c macro">
<dt id="c.SIP_NOT_NONE">
<code class="sig-name descname">SIP_NOT_NONE</code><a class="headerlink" href="#c.SIP_NOT_NONE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a flag used by various type convertors that causes the conversion
to fail if the Python object being converted is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>.</p>
</dd></dl>

<dl class="c macro">
<dt id="c.SIP_NULLPTR">
<code class="sig-name descname">SIP_NULLPTR</code><a class="headerlink" href="#c.SIP_NULLPTR" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.14.</span></p>
</div>
<p>This is a C preprocessor macro that should be used instead of <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or
<code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.  It ensures the correct value is used depending on whether C
or C++ is being generated and which language standard the compiler
supports.</p>
</dd></dl>

<dl class="c macro">
<dt id="c.SIP_OWNS_MEMORY">
<code class="sig-name descname">SIP_OWNS_MEMORY</code><a class="headerlink" href="#c.SIP_OWNS_MEMORY" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.15.2.</span></p>
</div>
<p>This is a flag used by various array constructors that species that the
array owns the memory that holds the array’s contents.</p>
</dd></dl>

<dl class="c macro">
<dt id="c.SIP_PROTECTED_IS_PUBLIC">
<code class="sig-name descname">SIP_PROTECTED_IS_PUBLIC</code><a class="headerlink" href="#c.SIP_PROTECTED_IS_PUBLIC" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.10.</span></p>
</div>
<p>This is a C preprocessor symbol that is defined automatically by the build
system to specify that the generated code is being compiled with
<code class="docutils literal notranslate"><span class="pre">protected</span></code> redefined as <code class="docutils literal notranslate"><span class="pre">public</span></code>.  This allows handwritten code to
determine if the generated helper functions for accessing protected C++
functions are available (see <a class="reference internal" href="directives.html#std-directive-MethodCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%MethodCode</span></code></a>).</p>
</dd></dl>

<dl class="c macro">
<dt id="c.SIP_READ_ONLY">
<code class="sig-name descname">SIP_READ_ONLY</code><a class="headerlink" href="#c.SIP_READ_ONLY" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.15.2.</span></p>
</div>
<p>This is a flag used by various array constructors that species that the
array is read-only.</p>
</dd></dl>

<dl class="c function">
<dt>
<code class="sig-name descname">SIP_RELEASE_GIL(sip_gilstate_t sipGILState)</code></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.14.4.</span></p>
</div>
<p>This is called from the handwritten code specified with the
<code class="xref std std-directive docutils literal notranslate"><span class="pre">VirtualErrorHandler</span></code> in order to release the Python Global
Interpreter Lock (GIL) prior to changing the execution path (e.g. by
throwing a C++ exception).  It should not be called under any other
circumstances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sipGILState</strong> – an opaque value provided to the handwritten code by SIP.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt id="c.SIP_SSIZE_T">
<code class="sig-name descname">SIP_SSIZE_T</code><a class="headerlink" href="#c.SIP_SSIZE_T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a C preprocessor macro that is defined as <code class="docutils literal notranslate"><span class="pre">Py_ssize_t</span></code> for Python
v2.5 and later, and as <code class="docutils literal notranslate"><span class="pre">int</span></code> for earlier versions of Python.  It makes it
easier to write PEP 353 compliant handwritten code.</p>
</dd></dl>

<dl class="c macro">
<dt id="c.SIP_SSIZE_T_FORMAT">
<code class="sig-name descname">SIP_SSIZE_T_FORMAT</code><a class="headerlink" href="#c.SIP_SSIZE_T_FORMAT" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.15.4.</span></p>
</div>
<p>This is a C preprocessor macro that is defined as <code class="docutils literal notranslate"><span class="pre">%zd</span></code> for Python
v2.5 and later, and as <code class="docutils literal notranslate"><span class="pre">%d</span></code> for earlier versions of Python.  It makes it
easier to write PEP 353 compliant handwritten code.</p>
</dd></dl>

<dl class="c macro">
<dt id="c.SIP_UNBLOCK_THREADS">
<code class="sig-name descname">SIP_UNBLOCK_THREADS</code><a class="headerlink" href="#c.SIP_UNBLOCK_THREADS" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a C preprocessor macro that will restore the Python Global
Interpreter Lock (GIL) to the state it was prior to the corresponding
<a class="reference internal" href="#c.SIP_BLOCK_THREADS" title="SIP_BLOCK_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_BLOCK_THREADS</span></code></a>.</p>
</dd></dl>

<dl class="c macro">
<dt id="c.SIP_USE_PYCAPSULE">
<code class="sig-name descname">SIP_USE_PYCAPSULE</code><a class="headerlink" href="#c.SIP_USE_PYCAPSULE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.11.</span></p>
</div>
<p>This is a C preprocessor symbol that is defined when <code class="docutils literal notranslate"><span class="pre">PyCapsule</span></code> objects
are being used rather than the (now deprecated) <code class="docutils literal notranslate"><span class="pre">PyCObject</span></code> objects.</p>
</dd></dl>

<dl class="c macro">
<dt id="c.SIP_VERSION">
<code class="sig-name descname">SIP_VERSION</code><a class="headerlink" href="#c.SIP_VERSION" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a C preprocessor symbol that defines the SIP version number
represented as a 3 part hexadecimal number (e.g. v5.0.0 is represented as
<code class="docutils literal notranslate"><span class="pre">0x050000</span></code>).</p>
</dd></dl>

<dl class="c macro">
<dt id="c.SIP_VERSION_STR">
<code class="sig-name descname">SIP_VERSION_STR</code><a class="headerlink" href="#c.SIP_VERSION_STR" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a C preprocessor symbol that defines the SIP version number
represented as a string.  For development versions it will contain either
<code class="docutils literal notranslate"><span class="pre">.dev</span></code> or <code class="docutils literal notranslate"><span class="pre">-snapshot-</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipBadCallableArg">
sipErrorState <code class="sig-name descname">sipBadCallableArg</code><span class="sig-paren">(</span>int <em>arg_nr</em>, PyObject *<em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipBadCallableArg" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.10.</span></p>
</div>
<p>This is called from <a class="reference internal" href="directives.html#std-directive-MethodCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%MethodCode</span></code></a> to raise a Python exception
when an argument to a function, a C++ constructor or method is found to
have an unexpected type.  This should be used when the
<a class="reference internal" href="directives.html#std-directive-MethodCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%MethodCode</span></code></a> does additional type checking of the supplied
arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg_nr</strong> – the number of the argument.  Arguments are numbered from 0 but are
numbered from 1 in the detail of the exception.</p></li>
<li><p><strong>arg</strong> – the argument.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the value that should be assigned to <code class="docutils literal notranslate"><span class="pre">sipError</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipBadCatcherResult">
void <code class="sig-name descname">sipBadCatcherResult</code><span class="sig-paren">(</span>PyObject *<em>method</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipBadCatcherResult" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This raises a Python exception when the result of a Python reimplementation
of a C++ method doesn’t have the expected type.  It is normally called by
handwritten code specified with the <a class="reference internal" href="directives.html#std-directive-VirtualCatcherCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%VirtualCatcherCode</span></code></a>
directive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> – the Python method and would normally be the supplied <code class="docutils literal notranslate"><span class="pre">sipMethod</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipBadLengthForSlice">
void <code class="sig-name descname">sipBadLengthForSlice</code><span class="sig-paren">(</span><a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> <em>seqlen</em>, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> <em>slicelen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipBadLengthForSlice" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This raises a Python exception when the length of a slice object is
inappropriate for a sequence-like object.  It is normally called by
handwritten code specified for <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code> methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seqlen</strong> – the length of the sequence.</p></li>
<li><p><strong>slicelen</strong> – the length of the slice.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c type">
<dt id="c.sipBufferInfoDef">
<em class="property">type </em><code class="sig-name descname">sipBufferInfoDef</code><a class="headerlink" href="#c.sipBufferInfoDef" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This C structure is used with <a class="reference internal" href="#c.sipGetBufferInfo" title="sipGetBufferInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipGetBufferInfo()</span></code></a> and
<a class="reference internal" href="#c.sipReleaseBufferInfo" title="sipReleaseBufferInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipReleaseBufferInfo()</span></code></a> and encapsulates information provided by a
Python object that implements the buffer protocol.  The structure elements
are as follows.</p>
<dl class="c member">
<dt>
<code class="sig-name descname">void \*bi_buf</code></dt>
<dd><p>The address of the buffer.</p>
</dd></dl>

<dl class="c member">
<dt>
<code class="sig-name descname">PyObject \*bi_obj</code></dt>
<dd><p>A reference to the object that implements the buffer protocol.</p>
</dd></dl>

<dl class="c member">
<dt id="c.sipBufferInfoDef.bi_len">
<a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> <code class="sig-name descname">bi_len</code><a class="headerlink" href="#c.sipBufferInfoDef.bi_len" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The length of the buffer in bytes.</p>
</dd></dl>

<dl class="c member">
<dt>
<code class="sig-name descname">char \*bi_format</code></dt>
<dd><p>The format of each element of the buffer.</p>
</dd></dl>

</dd></dl>

<dl class="c function">
<dt id="c.sipBuildResult">
PyObject *<code class="sig-name descname">sipBuildResult</code><span class="sig-paren">(</span>int *<em>iserr</em>, <em class="property">const</em> char *<em>format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.sipBuildResult" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This creates a Python object based on a format string and associated
values in a similar way to the Python <code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iserr</strong> – if this is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the location it points to is set to a
non-zero value.</p></li>
<li><p><strong>format</strong> – the string of format characters.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If there was an error then <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned and a Python exception
is raised.</p>
</dd>
</dl>
<p>If the format string begins and ends with parentheses then a tuple of
objects is created.  If it contains more than one format character then
parentheses must be specified.</p>
<p>In the following description the first letter is the format character, the
entry in parentheses is the Python object type that the format character
will create, and the entry in brackets are the types of the C/C++ values
to be passed.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code> (string) [char]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">char</span></code> to a Python v2 or v3 string object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code> (boolean) [int]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">int</span></code> to a Python boolean.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code> (string/bytes) [char]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">char</span></code> to a Python v2 string object or a Python v3
bytes object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d</span></code> (float) [double]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">double</span></code> to a Python floating point number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e</span></code> (integer) [enum]</dt><dd><p>Convert an anonymous C/C++ <code class="docutils literal notranslate"><span class="pre">enum</span></code> to a Python integer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code> (float) [float]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">float</span></code> to a Python floating point number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g</span></code> (string/bytes) [char *, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_SSIZE_T</span></code></a>]</dt><dd><p>Convert a C/C++ character array and its length to a Python v2 string
object or a Python v3 bytes object.  If the array is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the
length is ignored and the result is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h</span></code> (integer) [short]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">short</span></code> to a Python integer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i</span></code> (integer) [int]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">int</span></code> to a Python integer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">l</span></code> (long) [long]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">long</span></code> to a Python integer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">m</span></code> (long) [unsigned long]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code> to a Python long.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code> (long) [long long]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code> to a Python long.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">o</span></code> (long) [unsigned long long]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> to a Python long.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">r</span></code> (wrapped instance) [<em>type</em> *, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_SSIZE_T</span></code></a>, const <code class="xref c c-type docutils literal notranslate"><span class="pre">sipTypeDef</span></code> *]</dt><dd><p>Convert an array of C structures, C++ classes or mapped type instances
to a Python tuple.  Note that copies of the array elements are made.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code> (string/bytes) [char *]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> terminated string to a Python v2 string object
or a Python v3 bytes object.  If the string pointer is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then
the result is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">t</span></code> (long) [unsigned short]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code> to a Python long.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u</span></code> (long) [unsigned int]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> to a Python long.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">w</span></code> (unicode/string) [wchar_t]</dt><dd><p>Convert a C/C++ wide character to a Python v2 unicode object or a
Python v3 string object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code> (unicode/string) [wchar_t *]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">L'\0'</span></code> terminated wide character string to a Python
v2 unicode object or a Python v3 string object.  If the string pointer
is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the result is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">A</span></code> (string) [char *]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> terminated string to a Python v2 or v3 string
object.  If the string pointer is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the result is
<code class="docutils literal notranslate"><span class="pre">Py_None</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">B</span></code> (wrapped instance) [<em>type</em> *, <a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType"><code class="xref c c-type docutils literal notranslate"><span class="pre">sipWrapperType</span></code></a> *, PyObject *]</dt><dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <code class="docutils literal notranslate"><span class="pre">N</span></code> instead.</p>
</div>
<p>Convert a new C structure or a new C++ class instance to a Python class
instance object.  Ownership of the structure or instance is determined
by the <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code> argument.  If it is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and the instance has
already been wrapped then the ownership is unchanged.  If it is
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> or <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then ownership will be with Python.  Otherwise
ownership will be with C/C++ and the instance associated with the
<code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code> argument.  The Python class is influenced by any
applicable <a class="reference internal" href="directives.html#std-directive-ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">C</span></code> (wrapped instance) [<em>type</em> *, <a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType"><code class="xref c c-type docutils literal notranslate"><span class="pre">sipWrapperType</span></code></a> *, PyObject *]</dt><dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <code class="docutils literal notranslate"><span class="pre">D</span></code> instead.</p>
</div>
<p>Convert a C structure or a C++ class instance to a Python class
instance object.  If the structure or class instance has already been
wrapped then the result is a new reference to the existing class
instance object.  Ownership of the structure or instance is determined
by the <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code> argument.  If it is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and the instance has
already been wrapped then the ownership is unchanged.  If it is
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> and the instance is newly wrapped then ownership will be with
C/C++.  If it is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then ownership is transferred to Python
via a call to <a class="reference internal" href="#c.sipTransferBack" title="sipTransferBack"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferBack()</span></code></a>.  Otherwise ownership is
transferred to C/C++ and the instance associated with the
<code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code> argument via a call to <a class="reference internal" href="#c.sipTransferTo" title="sipTransferTo"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferTo()</span></code></a>.  The
Python class is influenced by any applicable
<a class="reference internal" href="directives.html#std-directive-ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">D</span></code> (wrapped instance) [<em>type</em> *, const <code class="xref c c-type docutils literal notranslate"><span class="pre">sipTypeDef</span></code> *, PyObject *]</dt><dd><p>Convert a C structure, C++ class or mapped type instance to a Python
object.  If the instance has already been wrapped then the result is a
new reference to the existing object.  Ownership of the instance is
determined by the <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code> argument.  If it is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and the
instance has already been wrapped then the ownership is unchanged.  If
it is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and the instance is newly wrapped then ownership will be
with C/C++.  If it is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then ownership is transferred to
Python via a call to <a class="reference internal" href="#c.sipTransferBack" title="sipTransferBack"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferBack()</span></code></a>.  Otherwise ownership
is transferred to C/C++ and the instance associated with the
<code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code> argument via a call to <a class="reference internal" href="#c.sipTransferTo" title="sipTransferTo"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferTo()</span></code></a>.  The
Python class is influenced by any applicable
<a class="reference internal" href="directives.html#std-directive-ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">E</span></code> (wrapped enum) [enum, PyTypeObject *]</dt><dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <code class="docutils literal notranslate"><span class="pre">F</span></code> instead.</p>
</div>
<p>Convert a named C/C++ <code class="docutils literal notranslate"><span class="pre">enum</span></code> to an instance of the corresponding
Python named enum type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">F</span></code> (wrapped enum) [enum, <code class="xref c c-type docutils literal notranslate"><span class="pre">sipTypeDef</span></code> *]</dt><dd><p>Convert a named C/C++ <code class="docutils literal notranslate"><span class="pre">enum</span></code> to an instance of the corresponding
Python named enum type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">G</span></code> (unicode) [wchar_t *, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_SSIZE_T</span></code></a>]</dt><dd><p>Convert a C/C++ wide character array and its length to a Python unicode
object.  If the array is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the length is ignored and the
result is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">L</span></code> (integer) [char]</dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.12.</span></p>
</div>
<p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">char</span></code> to a Python integer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">M</span></code> (long) [unsigned char]</dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.12.</span></p>
</div>
<p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code> to a Python long.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">N</span></code> (wrapped instance) [<em>type</em> *, <code class="xref c c-type docutils literal notranslate"><span class="pre">sipTypeDef</span></code> *, PyObject *]</dt><dd><p>Convert a new C structure, C++ class or mapped type instance to a
Python object.  Ownership of the instance is determined by the
<code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code> argument.  If it is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and the instance has
already been wrapped then the ownership is unchanged.  If it is
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> or <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then ownership will be with Python.  Otherwise
ownership will be with C/C++ and the instance associated with the
<code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code> argument.  The Python class is influenced by any
applicable <a class="reference internal" href="directives.html#std-directive-ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">R</span></code> (object) [PyObject *]</dt><dd><p>The result is value passed without any conversions.  The reference
count is unaffected, i.e. a reference is taken.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S</span></code> (object) [PyObject *]</dt><dd><p>The result is value passed without any conversions.  The reference
count is incremented.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">V</span></code> (sip.voidptr) [void *]</dt><dd><p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> to a Python <a class="reference internal" href="python_api.html#sip.voidptr" title="sip.voidptr"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.voidptr</span></code></a> object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z</span></code> (object) [const char *, void *]</dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.14.1.</span></p>
</div>
<p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> to a Python named capsule object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">=</span></code> (long) [size_t]</dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.14.</span></p>
</div>
<p>Convert a C/C++ <code class="docutils literal notranslate"><span class="pre">size_t</span></code> to a Python long.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipCallMethod">
PyObject *<code class="sig-name descname">sipCallMethod</code><span class="sig-paren">(</span>int *<em>iserr</em>, PyObject *<em>method</em>, <em class="property">const</em> char *<em>format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.sipCallMethod" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This calls a Python method passing a tuple of arguments based on a format
string and associated values in a similar way to the Python
<code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallObject()</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iserr</strong> – if this is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the location it points to is set to a
non-zero value if there was an error.</p></li>
<li><p><strong>method</strong> – the Python bound method to call.</p></li>
<li><p><strong>format</strong> – the string of format characters (see <a class="reference internal" href="#c.sipBuildResult" title="sipBuildResult"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipBuildResult()</span></code></a>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If there was an error then <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned and a Python exception
is raised.</p>
</dd>
</dl>
<p>It is normally called by handwritten code specified with the
<a class="reference internal" href="directives.html#std-directive-VirtualCatcherCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%VirtualCatcherCode</span></code></a> directive with method being the supplied
<code class="docutils literal notranslate"><span class="pre">sipMethod</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipCanConvertToEnum">
int <code class="sig-name descname">sipCanConvertToEnum</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <em class="property">const</em> sipTypeDef *<em>td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipCanConvertToEnum" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.19.4: </span>Use <a class="reference internal" href="#c.sipConvertToEnum" title="sipConvertToEnum"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToEnum()</span></code></a> instead.</p>
</div>
<p>This checks if a Python object can be converted to a named enum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
<li><p><strong>td</strong> – the enum’s <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the object can be converted.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipCanConvertToInstance">
int <code class="sig-name descname">sipCanConvertToInstance</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType">sipWrapperType</a> *<em>type</em>, int <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipCanConvertToInstance" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipCanConvertToType" title="sipCanConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipCanConvertToType()</span></code></a> instead.</p>
</div>
<p>This checks if a Python object can be converted to an instance of a C
structure or C++ class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
<li><p><strong>type</strong> – the C/C++ type’s <a class="reference internal" href="#ref-type-objects"><span class="std std-ref">generated type object</span></a>.</p></li>
<li><p><strong>flags</strong> – any combination of the <a class="reference internal" href="#c.SIP_NOT_NONE" title="SIP_NOT_NONE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_NOT_NONE</span></code></a> and
<a class="reference internal" href="#c.SIP_NO_CONVERTORS" title="SIP_NO_CONVERTORS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_NO_CONVERTORS</span></code></a> flags.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the object can be converted.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipCanConvertToMappedType">
int <code class="sig-name descname">sipCanConvertToMappedType</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <em class="property">const</em> sipMappedType *<em>mt</em>, int <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipCanConvertToMappedType" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipCanConvertToType" title="sipCanConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipCanConvertToType()</span></code></a> instead.</p>
</div>
<p>This checks if a Python object can be converted to an instance of a C
structure or C++ class which has been implemented as a mapped type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
<li><p><strong>mt</strong> – the opaque structure returned by <a class="reference internal" href="#c.sipFindMappedType" title="sipFindMappedType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipFindMappedType()</span></code></a>.</p></li>
<li><p><strong>flags</strong> – this may be the <a class="reference internal" href="#c.SIP_NOT_NONE" title="SIP_NOT_NONE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_NOT_NONE</span></code></a> flag.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the object can be converted.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipCanConvertToType">
int <code class="sig-name descname">sipCanConvertToType</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <em class="property">const</em> sipTypeDef *<em>td</em>, int <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipCanConvertToType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This checks if a Python object can be converted to an instance of a C
structure, C++ class or mapped type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
<li><p><strong>td</strong> – the C/C++ type’s <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>.</p></li>
<li><p><strong>flags</strong> – any combination of the <a class="reference internal" href="#c.SIP_NOT_NONE" title="SIP_NOT_NONE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_NOT_NONE</span></code></a> and
<a class="reference internal" href="#c.SIP_NO_CONVERTORS" title="SIP_NO_CONVERTORS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_NO_CONVERTORS</span></code></a> flags.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the object can be converted.</p>
</dd>
</dl>
</dd></dl>

<dl class="c type">
<dt id="c.sipCFunctionDef">
<em class="property">type </em><code class="sig-name descname">sipCFunctionDef</code><a class="headerlink" href="#c.sipCFunctionDef" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This C structure is used with <a class="reference internal" href="#c.sipGetCFunction" title="sipGetCFunction"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipGetCFunction()</span></code></a> and encapsulates
the components parts of a Python C function.  The structure elements are as
follows.</p>
<dl class="c member">
<dt>
<code class="sig-name descname">PyMethodDef \*cf_function</code></dt>
<dd><p>The C function.</p>
</dd></dl>

<dl class="c member">
<dt>
<code class="sig-name descname">PyObject \*cf_self</code></dt>
<dd><p>The optional bound object.</p>
</dd></dl>

</dd></dl>

<dl class="c function">
<dt id="c.sipClassName">
PyObject *<code class="sig-name descname">sipClassName</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipClassName" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use the following instead:</p>
<blockquote>
<div><p>PyString_FromString(obj-&gt;ob_type-&gt;tp_name)</p>
</div></blockquote>
</div>
<p>This gets the class name of a wrapped instance as a Python string.  It
comes with a reference.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the wrapped instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the name of the instance’s class.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertFromConstVoidPtr">
PyObject *<code class="sig-name descname">sipConvertFromConstVoidPtr</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>cpp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertFromConstVoidPtr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This creates a <a class="reference internal" href="python_api.html#sip.voidptr" title="sip.voidptr"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.voidptr</span></code></a> object for a memory address.  The
object will not be writeable and has no associated size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cpp</strong> – the memory address.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <a class="reference internal" href="python_api.html#sip.voidptr" title="sip.voidptr"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.voidptr</span></code></a> object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertFromConstVoidPtrAndSize">
PyObject *<code class="sig-name descname">sipConvertFromConstVoidPtrAndSize</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>cpp</em>, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertFromConstVoidPtrAndSize" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This creates a <a class="reference internal" href="python_api.html#sip.voidptr" title="sip.voidptr"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.voidptr</span></code></a> object for a memory address.  The
object will not be writeable and can be used as an immutable buffer object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cpp</strong> – the memory address.</p></li>
<li><p><strong>size</strong> – the size associated with the address.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <a class="reference internal" href="python_api.html#sip.voidptr" title="sip.voidptr"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.voidptr</span></code></a> object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertFromEnum">
PyObject *<code class="sig-name descname">sipConvertFromEnum</code><span class="sig-paren">(</span>int <em>eval</em>, <em class="property">const</em> sipTypeDef *<em>td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertFromEnum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This converts a named C/C++ <code class="docutils literal notranslate"><span class="pre">enum</span></code> to a Python object.  If the enum is a
C++11 scoped enum then the Python object is created using the
<code class="xref py py-mod docutils literal notranslate"><span class="pre">enum</span></code> module.  Otherwise a SIP generated type is used that can
itself be converted to an <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval</strong> – the enumerated value to convert.</p></li>
<li><p><strong>td</strong> – the enum’s <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Python object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertFromInstance">
PyObject *<code class="sig-name descname">sipConvertFromInstance</code><span class="sig-paren">(</span>void *<em>cpp</em>, <a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType">sipWrapperType</a> *<em>type</em>, PyObject *<em>transferObj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertFromInstance" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipConvertFromType" title="sipConvertFromType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertFromType()</span></code></a> instead.</p>
</div>
<p>This converts a C structure or a C++ class instance to an instance of the
corresponding generated Python type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cpp</strong> – the C/C++ instance.</p></li>
<li><p><strong>type</strong> – the type’s <a class="reference internal" href="#ref-type-objects"><span class="std std-ref">generated type object</span></a>.</p></li>
<li><p><strong>transferObj</strong> – this controls the ownership of the returned value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Python object.</p>
</dd>
</dl>
<p>If the C/C++ instance has already been wrapped then the result is a
new reference to the existing class instance object.</p>
<p>If <em>transferObj</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and the instance has already been wrapped then
the ownership is unchanged.</p>
<p>If <em>transferObj</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and the instance is newly wrapped then
ownership will be with C/C++.</p>
<p>If <em>transferObj</em> is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then ownership is transferred to Python via
a call to <a class="reference internal" href="#c.sipTransferBack" title="sipTransferBack"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferBack()</span></code></a>.</p>
<p>Otherwise ownership is transferred to C/C++ and the instance associated
with <em>transferObj</em> via a call to <a class="reference internal" href="#c.sipTransferTo" title="sipTransferTo"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferTo()</span></code></a>.</p>
<p>The Python type is influenced by any applicable
<a class="reference internal" href="directives.html#std-directive-ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> code.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertFromMappedType">
PyObject *<code class="sig-name descname">sipConvertFromMappedType</code><span class="sig-paren">(</span>void *<em>cpp</em>, <em class="property">const</em> sipMappedType *<em>mt</em>, PyObject *<em>transferObj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertFromMappedType" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipConvertFromType" title="sipConvertFromType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertFromType()</span></code></a> instead.</p>
</div>
<p>This converts a C structure or a C++ class instance wrapped as a mapped
type to an instance of the corresponding generated Python type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cpp</strong> – the C/C++ instance.</p></li>
<li><p><strong>mt</strong> – the opaque structure returned by <a class="reference internal" href="#c.sipFindMappedType" title="sipFindMappedType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipFindMappedType()</span></code></a>.</p></li>
<li><p><strong>transferObj</strong> – this controls the ownership of the returned value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Python object.</p>
</dd>
</dl>
<p>If <em>transferObj</em>  is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the ownership is unchanged.</p>
<p>If <em>transferObj</em> is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then ownership is transferred to Python
via a call to <a class="reference internal" href="#c.sipTransferBack" title="sipTransferBack"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferBack()</span></code></a>.</p>
<p>Otherwise ownership is transferred to C/C++ and the instance associated
with <em>transferObj</em> argument via a call to <a class="reference internal" href="#c.sipTransferTo" title="sipTransferTo"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferTo()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertFromNamedEnum">
PyObject *<code class="sig-name descname">sipConvertFromNamedEnum</code><span class="sig-paren">(</span>int <em>eval</em>, PyTypeObject *<em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertFromNamedEnum" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipConvertFromEnum" title="sipConvertFromEnum"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertFromEnum()</span></code></a> instead.</p>
</div>
<p>This converts a named C/C++ <code class="docutils literal notranslate"><span class="pre">enum</span></code> to an instance of the corresponding
generated Python type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval</strong> – the enumerated value to convert.</p></li>
<li><p><strong>type</strong> – the enum’s <a class="reference internal" href="#ref-type-objects"><span class="std std-ref">generated type object</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Python object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertFromNewInstance">
PyObject *<code class="sig-name descname">sipConvertFromNewInstance</code><span class="sig-paren">(</span>void *<em>cpp</em>, <a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType">sipWrapperType</a> *<em>type</em>, PyObject *<em>transferObj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertFromNewInstance" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipConvertFromNewType" title="sipConvertFromNewType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertFromNewType()</span></code></a> instead.</p>
</div>
<p>This converts a new C structure or a C++ class instance to an instance of
the corresponding generated Python type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cpp</strong> – the C/C++ instance.</p></li>
<li><p><strong>type</strong> – the type’s <a class="reference internal" href="#ref-type-objects"><span class="std std-ref">generated type object</span></a>.</p></li>
<li><p><strong>transferObj</strong> – this controls the ownership of the returned value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Python object.</p>
</dd>
</dl>
<p>If <em>transferObj</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then ownership will be with
Python.</p>
<p>Otherwise ownership will be with C/C++ and the instance associated with
<em>transferObj</em>.</p>
<p>The Python type is influenced by any applicable
<a class="reference internal" href="directives.html#std-directive-ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> code.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertFromNewPyType">
PyObject *<code class="sig-name descname">sipConvertFromNewPyType</code><span class="sig-paren">(</span>void *<em>cpp</em>, PyTypeObject *<em>py_type</em>, <a class="reference internal" href="#c.sipWrapper" title="sipWrapper">sipWrapper</a> *<em>owner</em>, <a class="reference internal" href="#c.sipSimpleWrapper" title="sipSimpleWrapper">sipSimpleWrapper</a> **<em>selfp</em>, <em class="property">const</em> char *<em>format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertFromNewPyType" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.15.</span></p>
</div>
<p>This converts a new C structure or a C++ class instance to an instance of a
corresponding Python type (as opposed to the corresponding generated Python
type).  This is useful when the C/C++ library provides some sort of
mechanism whereby handwritten code has some control over the exact type of
structure or class being created.  Typically it would be used to create an
instance of the generated derived class which would then allow Python
re-implementations of C++ virtual methods to function properly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cpp</strong> – the C/C++ instance.</p></li>
<li><p><strong>py_type</strong> – the Python type object.  This is called to create the Python object and
is passed the arguments defined by the string of format characters.</p></li>
<li><p><strong>owner</strong> – is the optional owner of the Python object.</p></li>
<li><p><strong>selfp</strong> – is an optional pointer to the <code class="docutils literal notranslate"><span class="pre">sipPySelf</span></code> instance variable of the
C/C++ instance if that instance’s type is a generated derived class.
Otherwise it should be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p></li>
<li><p><strong>format</strong> – the string of format characters (see <a class="reference internal" href="#c.sipBuildResult" title="sipBuildResult"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipBuildResult()</span></code></a>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Python object.  If there was an error then <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned and
a Python exception is raised.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertFromNewType">
PyObject *<code class="sig-name descname">sipConvertFromNewType</code><span class="sig-paren">(</span>void *<em>cpp</em>, <em class="property">const</em> sipTypeDef *<em>td</em>, PyObject *<em>transferObj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertFromNewType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This converts a new C structure or a C++ class instance to an instance of
the corresponding generated Python type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cpp</strong> – the C/C++ instance.</p></li>
<li><p><strong>td</strong> – the type’s <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>.</p></li>
<li><p><strong>transferObj</strong> – this controls the ownership of the returned value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Python object.</p>
</dd>
</dl>
<p>If <em>transferObj</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then ownership will be with
Python.</p>
<p>Otherwise ownership will be with C/C++ and the instance associated with
<em>transferObj</em>.</p>
<p>The Python type is influenced by any applicable
<a class="reference internal" href="directives.html#std-directive-ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> code.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertFromSequenceIndex">
<a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> <code class="sig-name descname">sipConvertFromSequenceIndex</code><span class="sig-paren">(</span><a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> <em>idx</em>, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertFromSequenceIndex" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This converts a Python sequence index (i.e. where a negative value refers
to the offset from the end of the sequence) to a C/C++ array index.  If the
index was out of range then a negative value is returned and a Python
exception raised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong> – the sequence index.</p></li>
<li><p><strong>len</strong> – the length of the sequence.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the unsigned array index.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertFromSliceObject">
int <code class="sig-name descname">sipConvertFromSliceObject</code><span class="sig-paren">(</span>PyObject *<em>slice</em>, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> <em>length</em>, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> *<em>start</em>, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> *<em>stop</em>, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> *<em>step</em>, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> *<em>slicelength</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertFromSliceObject" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a thin wrapper around the Python <code class="xref c c-func docutils literal notranslate"><span class="pre">PySlice_GetIndicesEx()</span></code>
function provided to make it easier to write handwritten code that is
compatible with SIP v3.x and versions of Python earlier that v2.3.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertFromType">
PyObject *<code class="sig-name descname">sipConvertFromType</code><span class="sig-paren">(</span>void *<em>cpp</em>, <em class="property">const</em> sipTypeDef *<em>td</em>, PyObject *<em>transferObj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertFromType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This converts a C structure or a C++ class instance to an instance of the
corresponding generated Python type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cpp</strong> – the C/C++ instance.</p></li>
<li><p><strong>td</strong> – the type’s <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>.</p></li>
<li><p><strong>transferObj</strong> – this controls the ownership of the returned value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Python object.</p>
</dd>
</dl>
<p>If the C/C++ instance has already been wrapped then the result is a new
reference to the existing object.</p>
<p>If <em>transferObj</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and the instance has already been wrapped then
the ownership is unchanged.</p>
<p>If <em>transferObj</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and the instance is newly wrapped then
ownership will be with C/C++.</p>
<p>If <em>transferObj</em> is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then ownership is transferred to Python via
a call to <a class="reference internal" href="#c.sipTransferBack" title="sipTransferBack"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferBack()</span></code></a>.</p>
<p>Otherwise ownership is transferred to C/C++ and the instance associated
with <em>transferObj</em> via a call to <a class="reference internal" href="#c.sipTransferTo" title="sipTransferTo"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferTo()</span></code></a>.</p>
<p>The Python class is influenced by any applicable
<a class="reference internal" href="directives.html#std-directive-ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> code.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertFromVoidPtr">
PyObject *<code class="sig-name descname">sipConvertFromVoidPtr</code><span class="sig-paren">(</span>void *<em>cpp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertFromVoidPtr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This creates a <a class="reference internal" href="python_api.html#sip.voidptr" title="sip.voidptr"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.voidptr</span></code></a> object for a memory address.  The
object will be writeable but has no associated size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cpp</strong> – the memory address.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <a class="reference internal" href="python_api.html#sip.voidptr" title="sip.voidptr"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.voidptr</span></code></a> object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertFromVoidPtrAndSize">
PyObject *<code class="sig-name descname">sipConvertFromVoidPtrAndSize</code><span class="sig-paren">(</span>void *<em>cpp</em>, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertFromVoidPtrAndSize" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This creates a <a class="reference internal" href="python_api.html#sip.voidptr" title="sip.voidptr"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.voidptr</span></code></a> object for a memory address.  The
object will be writeable and can be used as a mutable buffer object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cpp</strong> – the memory address.</p></li>
<li><p><strong>size</strong> – the size associated with the address.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <a class="reference internal" href="python_api.html#sip.voidptr" title="sip.voidptr"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.voidptr</span></code></a> object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertToArray">
PyObject *<code class="sig-name descname">sipConvertToArray</code><span class="sig-paren">(</span>void *<em>data</em>, <em class="property">const</em> char *<em>format</em>, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> <em>len</em>, int <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertToArray" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.15.</span></p>
</div>
<p>This converts a one dimensional array of fundamental types to a
<a class="reference internal" href="python_api.html#sip.array" title="sip.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.array</span></code></a> object.</p>
<p>An array is very like a Python <code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code> object.  The underlying
memory is not copied and may be modified in situ.  Arrays support the
buffer protocol and so can be passed to other modules, again without the
underlying memory being copied.</p>
<p><a class="reference internal" href="python_api.html#sip.array" title="sip.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.array</span></code></a> objects are not supported by the <strong class="program">sip</strong> code
generator.  They can only be created by handwritten code or by
<a class="reference internal" href="python_api.html#sip.voidptr.asarray" title="sip.voidptr.asarray"><code class="xref py py-func docutils literal notranslate"><span class="pre">sip.voidptr.asarray()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – the address of the start of the C/C++ array.</p></li>
<li><p><strong>format</strong> – the format, as defined by the <code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code> module, of an array
element.  At the moment only <code class="docutils literal notranslate"><span class="pre">b</span></code> (char), <code class="docutils literal notranslate"><span class="pre">B</span></code> (unsigned char),
<code class="docutils literal notranslate"><span class="pre">h</span></code> (short), <code class="docutils literal notranslate"><span class="pre">H</span></code> (unsigned short), <code class="docutils literal notranslate"><span class="pre">i</span></code> (int),
<code class="docutils literal notranslate"><span class="pre">I</span></code> (unsigned int), <code class="docutils literal notranslate"><span class="pre">f</span></code> (float) and <code class="docutils literal notranslate"><span class="pre">d</span></code> (double) are supported.</p></li>
<li><p><strong>len</strong> – the number of elements in the array.</p></li>
<li><p><strong>readonly</strong> – is non-zero if the array is read-only.</p></li>
<li><p><strong>flags</strong> – any combination of the <a class="reference internal" href="#c.SIP_READ_ONLY" title="SIP_READ_ONLY"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_READ_ONLY</span></code></a> and
<a class="reference internal" href="#c.SIP_OWNS_MEMORY" title="SIP_OWNS_MEMORY"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_OWNS_MEMORY</span></code></a> flags.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <a class="reference internal" href="python_api.html#sip.array" title="sip.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.array</span></code></a> object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertToBool">
int <code class="sig-name descname">sipConvertToBool</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertToBool" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.4.</span></p>
</div>
<p>This converts a Python object to an integer corresponding to a C++
<code class="docutils literal notranslate"><span class="pre">bool</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object to convert.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the boolean value as an integer.  <code class="docutils literal notranslate"><span class="pre">1</span></code> corresponds to <code class="docutils literal notranslate"><span class="pre">true</span></code> and
<code class="docutils literal notranslate"><span class="pre">0</span></code> corresponds to <code class="docutils literal notranslate"><span class="pre">false</span></code>.  <code class="docutils literal notranslate"><span class="pre">-1</span></code> is returned, and an exception
is raised, if there was an error.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertToEnum">
int <code class="sig-name descname">sipConvertToEnum</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <em class="property">const</em> sipTypeDef *<em>td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertToEnum" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.4.</span></p>
</div>
<p>This converts a Python object to the value of a named C/C++ <code class="docutils literal notranslate"><span class="pre">enum</span></code>
member.  If the enum is a C++11 scoped enum then the Python object must be
a member of the enum.  Otherwise it may also be an <code class="docutils literal notranslate"><span class="pre">int</span></code> corresponding to
the name of the member.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object to convert.</p></li>
<li><p><strong>td</strong> – the enum’s <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the integer value.  An exception is raised if there was an error.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertToInstance">
void *<code class="sig-name descname">sipConvertToInstance</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType">sipWrapperType</a> *<em>type</em>, PyObject *<em>transferObj</em>, int <em>flags</em>, int *<em>state</em>, int *<em>iserr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertToInstance" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipConvertToType" title="sipConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToType()</span></code></a> instead.</p>
</div>
<p>This converts a Python object to an instance of a C structure or C++ class
assuming that a previous call to <a class="reference internal" href="#c.sipCanConvertToInstance" title="sipCanConvertToInstance"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipCanConvertToInstance()</span></code></a> has
been successful.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
<li><p><strong>type</strong> – the type’s <a class="reference internal" href="#ref-type-objects"><span class="std std-ref">generated type object</span></a>.</p></li>
<li><p><strong>transferObj</strong> – this controls any ownership changes to <em>obj</em>.</p></li>
<li><p><strong>flags</strong> – any combination of the <a class="reference internal" href="#c.SIP_NOT_NONE" title="SIP_NOT_NONE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_NOT_NONE</span></code></a> and
<a class="reference internal" href="#c.SIP_NO_CONVERTORS" title="SIP_NO_CONVERTORS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_NO_CONVERTORS</span></code></a> flags.</p></li>
<li><p><strong>state</strong> – the state of the returned C/C++ instance is returned via this pointer.</p></li>
<li><p><strong>iserr</strong> – the error flag is passed and updated via this pointer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the C/C++ instance.</p>
</dd>
</dl>
<p>If <em>transferObj</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the ownership is unchanged.</p>
<p>If <em>transferObj</em> is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then ownership is transferred to Python via
a call to <a class="reference internal" href="#c.sipTransferBack" title="sipTransferBack"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferBack()</span></code></a>.</p>
<p>Otherwise ownership is transferred to C/C++ and <em>obj</em> associated with
<em>transferObj</em> via a call to <a class="reference internal" href="#c.sipTransferTo" title="sipTransferTo"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferTo()</span></code></a>.</p>
<p>If <em>state</em> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the location it points to is set to
describe the state of the returned C/C++ instance and is the value returned
by any <a class="reference internal" href="directives.html#std-directive-ConvertToTypeCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToTypeCode</span></code></a>.  The calling code must then release
the value at some point to prevent a memory leak by calling
<a class="reference internal" href="#c.sipReleaseInstance" title="sipReleaseInstance"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipReleaseInstance()</span></code></a>.</p>
<p>If there is an error then the location <em>iserr</em> points to is set to a
non-zero value.  If it was initially a non-zero value then the conversion
isn’t attempted in the first place.  (This allows several calls to be made
that share the same error flag so that it only needs to be tested once
rather than after each call.)</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertToMappedType">
void *<code class="sig-name descname">sipConvertToMappedType</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <em class="property">const</em> sipMappedType *<em>mt</em>, PyObject *<em>transferObj</em>, int <em>flags</em>, int *<em>state</em>, int *<em>iserr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertToMappedType" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipConvertToType" title="sipConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToType()</span></code></a> instead.</p>
</div>
<p>This converts a Python object to an instance of a C structure or C++
class that is implemented as a mapped type assuming that a previous call to
<a class="reference internal" href="#c.sipCanConvertToMappedType" title="sipCanConvertToMappedType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipCanConvertToMappedType()</span></code></a> has been successful.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
<li><p><strong>mt</strong> – the opaque structure returned by <a class="reference internal" href="#c.sipFindMappedType" title="sipFindMappedType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipFindMappedType()</span></code></a>.</p></li>
<li><p><strong>transferObj</strong> – this controls any ownership changes to <em>obj</em>.</p></li>
<li><p><strong>flags</strong> – this may be the <a class="reference internal" href="#c.SIP_NOT_NONE" title="SIP_NOT_NONE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_NOT_NONE</span></code></a> flag.</p></li>
<li><p><strong>state</strong> – the state of the returned C/C++ instance is returned via this pointer.</p></li>
<li><p><strong>iserr</strong> – the error flag is passed and updated via this pointer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the C/C++ instance.</p>
</dd>
</dl>
<p>If <em>transferObj</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the ownership is unchanged.</p>
<p>If <em>transferObj</em> is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then ownership is transferred to Python via
a call to <a class="reference internal" href="#c.sipTransferBack" title="sipTransferBack"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferBack()</span></code></a>.</p>
<p>Otherwise ownership is transferred to C/C++ and <em>obj</em> associated with
<em>transferObj</em> via a call to <a class="reference internal" href="#c.sipTransferTo" title="sipTransferTo"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferTo()</span></code></a>.</p>
<p>If <em>state</em> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the location it points to is set to
describe the state of the returned C/C++ instance and is the value returned
by any <a class="reference internal" href="directives.html#std-directive-ConvertToTypeCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToTypeCode</span></code></a>.  The calling code must then release
the value at some point to prevent a memory leak by calling
<a class="reference internal" href="#c.sipReleaseMappedType" title="sipReleaseMappedType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipReleaseMappedType()</span></code></a>.</p>
<p>If there is an error then the location <em>iserr</em> points to is set to a
non-zero value.  If it was initially a non-zero value then the conversion
isn’t attempted in the first place.  (This allows several calls to be made
that share the same error flag so that it only needs to be tested once
rather than after each call.)</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertToType">
void *<code class="sig-name descname">sipConvertToType</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <em class="property">const</em> sipTypeDef *<em>td</em>, PyObject *<em>transferObj</em>, int <em>flags</em>, int *<em>state</em>, int *<em>iserr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertToType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This converts a Python object to an instance of a C structure, C++ class or
mapped type assuming that a previous call to <a class="reference internal" href="#c.sipCanConvertToType" title="sipCanConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipCanConvertToType()</span></code></a>
has been successful.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
<li><p><strong>td</strong> – the type’s <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>.</p></li>
<li><p><strong>transferObj</strong> – this controls any ownership changes to <em>obj</em>.</p></li>
<li><p><strong>flags</strong> – any combination of the <a class="reference internal" href="#c.SIP_NOT_NONE" title="SIP_NOT_NONE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_NOT_NONE</span></code></a> and
<a class="reference internal" href="#c.SIP_NO_CONVERTORS" title="SIP_NO_CONVERTORS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_NO_CONVERTORS</span></code></a> flags.</p></li>
<li><p><strong>state</strong> – the state of the returned C/C++ instance is returned via this pointer.</p></li>
<li><p><strong>iserr</strong> – the error flag is passed and updated via this pointer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the C/C++ instance.</p>
</dd>
</dl>
<p>If <em>transferObj</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the ownership is unchanged.  If it is
<code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then ownership is transferred to Python via a call to
<a class="reference internal" href="#c.sipTransferBack" title="sipTransferBack"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferBack()</span></code></a>.</p>
<p>Otherwise ownership is transferred to C/C++ and <em>obj</em> associated with
<em>transferObj</em> via a call to <a class="reference internal" href="#c.sipTransferTo" title="sipTransferTo"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferTo()</span></code></a>.</p>
<p>Note that <em>obj</em> can also be managed by the C/C++ instance itself, but this
can only be achieved by using <a class="reference internal" href="#c.sipTransferTo" title="sipTransferTo"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTransferTo()</span></code></a>.</p>
<p>If <em>state</em> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the location it points to is set to
describe the state of the returned C/C++ instance and is the value returned
by any <a class="reference internal" href="directives.html#std-directive-ConvertToTypeCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToTypeCode</span></code></a>.  The calling code must then release
the value at some point to prevent a memory leak by calling
<a class="reference internal" href="#c.sipReleaseType" title="sipReleaseType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipReleaseType()</span></code></a>.</p>
<p>If there is an error then the location <em>iserr</em> points to is set to a
non-zero value.  If it was initially a non-zero value then the conversion
isn’t attempted in the first place.  (This allows several calls to be made
that share the same error flag so that it only needs to be tested once
rather than after each call.)</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertToTypedArray">
PyObject *<code class="sig-name descname">sipConvertToTypedArray</code><span class="sig-paren">(</span>void *<em>data</em>, <em class="property">const</em> sipTypeDef *<em>td</em>, <em class="property">const</em> char *<em>format</em>, size_t <em>stride</em>, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> <em>len</em>, int <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertToTypedArray" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.15.</span></p>
</div>
<p>This converts a one dimensional array of instances of a C structure, C++
class or mapped type to a <a class="reference internal" href="python_api.html#sip.array" title="sip.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.array</span></code></a> object.</p>
<p>An array is very like a Python <code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code> object but it’s elements
correspond to C structures or C++ classes.  The underlying memory is not
copied and may be modified in situ.  Arrays support the buffer protocol and
so can be passed to other modules, again without the underlying memory
being copied.</p>
<p><a class="reference internal" href="python_api.html#sip.array" title="sip.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.array</span></code></a> objects are not supported by the <strong class="program">sip</strong> code
generator.  They can only be created by handwritten code.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – the address of the start of the C/C++ array.</p></li>
<li><p><strong>td</strong> – an element’s type’s
<a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>.</p></li>
<li><p><strong>format</strong> – the format, as defined by the <code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code> module, of an array
element.</p></li>
<li><p><strong>stride</strong> – the size of an array element, including any padding.</p></li>
<li><p><strong>len</strong> – the number of elements in the array.</p></li>
<li><p><strong>flags</strong> – the optional <a class="reference internal" href="#c.SIP_READ_ONLY" title="SIP_READ_ONLY"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_READ_ONLY</span></code></a> flag.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <a class="reference internal" href="python_api.html#sip.array" title="sip.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.array</span></code></a> object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipConvertToVoidPtr">
void *<code class="sig-name descname">sipConvertToVoidPtr</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipConvertToVoidPtr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This converts a Python object to a memory address.
<code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_Occurred()</span></code> must be used to determine if the conversion was
successful.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object which may be <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>, a <a class="reference internal" href="python_api.html#sip.voidptr" title="sip.voidptr"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.voidptr</span></code></a> or a
<code class="xref c c-type docutils literal notranslate"><span class="pre">PyCObject</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the memory address.</p>
</dd>
</dl>
</dd></dl>

<dl class="c type">
<dt id="c.sipDateDef">
<em class="property">type </em><code class="sig-name descname">sipDateDef</code><a class="headerlink" href="#c.sipDateDef" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This C structure is used with <a class="reference internal" href="#c.sipGetDate" title="sipGetDate"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipGetDate()</span></code></a>,
<a class="reference internal" href="#c.sipFromDate" title="sipFromDate"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipFromDate()</span></code></a>, <a class="reference internal" href="#c.sipGetDateTime" title="sipGetDateTime"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipGetDateTime()</span></code></a> and
<a class="reference internal" href="#c.sipFromDateTime" title="sipFromDateTime"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipFromDateTime()</span></code></a> and encapsulates the components parts of a
Python date.  The structure elements are as follows.</p>
<dl class="c member">
<dt id="c.sipDateDef.pd_year">
int <code class="sig-name descname">pd_year</code><a class="headerlink" href="#c.sipDateDef.pd_year" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The year.</p>
</dd></dl>

<dl class="c member">
<dt id="c.sipDateDef.pd_month">
int <code class="sig-name descname">pd_month</code><a class="headerlink" href="#c.sipDateDef.pd_month" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The month (1-12).</p>
</dd></dl>

<dl class="c member">
<dt id="c.sipDateDef.pd_day">
int <code class="sig-name descname">pd_day</code><a class="headerlink" href="#c.sipDateDef.pd_day" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The day (1-31).</p>
</dd></dl>

</dd></dl>

<dl class="c function">
<dt id="c.sipEnableAutoconversion">
int <code class="sig-name descname">sipEnableAutoconversion</code><span class="sig-paren">(</span><em class="property">const</em> sipTypeDef *<em>td</em>, int <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipEnableAutoconversion" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.14.7.</span></p>
</div>
<p>Instances of some classes may be automatically converted to other Python
objects even though the class has been wrapped.  This allows that behaviour
to be suppressed so that an instances of the wrapped class is returned
instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>td</strong> – the type’s <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>.  This
must refer to a class.</p></li>
<li><p><strong>enable</strong> – is non-zero if auto-conversion should be enabled for the type.  This is
the default behaviour.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code> depending on whether or not auto-conversion was
previously enabled for the type.  This allows the previous state to be
restored later on.  <code class="docutils literal notranslate"><span class="pre">-1</span></code> is returned, and a Python exception raised,
if there was an error.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipEnableGC">
int <code class="sig-name descname">sipEnableGC</code><span class="sig-paren">(</span>int <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipEnableGC" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.1.</span></p>
</div>
<p>This enables or disables the Python garbarge collector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>enable</strong> – is greater than <code class="docutils literal notranslate"><span class="pre">0</span></code> if the garbage collector should be enabled.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code> depending on whether or not the garbage collector was
previously enabled.  This allows the previous state to be restored
later on.  <code class="docutils literal notranslate"><span class="pre">-1</span></code> is returned if there was an error.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipEnableOverflowChecking">
int <code class="sig-name descname">sipEnableOverflowChecking</code><span class="sig-paren">(</span>int <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipEnableOverflowChecking" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.4.</span></p>
</div>
<p>This enables or disables the checking for overflows when converting Python
integer objects to C/C++ integer types.  When it is enabled an exception is
raised when the value of a Python integer object is too large to fit in the
corresponding C/C++ type.  By default it is disabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>enable</strong> – is greater than <code class="docutils literal notranslate"><span class="pre">0</span></code> if overflow checking should be enabled.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code> depending on whether or not overflow chacking was
previously enabled.  This allows the previous state to be restored
later on.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipExportSymbol">
int <code class="sig-name descname">sipExportSymbol</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em>, void *<em>sym</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipExportSymbol" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Python does not allow extension modules to directly access symbols in
another extension module.  This exports a symbol, referenced by a name,
that can subsequently be imported, using <a class="reference internal" href="#c.sipImportSymbol" title="sipImportSymbol"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipImportSymbol()</span></code></a>, by
another module.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – the name of the symbol.</p></li>
<li><p><strong>sym</strong> – the value of the symbol.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 if there was no error.  A negative value is returned if <em>name</em> is
already associated with a symbol or there was some other error.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipFindClass">
<a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType">sipWrapperType</a> *<code class="sig-name descname">sipFindClass</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipFindClass" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipFindType" title="sipFindType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipFindType()</span></code></a> instead.</p>
</div>
<p>This returns a pointer to the <a class="reference internal" href="#ref-type-objects"><span class="std std-ref">generated type object</span></a> corresponding to a C/C++ type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> – the C/C++ declaration of the type.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the generated type object.  This will not change and may be saved in a
static cache.  <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if the C/C++ type doesn’t exist.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipFindMappedType">
<em class="property">const</em> sipMappedType *<code class="sig-name descname">sipFindMappedType</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipFindMappedType" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipFindType" title="sipFindType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipFindType()</span></code></a> instead.</p>
</div>
<p>This returns a pointer to an opaque structure describing a mapped type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> – the C/C++ declaration of the type.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the opaque structure.  This will not change and may be saved in a
static cache.  <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if the C/C++ type doesn’t exist.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipFindNamedEnum">
PyTypeObject *<code class="sig-name descname">sipFindNamedEnum</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipFindNamedEnum" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipFindType" title="sipFindType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipFindType()</span></code></a> instead.</p>
</div>
<p>This returns a pointer to the <a class="reference internal" href="#ref-enum-type-objects"><span class="std std-ref">generated Python type object</span></a> corresponding to a named unscoped C/C++ enum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> – the C/C++ declaration of the enum.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the generated Python type object.  This will not change and may be
saved in a static cache.  <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if the C/C++ unscoped
enum doesn’t exist.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipFindType">
<em class="property">const</em> sipTypeDef *<code class="sig-name descname">sipFindType</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipFindType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This returns a pointer to the <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a> corresponding to a C/C++ type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> – the C/C++ declaration of the type.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the generated type structure.  This will not change and may be saved in
a static cache.  <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if the C/C++ type doesn’t exist.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipForceConvertToInstance">
void *<code class="sig-name descname">sipForceConvertToInstance</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType">sipWrapperType</a> *<em>type</em>, PyObject *<em>transferObj</em>, int <em>flags</em>, int *<em>state</em>, int *<em>iserr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipForceConvertToInstance" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipForceConvertToType" title="sipForceConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipForceConvertToType()</span></code></a> instead.</p>
</div>
<p>This converts a Python object to an instance of a C structure or C++ class
by calling <a class="reference internal" href="#c.sipCanConvertToInstance" title="sipCanConvertToInstance"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipCanConvertToInstance()</span></code></a> and, if it is successfull,
calling <a class="reference internal" href="#c.sipConvertToInstance" title="sipConvertToInstance"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToInstance()</span></code></a>.</p>
<p>See <a class="reference internal" href="#c.sipConvertToInstance" title="sipConvertToInstance"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToInstance()</span></code></a> for a full description of the
arguments.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipForceConvertToMappedType">
void *<code class="sig-name descname">sipForceConvertToMappedType</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <em class="property">const</em> sipMappedType *<em>mt</em>, PyObject *<em>transferObj</em>, int <em>flags</em>, int *<em>state</em>, int *<em>iserr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipForceConvertToMappedType" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipForceConvertToType" title="sipForceConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipForceConvertToType()</span></code></a> instead.</p>
</div>
<p>This converts a Python object to an instance of a C structure or C++ class
which has been implemented as a mapped type by calling
<a class="reference internal" href="#c.sipCanConvertToMappedType" title="sipCanConvertToMappedType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipCanConvertToMappedType()</span></code></a> and, if it is successfull, calling
<a class="reference internal" href="#c.sipConvertToMappedType" title="sipConvertToMappedType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToMappedType()</span></code></a>.</p>
<p>See <a class="reference internal" href="#c.sipConvertToMappedType" title="sipConvertToMappedType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToMappedType()</span></code></a> for a full description of the
arguments.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipForceConvertToType">
void *<code class="sig-name descname">sipForceConvertToType</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <em class="property">const</em> sipTypeDef *<em>td</em>, PyObject *<em>transferObj</em>, int <em>flags</em>, int *<em>state</em>, int *<em>iserr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipForceConvertToType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This converts a Python object to an instance of a C structure, C++ class or
mapped type by calling <a class="reference internal" href="#c.sipCanConvertToType" title="sipCanConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipCanConvertToType()</span></code></a> and, if it is
successfull, calling <a class="reference internal" href="#c.sipConvertToType" title="sipConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToType()</span></code></a>.</p>
<p>See <a class="reference internal" href="#c.sipConvertToType" title="sipConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToType()</span></code></a> for a full description of the arguments.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipFree">
void <code class="sig-name descname">sipFree</code><span class="sig-paren">(</span>void *<em>mem</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipFree" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This returns an area of memory allocated by <a class="reference internal" href="#c.sipMalloc" title="sipMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipMalloc()</span></code></a> to the
heap.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mem</strong> – the memory address.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipFromDate">
PyObject *<code class="sig-name descname">sipFromDate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#c.sipDateDef" title="sipDateDef">sipDateDef</a> *<em>date</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipFromDate" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This creates a Python date object from its component parts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>date</strong> – the component parts of the date.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Python date object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipFromDateTime">
PyObject *<code class="sig-name descname">sipFromDateTime</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#c.sipDateDef" title="sipDateDef">sipDateDef</a> *<em>date</em>, <em class="property">const</em> <a class="reference internal" href="#c.sipTimeDef" title="sipTimeDef">sipTimeDef</a> *<em>time</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipFromDateTime" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This creates a Python datetime object from its component parts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>date</strong> – the date related component parts of the datetime.</p></li>
<li><p><strong>time</strong> – the time related component parts of the datetime.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Python datetime object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipFromMethod">
PyObject *<code class="sig-name descname">sipFromMethod</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#c.sipMethodDef" title="sipMethodDef">sipMethodDef</a> *<em>method</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipFromMethod" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This creates a Python method object from its component parts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> – the component parts of the method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Python method object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipFromTime">
PyObject *<code class="sig-name descname">sipFromTime</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#c.sipTimeDef" title="sipTimeDef">sipTimeDef</a> *<em>time</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipFromTime" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This creates a Python time object from its component parts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time</strong> – the component parts of the time.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Python time object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipGetAddress">
void *<code class="sig-name descname">sipGetAddress</code><span class="sig-paren">(</span><a class="reference internal" href="#c.sipSimpleWrapper" title="sipSimpleWrapper">sipSimpleWrapper</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipGetAddress" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.12.</span></p>
</div>
<p>This returns the address of the C structure or C++ class instance wrapped
by a Python object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the address of the C/C++ instance</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipGetBufferInfo">
int <code class="sig-name descname">sipGetBufferInfo</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <a class="reference internal" href="#c.sipBufferInfoDef" title="sipBufferInfoDef">sipBufferInfoDef</a> *<em>buffer_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipGetBufferInfo" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This checks to see if an object implements the Python buffer protocol and,
if so, optionally returns the buffer information.  It is similar to
<code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code> and should be used instead of that when the
limited Python API is enabled.  Note that, at the moment, only
1-dimensional buffers are supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
<li><p><strong>buffer_info</strong> – if this is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, and the object implements the buffer protocol,
then the buffer information is returned in this structure.  There
should be a corresponding call to <code class="xref c c-func docutils literal notranslate"><span class="pre">sipReleaseBuffer()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>&gt; 0 if the object supports the buffer protocol and the buffer
information was returned (if requested).  0 if the object does not
support the buffer protocol.  &lt; 0 (and a Python exception is raised) if
the object supports the buffer protocol but there was an error
returning the requested buffer information.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipGetCFunction">
int <code class="sig-name descname">sipGetCFunction</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <a class="reference internal" href="#c.sipCFunctionDef" title="sipCFunctionDef">sipCFunctionDef</a> *<em>c_function</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipGetCFunction" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This checks to see if an object is a Python C function object and, if so,
optionally returns its component parts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
<li><p><strong>c_function</strong> – if this is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, and the object is a C function object, then
the component parts are returned in this structure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the object is a Python C function object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipGetDate">
int <code class="sig-name descname">sipGetDate</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <a class="reference internal" href="#c.sipDateDef" title="sipDateDef">sipDateDef</a> *<em>date</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipGetDate" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This checks to see if an object is a Python date object and, if so,
optionally returns its component parts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
<li><p><strong>date</strong> – if this is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, and the object is a date object, then the
component parts are returned in this structure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the object is a Python date object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipGetDateTime">
int <code class="sig-name descname">sipGetDateTime</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <a class="reference internal" href="#c.sipDateDef" title="sipDateDef">sipDateDef</a> *<em>date</em>, <a class="reference internal" href="#c.sipTimeDef" title="sipTimeDef">sipTimeDef</a> *<em>time</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipGetDateTime" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This checks to see if an object is a Python datetime object and, if so,
optionally returns its component parts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
<li><p><strong>date</strong> – if this is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, and the object is a datetime object, then the
date related component parts are returned in this structure.</p></li>
<li><p><strong>time</strong> – if this is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, and the object is a datetime object, then the
time related component parts are returned in this structure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the object is a Python datetime object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipGetFrame">
<em class="property">struct</em> _frame <code class="sig-name descname">sipGetFrame</code><span class="sig-paren">(</span>int <em>depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipGetFrame" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This retrieves a frame object from the current execution stack.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>depth</strong> – the depth of frame to retrieve where 0 is the current frame, 1 is the
previous frame etc.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the opaque frame or NULL if there wasn’t one at the given depth.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipGetInterpreter">
PyInterpreterState *<code class="sig-name descname">sipGetInterpreter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.sipGetInterpreter" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.17.1.</span></p>
</div>
<p>This returns the address of the Python interpreter.  If it is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then
calls to the Python interpreter library must not be made.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the address of the Python interpreter</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipGetMethod">
int <code class="sig-name descname">sipGetMethod</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <a class="reference internal" href="#c.sipMethodDef" title="sipMethodDef">sipMethodDef</a> *<em>method</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipGetMethod" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This checks to see if an object is a Python method object and, if so,
optionally returns its component parts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
<li><p><strong>method</strong> – if this is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, and the object is a method object, then the
component parts are returned in this structure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the object is a Python method object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipGetMixinAddress">
void *<code class="sig-name descname">sipGetMixinAddress</code><span class="sig-paren">(</span><a class="reference internal" href="#c.sipSimpleWrapper" title="sipSimpleWrapper">sipSimpleWrapper</a> *<em>obj</em>, <em class="property">const</em> sipTypeDef *<em>td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipGetMixinAddress" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.15.</span></p>
</div>
<p>This returns the address of the C++ class instance that implements the
mixin of a wrapped Python object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
<li><p><strong>td</strong> – the <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a> corresponding
to the C++ type of the mixin.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the address of the C++ instance</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipGetPyObject">
PyObject *<code class="sig-name descname">sipGetPyObject</code><span class="sig-paren">(</span>void *<em>cppptr</em>, <em class="property">const</em> sipTypeDef *<em>td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipGetPyObject" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This returns a borrowed reference to the Python object for a C structure or
C++ class instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cppptr</strong> – the pointer to the C/C++ instance.</p></li>
<li><p><strong>td</strong> – the <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a> corresponding
to the C/C++ type.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Python object or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> (and no exception is raised) if the
C/C++ instance hasn’t been wrapped.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipGetState">
int <code class="sig-name descname">sipGetState</code><span class="sig-paren">(</span>PyObject *<em>transferObj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipGetState" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The <a class="reference internal" href="directives.html#std-directive-ConvertToTypeCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToTypeCode</span></code></a> directive requires that the provided
code returns an <code class="docutils literal notranslate"><span class="pre">int</span></code> describing the state of the converted value.  The
state usually depends on any transfers of ownership that have been
requested.  This is a convenience function that returns the correct state
when the converted value is a temporary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transferObj</strong> – the object that describes the requested transfer of ownership.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the state of the converted value.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipGetTime">
int <code class="sig-name descname">sipGetTime</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, <a class="reference internal" href="#c.sipTimeDef" title="sipTimeDef">sipTimeDef</a> *<em>time</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipGetTime" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This checks to see if an object is a Python time object and, if so,
optionally returns its component parts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
<li><p><strong>time</strong> – if this is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, and the object is a time object, then the
component parts are returned in this structure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the object is a Python time object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipGetTypeUserData">
void *<code class="sig-name descname">sipGetTypeUserData</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType">sipWrapperType</a> *<em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipGetTypeUserData" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>Each generated type corresponding to a wrapped C/C++ type, or a user
sub-class of such a type, contains a pointer for the use of handwritten
code.  This returns the value of that pointer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> – the type object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the type-specific pointer.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipGetUserObject">
PyObject *<code class="sig-name descname">sipGetUserObject</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#c.sipSimpleWrapper" title="sipSimpleWrapper">sipSimpleWrapper</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipGetUserObject" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>Each wrapped object can contain a reference to a single Python object that
can be used for any purpose by handwritten code and will automatically be
garbage collected at the appropriate time.  This returns that object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the wrapped object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the user object.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipGetWrapper">
PyObject *<code class="sig-name descname">sipGetWrapper</code><span class="sig-paren">(</span>void *<em>cppptr</em>, <a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType">sipWrapperType</a> *<em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipGetWrapper" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipGetPyObject" title="sipGetPyObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipGetPyObject()</span></code></a> instead.</p>
</div>
<p>This returns a borrowed reference to the wrapped instance object for a C
structure or C++ class instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cppptr</strong> – the pointer to the C/C++ instance.</p></li>
<li><p><strong>type</strong> – the <a class="reference internal" href="#ref-type-objects"><span class="std std-ref">generated type object</span></a> corresponding to
the C/C++ type.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Python object or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> (and no exception is raised) if the
C/C++ instance hasn’t been wrapped.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipImportSymbol">
void *<code class="sig-name descname">sipImportSymbol</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipImportSymbol" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Python does not allow extension modules to directly access symbols in
another extension module.  This imports a symbol, referenced by a name,
that has previously been exported, using <a class="reference internal" href="#c.sipExportSymbol" title="sipExportSymbol"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipExportSymbol()</span></code></a>, by
another module.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – the name of the symbol.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the value of the symbol.  <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if there is no such
symbol.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipInstanceDestroyed">
void <code class="sig-name descname">sipInstanceDestroyed</code><span class="sig-paren">(</span><a class="reference internal" href="#c.sipSimpleWrapper" title="sipSimpleWrapper">sipSimpleWrapper</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipInstanceDestroyed" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.3.</span></p>
</div>
<p>This should be called by handwritten code if it is able to detect that a
wrapped C++ instance has been destroyed from C++.  It should not be called
if SIP is able to detect this itself, i.e. when the instance was created
from Python and the class has a virtual destructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object that wraps the destroyed instance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c type">
<dt id="c.sipIntTypeClassMap">
<em class="property">type </em><code class="sig-name descname">sipIntTypeClassMap</code><a class="headerlink" href="#c.sipIntTypeClassMap" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8.</span></p>
</div>
<p>This C structure is used with <a class="reference internal" href="#c.sipMapIntToClass" title="sipMapIntToClass"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipMapIntToClass()</span></code></a> to define a
mapping between integer based RTTI and <a class="reference internal" href="#ref-type-objects"><span class="std std-ref">generated type objects</span></a>.  The structure elements are as follows.</p>
<dl class="c member">
<dt id="c.sipIntTypeClassMap.typeInt">
int <code class="sig-name descname">typeInt</code><a class="headerlink" href="#c.sipIntTypeClassMap.typeInt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The integer RTTI.</p>
</dd></dl>

<dl class="c member">
<dt>
<code class="sig-name descname">sipWrapperType **pyType.</code></dt>
<dd><p>A pointer to the corresponding generated type object.</p>
</dd></dl>

</dd></dl>

<dl class="c function">
<dt id="c.sipIsAPIEnabled">
int <code class="sig-name descname">sipIsAPIEnabled</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em>, int <em>from</em>, int <em>to</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipIsAPIEnabled" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.9.</span></p>
</div>
<p>This checks to see if the current version number of an API falls within a
given range.  See <a class="reference internal" href="using.html#ref-incompat-apis"><span class="std std-ref">Managing Incompatible APIs</span></a> for more detail.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – the name of the API.</p></li>
<li><p><strong>from</strong> – the lower bound of the range.  For the API to be enabled its version
number must be greater than or equal to <em>from</em>.  If <em>from</em> is 0 then
this check isn’t made.</p></li>
<li><p><strong>to</strong> – the upper bound of the range.  For the API to be enabled its version
number must be less than <em>to</em>.  If <em>to</em> is 0 then this check isn’t
made.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the API is enabled.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipIsOwnedByPython">
int <code class="sig-name descname">sipIsOwnedByPython</code><span class="sig-paren">(</span><a class="reference internal" href="#c.sipSimpleWrapper" title="sipSimpleWrapper">sipSimpleWrapper</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipIsOwnedByPython" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.19.</span></p>
</div>
<p>This determines if a wrapped object is currently owned by Python.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the wrapped object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the object is currently owned by Python.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipIsUserType">
int <code class="sig-name descname">sipIsUserType</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType">sipWrapperType</a> *<em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipIsUserType" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This checks if a type corresponds to a wrapped C/C++ type or a user
sub-class of such a type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> – the type object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the type is a user defined type.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipLong_AsChar">
char <code class="sig-name descname">sipLong_AsChar</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipLong_AsChar" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.4.</span></p>
</div>
<p>This converts a Python object to a C/C++ char.  If the value is too large
then an exception is raised if overflow checking is enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the converted C/C++ value.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipLong_AsSignedChar">
signed char <code class="sig-name descname">sipLong_AsSignedChar</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipLong_AsSignedChar" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.4.</span></p>
</div>
<p>This converts a Python object to a C/C++ signed char.  If the value is too
large then an exception is raised if overflow checking is enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the converted C/C++ value.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipLong_AsUnsignedChar">
unsigned char <code class="sig-name descname">sipLong_AsUnsignedChar</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipLong_AsUnsignedChar" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.4.</span></p>
</div>
<p>This converts a Python object to a C/C++ unsigned char.  If the value is
too large then an exception is raised if overflow checking is enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the converted C/C++ value.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipLong_AsShort">
short <code class="sig-name descname">sipLong_AsShort</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipLong_AsShort" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.4.</span></p>
</div>
<p>This converts a Python object to a C/C++ short.  If the value is too large
then an exception is raised if overflow checking is enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the converted C/C++ value.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipLong_AsUnsignedShort">
unsigned short <code class="sig-name descname">sipLong_AsUnsignedShort</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipLong_AsUnsignedShort" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.4.</span></p>
</div>
<p>This converts a Python object to a C/C++ unsigned short.  If the value is
too large then an exception is raised if overflow checking is enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the converted C/C++ value.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipLong_AsInt">
int <code class="sig-name descname">sipLong_AsInt</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipLong_AsInt" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.4.</span></p>
</div>
<p>This converts a Python object to a C/C++ int.  If the value is too large
then an exception is raised if overflow checking is enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the converted C/C++ value.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipLong_AsUnsignedInt">
unsigned int <code class="sig-name descname">sipLong_AsUnsignedInt</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipLong_AsUnsignedInt" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.4.</span></p>
</div>
<p>This converts a Python object to a C/C++ unsigned int.  If the value is too
large then an exception is raised if overflow checking is enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the converted C/C++ value.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipLong_AsSizeT">
size_t <code class="sig-name descname">sipLong_AsSizeT</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipLong_AsSizeT" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.14.</span></p>
</div>
<p>This converts a Python object to a C/C++ size_t.  If the value is too large
then an exception is raised if overflow checking is enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the converted C/C++ value.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipLong_AsLong">
long <code class="sig-name descname">sipLong_AsLong</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipLong_AsLong" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.4.</span></p>
</div>
<p>This converts a Python object to a C/C++ long.  If the value is too large
then an exception is raised if overflow checking is enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the converted C/C++ value.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipLong_AsUnsignedLong">
unsigned long <code class="sig-name descname">sipLong_AsUnsignedLong</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipLong_AsUnsignedLong" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.4.</span></p>
</div>
<p>This converts a Python object to a C/C++ unsigned long.  If the value is
too large then an exception is raised if overflow checking is enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the converted C/C++ value.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipLong_AsLongLong">
PY_LONG_LONG <code class="sig-name descname">sipLong_AsLongLong</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipLong_AsLongLong" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.4.</span></p>
</div>
<p>This converts a Python object to a C/C++ long long.  If the value is too
large then an exception is raised if overflow checking is enabled.  It is
not available if <code class="docutils literal notranslate"><span class="pre">Python.h</span></code> does not define <code class="docutils literal notranslate"><span class="pre">HAVE_LONG_LONG</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the converted C/C++ value.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt>
<code class="sig-name descname">unsigned PY_LONG_LONG sipLong_AsUnsignedLongLong(PyObject *obj)</code></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.4.</span></p>
</div>
<p>This converts a Python object to a C/C++ unsigned long long.  If the value
is too large then an exception is raised if overflow checking is enabled.
It is not available if <code class="docutils literal notranslate"><span class="pre">Python.h</span></code> does not define <code class="docutils literal notranslate"><span class="pre">HAVE_LONG_LONG</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the converted C/C++ value.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipMalloc">
void *<code class="sig-name descname">sipMalloc</code><span class="sig-paren">(</span>size_t <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipMalloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This allocates an area of memory on the heap using the Python
<code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code> function.  The memory is freed by calling
<a class="reference internal" href="#c.sipFree" title="sipFree"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipFree()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nbytes</strong> – the number of bytes to allocate.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the memory address.  If there was an error then <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned
and a Python exception raised.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipMapIntToClass">
<a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType">sipWrapperType</a> *<code class="sig-name descname">sipMapIntToClass</code><span class="sig-paren">(</span>int <em>type</em>, <em class="property">const</em> <a class="reference internal" href="#c.sipIntTypeClassMap" title="sipIntTypeClassMap">sipIntTypeClassMap</a> *<em>map</em>, int <em>maplen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipMapIntToClass" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8.</span></p>
</div>
<p>This can be used in <a class="reference internal" href="directives.html#std-directive-ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> code as a
convenient way of converting integer based RTTI to the corresponding
<a class="reference internal" href="#ref-type-objects"><span class="std std-ref">generated type object</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> – the integer RTTI.</p></li>
<li><p><strong>map</strong> – the table of known RTTI and the corresponding type objects (see
<a class="reference internal" href="#c.sipIntTypeClassMap" title="sipIntTypeClassMap"><code class="xref c c-type docutils literal notranslate"><span class="pre">sipIntTypeClassMap</span></code></a>).  The entries in the table must be sorted
in ascending order of RTTI.</p></li>
<li><p><strong>maplen</strong> – the number of entries in the table.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the corresponding type object, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if <em>type</em> wasn’t in <em>map</em>.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipMapStringToClass">
<a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType">sipWrapperType</a> *<code class="sig-name descname">sipMapStringToClass</code><span class="sig-paren">(</span>char *<em>type</em>, <em class="property">const</em> <a class="reference internal" href="#c.sipStringTypeClassMap" title="sipStringTypeClassMap">sipStringTypeClassMap</a> *<em>map</em>, int <em>maplen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipMapStringToClass" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8.</span></p>
</div>
<p>This can be used in <a class="reference internal" href="directives.html#std-directive-ConvertToSubClassCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToSubClassCode</span></code></a> code as a
convenient way of converting <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> terminated string based RTTI to the
corresponding <a class="reference internal" href="#ref-type-objects"><span class="std std-ref">generated type object</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> – the string RTTI.</p></li>
<li><p><strong>map</strong> – the table of known RTTI and the corresponding type objects (see
<a class="reference internal" href="#c.sipStringTypeClassMap" title="sipStringTypeClassMap"><code class="xref c c-type docutils literal notranslate"><span class="pre">sipStringTypeClassMap</span></code></a>).  The entries in the table must be
sorted in ascending order of RTTI.</p></li>
<li><p><strong>maplen</strong> – the number of entries in the table.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the corresponding type object, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if <em>type</em> wasn’t in <em>map</em>.</p>
</dd>
</dl>
</dd></dl>

<dl class="c type">
<dt id="c.sipMethodDef">
<em class="property">type </em><code class="sig-name descname">sipMethodDef</code><a class="headerlink" href="#c.sipMethodDef" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This C structure is used with <a class="reference internal" href="#c.sipGetMethod" title="sipGetMethod"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipGetMethod()</span></code></a> and
<a class="reference internal" href="#c.sipFromMethod" title="sipFromMethod"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipFromMethod()</span></code></a> and encapsulates the components parts of a Python
method.  The structure elements are as follows.</p>
<dl class="c member">
<dt id="c.sipMethodDef.pm_function">
PyObject *<code class="sig-name descname">pm_function</code><a class="headerlink" href="#c.sipMethodDef.pm_function" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function that implements the method.</p>
</dd></dl>

<dl class="c member">
<dt id="c.sipMethodDef.pm_self">
PyObject *<code class="sig-name descname">pm_self</code><a class="headerlink" href="#c.sipMethodDef.pm_self" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The bound object.</p>
</dd></dl>

<dl class="c member">
<dt id="c.sipMethodDef.pm_class">
PyObject *<code class="sig-name descname">pm_class</code><a class="headerlink" href="#c.sipMethodDef.pm_class" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The class.  (Python v2 only.)</p>
</dd></dl>

</dd></dl>

<dl class="c function">
<dt id="c.sipSetNewUserTypeHandler">
sipNewUserTypeFunc <code class="sig-name descname">sipSetNewUserTypeHandler</code><span class="sig-paren">(</span><em class="property">const</em> sipTypeDef *<em>td</em>, sipNewUserTypeFunc <em>handler</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipSetNewUserTypeHandler" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>The allows a function to be specified that is called whenever a user
defined sub-class of a C/C++ type is created (i.e. one implemented in
Python).  It is normalled called from a module’s
<a class="reference internal" href="directives.html#std-directive-PostInitialisationCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%PostInitialisationCode</span></code></a>.  It is provided as an alternative to
providing a meta-type when the limited Python API is enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>td</strong> – the <a class="reference internal" href="#ref-type-objects"><span class="std std-ref">generated type object</span></a> corresponding to
the C/C++ type.</p></li>
<li><p><strong>handler</strong> – the function that is called whenever a user defined sub-class of the
type is created.  The function takes a single argument which is the
<a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType"><code class="xref c c-type docutils literal notranslate"><span class="pre">sipWrapperType</span></code></a> of the user defined class.  It returns an
<code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> which is 0 if there was no error.  A Python exception is
raised and -1 returned if there was an error.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the previously installed handler.  This allows handlers to be chained.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipParseResult">
int <code class="sig-name descname">sipParseResult</code><span class="sig-paren">(</span>int *<em>iserr</em>, PyObject *<em>method</em>, PyObject *<em>result</em>, <em class="property">const</em> char *<em>format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.sipParseResult" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This converts a Python object (usually returned by a method) to C/C++ based
on a format string and associated values in a similar way to the Python
<code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iserr</strong> – if this is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the location it points to is set to a
non-zero value if there was an error.</p></li>
<li><p><strong>method</strong> – the Python method that returned <em>result</em>.</p></li>
<li><p><strong>result</strong> – the Python object returned by <em>method</em>.</p></li>
<li><p><strong>format</strong> – the format string.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 if there was no error.  Otherwise a negative value is returned, and
an exception raised.</p>
</dd>
</dl>
<p>This is normally called by handwritten code specified with the
<a class="reference internal" href="directives.html#std-directive-VirtualCatcherCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%VirtualCatcherCode</span></code></a> directive with <em>method</em> being the supplied
<code class="docutils literal notranslate"><span class="pre">sipMethod</span></code> and <em>result</em> being the value returned by
<a class="reference internal" href="#c.sipCallMethod" title="sipCallMethod"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipCallMethod()</span></code></a>.</p>
<p>If <em>format</em> begins and ends with parentheses then <em>result</em> must be a Python
tuple and the rest of <em>format</em> is applied to the tuple contents.</p>
<p>In the following description the first letter is the format character, the
entry in parentheses is the Python object type that the format character
will convert, and the entry in brackets are the types of the C/C++ values
to be passed.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ae</span></code> (object) [char *]</dt><dd><p>Convert a Python string-like object of length 1 to a C/C++ <code class="docutils literal notranslate"><span class="pre">char</span></code>
according to the encoding <code class="docutils literal notranslate"><span class="pre">e</span></code>.  <code class="docutils literal notranslate"><span class="pre">e</span></code> can either be <code class="docutils literal notranslate"><span class="pre">A</span></code> for ASCII,
<code class="docutils literal notranslate"><span class="pre">L</span></code> for Latin-1, or <code class="docutils literal notranslate"><span class="pre">8</span></code> for UTF-8.  For Python v2 the object may be
either a string or a unicode object that can be encoded.  For Python v3
the object may either be a bytes object or a string object that can be
encoded.  An object that supports the buffer protocol may also be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code> (integer) [bool *]</dt><dd><p>Convert a Python integer to a C/C++ <code class="docutils literal notranslate"><span class="pre">bool</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code> (string/bytes) [char *]</dt><dd><p>Convert a Python v2 string object or a Python v3 bytes object of length
1 to a C/C++ <code class="docutils literal notranslate"><span class="pre">char</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d</span></code> (float) [double *]</dt><dd><p>Convert a Python floating point number to a C/C++ <code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e</span></code> (integer) [enum *]</dt><dd><p>Convert a Python integer to an anonymous C/C++ <code class="docutils literal notranslate"><span class="pre">enum</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code> (float) [float *]</dt><dd><p>Convert a Python floating point number to a C/C++ <code class="docutils literal notranslate"><span class="pre">float</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g</span></code> (string/bytes) [const char **, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_SSIZE_T</span></code></a> *]</dt><dd><p>Convert a Python v2 string object or a Python v3 bytes object to a
C/C++ character array and its length.  If the Python object is
<code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then the array and length are <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and zero
respectively.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h</span></code> (integer) [short *]</dt><dd><p>Convert a Python integer to a C/C++ <code class="docutils literal notranslate"><span class="pre">short</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i</span></code> (integer) [int *]</dt><dd><p>Convert a Python integer to a C/C++ <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">l</span></code> (long) [long *]</dt><dd><p>Convert a Python long to a C/C++ <code class="docutils literal notranslate"><span class="pre">long</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">m</span></code> (long) [unsigned long *]</dt><dd><p>Convert a Python long to a C/C++ <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code> (long) [long long *]</dt><dd><p>Convert a Python long to a C/C++ <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">o</span></code> (long) [unsigned long long *]</dt><dd><p>Convert a Python long to a C/C++ <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code> (string/bytes) [const char **]</dt><dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <code class="docutils literal notranslate"><span class="pre">B</span></code> instead.</p>
</div>
<p>Convert a Python v2 string object or a Python v3 bytes object to a
C/C++ <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> terminated string.  If the Python object is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>
then the string is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">t</span></code> (long) [unsigned short *]</dt><dd><p>Convert a Python long to a C/C++ <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u</span></code> (long) [unsigned int *]</dt><dd><p>Convert a Python long to a C/C++ <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">w</span></code> (unicode/string) [wchar_t *]</dt><dd><p>Convert a Python v2 string or unicode object or a Python v3 string
object of length 1 to a C/C++ wide character.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code> (unicode/string) [wchar_t **]</dt><dd><p>Convert a Python v2 string or unicode object or a Python v3 string
object to a C/C++ <code class="docutils literal notranslate"><span class="pre">L'\0'</span></code> terminated wide character string.  If the
Python object is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then the string is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Ae</span></code> (object) [int, const char **]</dt><dd><p>Convert a Python string-like object to a C/C++ <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> terminated
string according to the encoding <code class="docutils literal notranslate"><span class="pre">e</span></code>.  <code class="docutils literal notranslate"><span class="pre">e</span></code> can either be <code class="docutils literal notranslate"><span class="pre">A</span></code> for
ASCII, <code class="docutils literal notranslate"><span class="pre">L</span></code> for Latin-1, or <code class="docutils literal notranslate"><span class="pre">8</span></code> for UTF-8.  If the Python object is
<code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then the string is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  The integer uniquely
identifies the object in the context defined by the <code class="docutils literal notranslate"><span class="pre">S</span></code> format
character and allows an extra reference to the object to be kept to
ensure that the string remains valid.  For Python v2 the object may be
either a string or a unicode object that can be encoded.  For Python v3
the object may either be a bytes object or a string object that can be
encoded.  An object that supports the buffer protocol may also be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">B</span></code> (string/bytes) [int, const char **]</dt><dd><p>Convert a Python v2 string object or a Python v3 bytes object to a
C/C++ <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> terminated string.  If the Python object is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>
then the string is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  The integer uniquely identifies the
object in the context defined by the <code class="docutils literal notranslate"><span class="pre">S</span></code> format character and allows
an extra reference to the object to be kept to ensure that the string
remains valid.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Cf</span></code> (wrapped class) [<a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType"><code class="xref c c-type docutils literal notranslate"><span class="pre">sipWrapperType</span></code></a> *, int *, void **]</dt><dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <code class="docutils literal notranslate"><span class="pre">Hf</span></code> instead.</p>
</div>
<p>Convert a Python object to a C structure or a C++ class instance and
return its state as described in <a class="reference internal" href="#c.sipConvertToInstance" title="sipConvertToInstance"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToInstance()</span></code></a>.
<code class="docutils literal notranslate"><span class="pre">f</span></code> is a combination of the following flags encoded as an ASCII
character by adding <code class="docutils literal notranslate"><span class="pre">0</span></code> to the combined value:</p>
<blockquote>
<div><p>0x01 disallows the conversion of <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> to <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
<dl class="simple">
<dt>0x02 implements the <a class="reference internal" href="annotations.html#function-annotation-Factory"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">Factory</span></code></a> and <a class="reference internal" href="annotations.html#function-annotation-TransferBack"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">TransferBack</span></code></a></dt><dd><p>annotations</p>
</dd>
<dt>0x04 suppresses the return of the state of the returned C/C++</dt><dd><p>instance.  Note that the <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span></code> used to return the state is
not passed if this flag is specified.</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Df</span></code> (wrapped instance) [const <code class="xref c c-type docutils literal notranslate"><span class="pre">sipTypeDef</span></code> *, int *, void **]</dt><dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.10.1: </span>Use <code class="docutils literal notranslate"><span class="pre">Hf</span></code> instead.</p>
</div>
<p>Convert a Python object to a C structure, C++ class or mapped type
instance and return its state as described in
<a class="reference internal" href="#c.sipConvertToType" title="sipConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToType()</span></code></a>.  <code class="docutils literal notranslate"><span class="pre">f</span></code> is a combination of the following
flags encoded as an ASCII character by adding <code class="docutils literal notranslate"><span class="pre">0</span></code> to the combined
value:</p>
<blockquote>
<div><p>0x01 disallows the conversion of <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> to <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
<dl class="simple">
<dt>0x02 implements the <a class="reference internal" href="annotations.html#function-annotation-Factory"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">Factory</span></code></a> and <a class="reference internal" href="annotations.html#function-annotation-TransferBack"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">TransferBack</span></code></a></dt><dd><p>annotations</p>
</dd>
<dt>0x04 suppresses the return of the state of the returned C/C++</dt><dd><p>instance.  Note that the <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span></code> used to return the state is
not passed if this flag is specified.</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">E</span></code> (wrapped enum) [PyTypeObject *, enum *]</dt><dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <code class="docutils literal notranslate"><span class="pre">F</span></code> instead.</p>
</div>
<p>Convert a Python named enum type to the corresponding C/C++ <code class="docutils literal notranslate"><span class="pre">enum</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">F</span></code> (wrapped enum) [<code class="xref c c-type docutils literal notranslate"><span class="pre">sipTypeDef</span></code> *, enum *]</dt><dd><p>Convert a Python named enum type to the corresponding C/C++ <code class="docutils literal notranslate"><span class="pre">enum</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">G</span></code> (unicode/string) [wchar_t **, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_SSIZE_T</span></code></a> *]</dt><dd><p>Convert a Python v2 string or unicode object or a Python v3 string
object to a C/C++ wide character array and its length.  If the Python
object is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then the array and length are <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and zero
respectively.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Hf</span></code> (wrapped instance) [const <code class="xref c c-type docutils literal notranslate"><span class="pre">sipTypeDef</span></code> *, int *, void **]</dt><dd><p>Convert a Python object to a C structure, C++ class or mapped type
instance as described in <a class="reference internal" href="#c.sipConvertToType" title="sipConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToType()</span></code></a>.  <code class="docutils literal notranslate"><span class="pre">f</span></code> is a
combination of the following flags encoded as an ASCII character by
adding <code class="docutils literal notranslate"><span class="pre">0</span></code> to the combined value:</p>
<blockquote>
<div><p>0x01 disallows the conversion of <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> to <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
<dl class="simple">
<dt>0x02 implements the <a class="reference internal" href="annotations.html#function-annotation-Factory"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">Factory</span></code></a> and <a class="reference internal" href="annotations.html#function-annotation-TransferBack"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">TransferBack</span></code></a></dt><dd><p>annotations</p>
</dd>
</dl>
<p>0x04 returns a copy of the C/C++ instance.</p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">L</span></code> (integer) [signed char *]</dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.12.</span></p>
</div>
<p>Convert a Python integer to a C/C++ <code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">char</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">M</span></code> (long) [unsigned char *]</dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.12.</span></p>
</div>
<p>Convert a Python long to a C/C++ <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">N</span></code> (object) [PyTypeObject *, PyObject **]</dt><dd><p>A Python object is checked to see if it is a certain type and then
returned without any conversions.  The reference count is incremented.
The Python object may be <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">O</span></code> (object) [PyObject **]</dt><dd><p>A Python object is returned without any conversions.  The reference
count is incremented.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S</span></code> [<a class="reference internal" href="#c.sipSimpleWrapper" title="sipSimpleWrapper"><code class="xref c c-type docutils literal notranslate"><span class="pre">sipSimpleWrapper</span></code></a> *]</dt><dd><p>This format character, if used, must be the first.  It is used with
other format characters to define a context and doesn’t itself convert
an argument.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">T</span></code> (object) [PyTypeObject *, PyObject **]</dt><dd><p>A Python object is checked to see if it is a certain type and then
returned without any conversions.  The reference count is incremented.
The Python object may not be <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">V</span></code> (<a class="reference internal" href="python_api.html#sip.voidptr" title="sip.voidptr"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.voidptr</span></code></a>) [void **]</dt><dd><p>Convert a Python <a class="reference internal" href="python_api.html#sip.voidptr" title="sip.voidptr"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.voidptr</span></code></a> object to a C/C++ <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z</span></code> (object) [const char *, void **]</dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.14.1.</span></p>
</div>
<p>Convert a Python named capsule object to a C/C++ <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Z</span></code> (object) []</dt><dd><p>Check that a Python object is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>.  No value is returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!</span></code> (object) [PyObject **]</dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.14.1.</span></p>
</div>
<p>A Python object is checked to see if it implements the buffer protocol
and then returned without any conversions.  The reference count is
incremented.  The Python object may not be <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">$</span></code> (object) [PyObject **]</dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.14.1.</span></p>
</div>
<p>A Python object is checked to see if it implements the buffer protocol
and then returned without any conversions.  The reference count is
incremented.  The Python object may be <code class="docutils literal notranslate"><span class="pre">Py_None</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">=</span></code> (long) [size_t *]</dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.14.</span></p>
</div>
<p>Convert a Python long to a C/C++ <code class="docutils literal notranslate"><span class="pre">size_t</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipPyTypeDict">
PyObject *<code class="sig-name descname">sipPyTypeDict</code><span class="sig-paren">(</span><em class="property">const</em> PyTypeObject *<em>py_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipPyTypeDict" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This provides access to a Python type object’s <code class="docutils literal notranslate"><span class="pre">tp_dict</span></code> field and is
typically used when the limited Python API is enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>py_type</strong> – the type object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the value of the type object’s <code class="docutils literal notranslate"><span class="pre">tp_dict</span></code> field.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipPyTypeName">
<em class="property">const</em> char *<code class="sig-name descname">sipPyTypeName</code><span class="sig-paren">(</span><em class="property">const</em> PyTypeObject *<em>py_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipPyTypeName" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This provides access to a Python type object’s <code class="docutils literal notranslate"><span class="pre">tp_name</span></code> field and is
typically used when the limited Python API is enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>py_type</strong> – the type object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the value of the type object’s <code class="docutils literal notranslate"><span class="pre">tp_name</span></code> field.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipRegisterAttributeGetter">
int <code class="sig-name descname">sipRegisterAttributeGetter</code><span class="sig-paren">(</span><em class="property">const</em> sipTypeDef *<em>td</em>, sipAttrGetterFunc <em>getter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipRegisterAttributeGetter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This registers a getter that will called just before SIP needs to get an
attribute from a wrapped type’s dictionary for the first time.  The getter
must then populate the type’s dictionary with any lazy attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>td</strong> – the optional <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a> that
determines which types the getter will be called for.</p></li>
<li><p><strong>getter</strong> – the getter function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 if there was no error, otherwise -1 is returned.</p>
</dd>
</dl>
<p>If <em>td</em> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the getter will only be called for types with
that type or that are sub-classed from it.  Otherwise the getter will be
called for all types.</p>
<p>A getter has the following signature.</p>
<p>int getter(const <code class="xref c c-type docutils literal notranslate"><span class="pre">sipTypeDef</span></code> *td, PyObject *dict)</p>
<blockquote>
<div><p><em>td</em> is the generated type definition of the type whose dictionary is
to be populated.</p>
<p><em>dict</em> is the dictionary to be populated.</p>
<p>0 is returned if there was no error, otherwise -1 is returned.</p>
</div></blockquote>
<p>See the section <a class="reference internal" href="using.html#ref-lazy-type-attributes"><span class="std std-ref">Lazy Type Attributes</span></a> for more details.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipRegisterExitNotifier">
int <code class="sig-name descname">sipRegisterExitNotifier</code><span class="sig-paren">(</span>PyMethodDef *<em>md</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipRegisterExitNotifier" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.19.</span></p>
</div>
<p>This registers a C function with Python’s <code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code> module that will
be called when the interpreter terminates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>md</strong> – the data structure that describes the C function to be called.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 if there was no error, otherwise -1 is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipRegisterProxyResolver">
int <code class="sig-name descname">sipRegisterProxyResolver</code><span class="sig-paren">(</span><em class="property">const</em> sipTypeDef *<em>td</em>, sipProxyResolverFunc <em>resolver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipRegisterProxyResolver" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.15.</span></p>
</div>
<p>This registers a resolver that will called just before SIP wraps a C/C++
pointer in a Python object.  The resolver may choose to replace the C/C++
pointer with the address of another object.  Typically this is used to
replace a proxy by the object that is being proxied for.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>td</strong> – the optional <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a> that
determines which type the resolver will be called for.</p></li>
<li><p><strong>resolver</strong> – the resolver function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 if there was no error, otherwise -1 is returned.</p>
</dd>
</dl>
<p>A resolver has the following signature.</p>
<p>void *resolver(void *proxy)</p>
<blockquote>
<div><p><em>proxy</em> is C/C++ pointer that is being wrapped.</p>
<p>The C/C++ pointer that will actually be wrapped is returned.</p>
</div></blockquote>
</dd></dl>

<dl class="c function">
<dt id="c.sipRegisterPyType">
int <code class="sig-name descname">sipRegisterPyType</code><span class="sig-paren">(</span>PyTypeObject *<em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipRegisterPyType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This registers a Python type object that can be used as the meta-type or
super-type of a wrapped C++ type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> – the type object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 if there was no error, otherwise -1 is returned.</p>
</dd>
</dl>
<p>See the section <a class="reference internal" href="using.html#ref-types-metatypes"><span class="std std-ref">Types and Meta-types</span></a> for more details.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipReleaseBufferInfo">
void <code class="sig-name descname">sipReleaseBufferInfo</code><span class="sig-paren">(</span><a class="reference internal" href="#c.sipBufferInfoDef" title="sipBufferInfoDef">sipBufferInfoDef</a> *<em>buffer_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipReleaseBufferInfo" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This releases the buffer information related to a Python object that
implements the buffer protocol that was created with a corresponding call
to <a class="reference internal" href="#c.sipGetBufferInfo" title="sipGetBufferInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipGetBufferInfo()</span></code></a>.  It is similar to
<code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code> and should be used instead of that when the
limited Python API is enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>buffer_info</strong> – the buffer information to release.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipReleaseInstance">
void <code class="sig-name descname">sipReleaseInstance</code><span class="sig-paren">(</span>void *<em>cpp</em>, <a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType">sipWrapperType</a> *<em>type</em>, int <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipReleaseInstance" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipReleaseType" title="sipReleaseType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipReleaseType()</span></code></a> instead.</p>
</div>
<p>This destroys a wrapped C/C++ instance if it was a temporary instance.  It
is called after a call to either <a class="reference internal" href="#c.sipConvertToInstance" title="sipConvertToInstance"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToInstance()</span></code></a> or
<a class="reference internal" href="#c.sipForceConvertToInstance" title="sipForceConvertToInstance"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipForceConvertToInstance()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cpp</strong> – the C/C++ instance.</p></li>
<li><p><strong>type</strong> – the type’s <a class="reference internal" href="#ref-type-objects"><span class="std std-ref">generated type object</span></a>.</p></li>
<li><p><strong>state</strong> – describes the state of the C/C++ instance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipReleaseMappedType">
void <code class="sig-name descname">sipReleaseMappedType</code><span class="sig-paren">(</span>void *<em>cpp</em>, <em class="property">const</em> sipMappedType *<em>mt</em>, int <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipReleaseMappedType" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <a class="reference internal" href="#c.sipReleaseType" title="sipReleaseType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipReleaseType()</span></code></a> instead.</p>
</div>
<p>This destroys a wrapped C/C++ mapped type if it was a temporary instance.
It is called after a call to either <a class="reference internal" href="#c.sipConvertToMappedType" title="sipConvertToMappedType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToMappedType()</span></code></a> or
<a class="reference internal" href="#c.sipForceConvertToMappedType" title="sipForceConvertToMappedType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipForceConvertToMappedType()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cpp</strong> – the C/C++ instance.</p></li>
<li><p><strong>mt</strong> – the opaque structure returned by <a class="reference internal" href="#c.sipFindMappedType" title="sipFindMappedType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipFindMappedType()</span></code></a>.</p></li>
<li><p><strong>state</strong> – describes the state of the C/C++ instance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipReleaseType">
void <code class="sig-name descname">sipReleaseType</code><span class="sig-paren">(</span>void *<em>cpp</em>, <em class="property">const</em> sipTypeDef *<em>td</em>, int <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipReleaseType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This destroys a wrapped C/C++ or mapped type instance if it was a temporary
instance.  It is called after a call to either <a class="reference internal" href="#c.sipConvertToType" title="sipConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToType()</span></code></a>
or <a class="reference internal" href="#c.sipForceConvertToType" title="sipForceConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipForceConvertToType()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cpp</strong> – the C/C++ instance.</p></li>
<li><p><strong>td</strong> – the type’s <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>.</p></li>
<li><p><strong>state</strong> – describes the state of the C/C++ instance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipResolveTypedef">
<em class="property">const</em> char *<code class="sig-name descname">sipResolveTypedef</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipResolveTypedef" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This returns the value of a C/C++ typedef.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – the name of the typedef.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the value of the typedef or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there was no such typedef.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipSetDestroyOnExit">
void <code class="sig-name descname">sipSetDestroyOnExit</code><span class="sig-paren">(</span>int <em>destroy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipSetDestroyOnExit" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.14.7.</span></p>
</div>
<p>When the Python interpreter exits it garbage collects those objects that it
can.  This means that any corresponding C++ instances and C structures
owned by Python are destroyed.  Unfortunately this happens in an
unpredictable order and so can cause memory faults within the wrapped
library.  Calling this function with a value of zero disables the automatic
destruction of C++ instances and C structures.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>destroy</strong> – non-zero if all C++ instances and C structures owned by Python should
be destroyed when the interpreter exits.  This is the default.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipSetTypeUserData">
void <code class="sig-name descname">sipSetTypeUserData</code><span class="sig-paren">(</span><a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType">sipWrapperType</a> *<em>type</em>, void *<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipSetTypeUserData" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>Each generated type corresponding to a wrapped C/C++ type, or a user
sub-class of such a type, contains a pointer for the use of handwritten
code.  This sets the value of that pointer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> – the type object.</p></li>
<li><p><strong>data</strong> – the type-specific pointer.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipSetUserObject">
void <code class="sig-name descname">sipSetUserObject</code><span class="sig-paren">(</span><a class="reference internal" href="#c.sipSimpleWrapper" title="sipSimpleWrapper">sipSimpleWrapper</a> *<em>obj</em>, PyObject *<em>user</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipSetUserObject" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>Each wrapped object can contain a reference to a single Python object that
can be used for any purpose by handwritten code and will automatically be
garbage collected at the appropriate time.  This sets that object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the wrapped object.</p></li>
<li><p><strong>user</strong> – a borrowed reference to the user object.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c type">
<dt id="c.sipSimpleWrapper">
<em class="property">type </em><code class="sig-name descname">sipSimpleWrapper</code><a class="headerlink" href="#c.sipSimpleWrapper" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a C structure that represents a Python wrapped instance whose type
is <a class="reference internal" href="python_api.html#sip.simplewrapper" title="sip.simplewrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.simplewrapper</span></code></a>.  It is an extension of the <code class="docutils literal notranslate"><span class="pre">PyObject</span></code>
structure and so may be safely cast to it.</p>
<p>When the limited Python API is enabled and Python v3.2 or later is being
used then it is only available as an opaque (i.e. incomplete) type and the
following members are not available.</p>
<dl class="c member">
<dt id="c.sipSimpleWrapper.data">
void *<code class="sig-name descname">data</code><a class="headerlink" href="#c.sipSimpleWrapper.data" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is initialised to the address of the C/C++ instance.  If an access
function is subsequently provided then it may be used for any purpose
by the access function.</p>
</dd></dl>

<dl class="c member">
<dt id="c.sipSimpleWrapper.access_func">
sipAccessFunc <code class="sig-name descname">access_func</code><a class="headerlink" href="#c.sipSimpleWrapper.access_func" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is the address of an optional access function that is called, with
a pointer to this structure as its first argument.  If its second
argument is <code class="docutils literal notranslate"><span class="pre">UnguardedPointer</span></code> then it returns the address of the
C/C++ instance, even if it is known that its value is no longer valid.
If the second argument is <code class="docutils literal notranslate"><span class="pre">GuardedPointer</span></code> then it returns the
address of the C++ instance or <code class="docutils literal notranslate"><span class="pre">0</span></code> if it is known to be invalid.  If
the second argument is <code class="docutils literal notranslate"><span class="pre">ReleaseGuard</span></code> then the structure is being
deallocated and any dynamic resources used by the access function
should be released.  If there is no access function then the
<a class="reference internal" href="#c.sipSimpleWrapper.data" title="sipSimpleWrapper.data"><code class="xref c c-member docutils literal notranslate"><span class="pre">sipSimpleWrapper.data</span></code></a> is used as the address of the C/C++
instance.  Typically a custom meta-type is used to set an access method
after the Python object has been created.</p>
</dd></dl>

<dl class="c member">
<dt id="c.sipSimpleWrapper.user">
PyObject *<code class="sig-name descname">user</code><a class="headerlink" href="#c.sipSimpleWrapper.user" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This can be used for any purpose by handwritten code and will
automatically be garbage collected at the appropriate time.</p>
</dd></dl>

</dd></dl>

<dl class="c var">
<dt id="c.sipSimpleWrapper_Type">
PyTypeObject *<code class="sig-name descname">sipSimpleWrapper_Type</code><a class="headerlink" href="#c.sipSimpleWrapper_Type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is the type of a <a class="reference internal" href="#c.sipSimpleWrapper" title="sipSimpleWrapper"><code class="xref c c-type docutils literal notranslate"><span class="pre">sipSimpleWrapper</span></code></a> structure and is the C
implementation of <a class="reference internal" href="python_api.html#sip.simplewrapper" title="sip.simplewrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.simplewrapper</span></code></a>.  It may be safely cast to
<a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType"><code class="xref c c-type docutils literal notranslate"><span class="pre">sipWrapperType</span></code></a>.</p>
<p>When the limited Python API is enabled and Python v3.2 or later is being
used then it is only available as an opaque (i.e. incomplete) type.</p>
</dd></dl>

<dl class="c type">
<dt id="c.sipStringTypeClassMap">
<em class="property">type </em><code class="sig-name descname">sipStringTypeClassMap</code><a class="headerlink" href="#c.sipStringTypeClassMap" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8.</span></p>
</div>
<p>This C structure is used with <a class="reference internal" href="#c.sipMapStringToClass" title="sipMapStringToClass"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipMapStringToClass()</span></code></a> to define a
mapping between <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> terminated string based RTTI and
<a class="reference internal" href="#ref-type-objects"><span class="std std-ref">Generated Type Objects</span></a>.  The structure elements are as follows.</p>
<dl class="c member">
<dt id="c.sipStringTypeClassMap.typeString">
char *<code class="sig-name descname">typeString</code><a class="headerlink" href="#c.sipStringTypeClassMap.typeString" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> terminated string RTTI.</p>
</dd></dl>

<dl class="c member">
<dt>
<code class="sig-name descname">sipWrapperType **pyType.</code></dt>
<dd><p>A pointer to the corresponding generated type object.</p>
</dd></dl>

</dd></dl>

<dl class="c type">
<dt id="c.sipTimeDef">
<em class="property">type </em><code class="sig-name descname">sipTimeDef</code><a class="headerlink" href="#c.sipTimeDef" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This C structure is used with <a class="reference internal" href="#c.sipGetTime" title="sipGetTime"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipGetTime()</span></code></a>,
<a class="reference internal" href="#c.sipFromTime" title="sipFromTime"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipFromTime()</span></code></a>, <a class="reference internal" href="#c.sipGetDateTime" title="sipGetDateTime"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipGetDateTime()</span></code></a> and
<a class="reference internal" href="#c.sipFromDateTime" title="sipFromDateTime"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipFromDateTime()</span></code></a> and encapsulates the components parts of a
Python time.  The structure elements are as follows.</p>
<dl class="c member">
<dt id="c.sipTimeDef.pt_hour">
int <code class="sig-name descname">pt_hour</code><a class="headerlink" href="#c.sipTimeDef.pt_hour" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The hour (0-23).</p>
</dd></dl>

<dl class="c member">
<dt id="c.sipTimeDef.pt_minute">
int <code class="sig-name descname">pt_minute</code><a class="headerlink" href="#c.sipTimeDef.pt_minute" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The minute (0-59).</p>
</dd></dl>

<dl class="c member">
<dt id="c.sipTimeDef.pt_second">
int <code class="sig-name descname">pt_second</code><a class="headerlink" href="#c.sipTimeDef.pt_second" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The second (0-59).</p>
</dd></dl>

<dl class="c member">
<dt id="c.sipTimeDef.pt_microsecond">
int <code class="sig-name descname">pt_microsecond</code><a class="headerlink" href="#c.sipTimeDef.pt_microsecond" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The microsecond (0-999999).</p>
</dd></dl>

</dd></dl>

<dl class="c function">
<dt id="c.sipTransferBack">
void <code class="sig-name descname">sipTransferBack</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipTransferBack" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This transfers ownership of a Python wrapped instance to Python (see
<a class="reference internal" href="using.html#ref-object-ownership"><span class="std std-ref">Ownership of Objects</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the wrapped instance.</p></li>
</ul>
</dd>
</dl>
<p>In addition, any association of the instance with regard to the cyclic
garbage collector with another instance is removed.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipTransferBreak">
void <code class="sig-name descname">sipTransferBreak</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipTransferBreak" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Any association of a Python wrapped instance with regard to the cyclic
garbage collector with another instance is removed.  Ownership of the
instance should be with C++.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the wrapped instance.</p></li>
</ul>
</dd>
</dl>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.14: </span>Use the following instead:</p>
<blockquote>
<div><p>sipTransferTo(obj, NULL);</p>
</div></blockquote>
</div>
</dd></dl>

<dl class="c function">
<dt id="c.sipTransferTo">
void <code class="sig-name descname">sipTransferTo</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, PyObject *<em>owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipTransferTo" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This transfers ownership of a Python wrapped instance to C++ (see
<a class="reference internal" href="using.html#ref-object-ownership"><span class="std std-ref">Ownership of Objects</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the wrapped instance.</p></li>
<li><p><strong>owner</strong> – an optional wrapped instance that <em>obj</em> becomes associated with with
regard to the cyclic garbage collector.  If <em>owner</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then no
such association is made.  If <em>owner</em> is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then <em>obj</em> is
given an extra reference which is removed when the C++ instance’s
destructor is called.  If <em>owner</em> is the same value as <em>obj</em> then any
reference cycles involving <em>obj</em> can never be detected or broken by the
cyclic garbage collector.  Responsibility for calling the C++
instance’s destructor is always transfered to C++.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipTypeAsPyTypeObject">
PyTypeObject *<code class="sig-name descname">sipTypeAsPyTypeObject</code><span class="sig-paren">(</span><em class="property">const</em> sipTypeDef *<em>td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipTypeAsPyTypeObject" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This returns a pointer to the Python type object that SIP creates for a
<a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>td</strong> – the type structure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Python type object.  If the type structure refers to a mapped type
then <code class="docutils literal notranslate"><span class="pre">NULL</span></code> will be returned.</p>
</dd>
</dl>
<p>If the type structure refers to a C structure or C++ class then the
Python type object may be safely cast to a <a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType"><code class="xref c c-type docutils literal notranslate"><span class="pre">sipWrapperType</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipTypeFromPyTypeObject">
<em class="property">const</em> sipTypeDef *<code class="sig-name descname">sipTypeFromPyTypeObject</code><span class="sig-paren">(</span>PyTypeObject *<em>py_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipTypeFromPyTypeObject" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This returns the <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a> for
a Python type object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>py_type</strong> – the Python type object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the type structure or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the Python type object doesn’t
correspond to a type structure.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipTypeIsClass">
int <code class="sig-name descname">sipTypeIsClass</code><span class="sig-paren">(</span>sipTypeDef *<em>td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipTypeIsClass" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This checks if a <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>
refers to a C structure or C++ class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>td</strong> – the type structure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the type structure refers to a structure or class.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipTypeIsEnum">
int <code class="sig-name descname">sipTypeIsEnum</code><span class="sig-paren">(</span>sipTypeDef *<em>td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipTypeIsEnum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This checks if a <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>
refers to a C-style named enum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>td</strong> – the type structure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the type structure refers to a C-style named enum.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipTypeIsMapped">
int <code class="sig-name descname">sipTypeIsMapped</code><span class="sig-paren">(</span>sipTypeDef *<em>td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipTypeIsMapped" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This checks if a <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>
refers to a mapped type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>td</strong> – the type structure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the type structure refers to a mapped type.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipTypeIsNamespace">
int <code class="sig-name descname">sipTypeIsNamespace</code><span class="sig-paren">(</span>sipTypeDef *<em>td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipTypeIsNamespace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This checks if a <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>
refers to a C++ namespace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>td</strong> – the type structure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the type structure refers to a namespace.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipTypeIsScopedEnum">
int <code class="sig-name descname">sipTypeIsScopedEnum</code><span class="sig-paren">(</span>sipTypeDef *<em>td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipTypeIsScopedEnum" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.4.</span></p>
</div>
<p>This checks if a <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>
refers to a C++11 scoped enum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>td</strong> – the type structure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the type structure refers to a C++11 scoped enum.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipTypeName">
<em class="property">const</em> char *<code class="sig-name descname">sipTypeName</code><span class="sig-paren">(</span><em class="property">const</em> sipTypeDef *<em>td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipTypeName" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This returns the C/C++ name of a wrapped type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>td</strong> – the type’s <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the name of the C/C++ type.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipTypeScope">
<em class="property">const</em> sipTypeDef *<code class="sig-name descname">sipTypeScope</code><span class="sig-paren">(</span><em class="property">const</em> sipTypeDef *<em>td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipTypeScope" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This returns the <a class="reference internal" href="#ref-type-structures"><span class="std std-ref">generated type structure</span></a> of
the enclosing scope of another generated type structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>td</strong> – the type structure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the type structure of the scope or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the type has no scope.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipUnicodeData">
void *<code class="sig-name descname">sipUnicodeData</code><span class="sig-paren">(</span>PyObject *<em>obj</em>, int *<em>char_size</em>, <a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> *<em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipUnicodeData" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This returns information about the contents of a Python unicode object.</p>
<p>This is only supported for Python v3.3 and later.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the unicode object.</p></li>
<li><p><strong>char_size</strong> – a pointer which will be updated with the number of bytes (either 1, 2
or 4) used to store a character.  If there was an error then this will
be a negative value.</p></li>
<li><p><strong>len</strong> – a pointer which will be updated with the number of characters (not
bytes) in the unicode object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the address of the buffer where the characters are stored.  It will be
undefined if the returned character size is a negative value.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipUnicodeNew">
PyObject *<code class="sig-name descname">sipUnicodeNew</code><span class="sig-paren">(</span><a class="reference internal" href="#c.SIP_SSIZE_T" title="SIP_SSIZE_T">SIP_SSIZE_T</a> <em>len</em>, unsigned <em>maxchar</em>, int *<em>kind</em>, void **<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipUnicodeNew" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This creates a Python unicode object that will hold a set number of
characters, each character being of a certain size.</p>
<p>This is only supported for Python v3.3 and later.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>len</strong> – the number of characters.</p></li>
<li><p><strong>maxchar</strong> – the largest code point that will be placed in the object.</p></li>
<li><p><strong>kind</strong> – a pointer which will be updated with a value that represents the number
of bytes (either 1, 2 or 4) used to store a character.</p></li>
<li><p><strong>data</strong> – a pointer which will be updated with the address of the buffer where
the characters will be stored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the unicode object or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there was an error.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipUnicodeWrite">
void <code class="sig-name descname">sipUnicodeWrite</code><span class="sig-paren">(</span>int <em>kind</em>, void *<em>data</em>, int <em>index</em>, unsigned <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipUnicodeWrite" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<p>This updates the buffer of a Python unicode object with a character at a
particular position.</p>
<p>This is only supported for Python v3.3 and later.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kind</strong> – the value that represents the number of bytes (either 1, 2 or 4) used
to store a character.</p></li>
<li><p><strong>data</strong> – the address of the buffer where the characters are stored.</p></li>
<li><p><strong>index</strong> – the character (not byte) index of the character to be updated.</p></li>
<li><p><strong>value</strong> – the value of the new character.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt id="c.sipVisitWrappers">
void <code class="sig-name descname">sipVisitWrappers</code><span class="sig-paren">(</span>sipWrapperVisitorFunc <em>visitor</em>, void *<em>closure</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipVisitWrappers" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.19.</span></p>
</div>
<p>This calls a visitor function for every wrapper object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>visitor</strong> – the visitor function.</p></li>
<li><p><strong>closure</strong> – a pointer that is passed to the visitor.</p></li>
</ul>
</dd>
</dl>
<p>A visitor has the following signature.</p>
<p>void visitor(sipSimpleWrapper *obj, void *closure)</p>
<blockquote>
<div><p><em>obj</em> is the wrapped object being visited.</p>
<p><em>closure</em> is the pointer passed to <a class="reference internal" href="#c.sipVisitWrappers" title="sipVisitWrappers"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipVisitWrappers()</span></code></a>.</p>
</div></blockquote>
</dd></dl>

<dl class="c var">
<dt id="c.sipVoidPtr_Type">
PyTypeObject *<code class="sig-name descname">sipVoidPtr_Type</code><a class="headerlink" href="#c.sipVoidPtr_Type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is the type of a <code class="docutils literal notranslate"><span class="pre">PyObject</span></code> structure that is used to wrap a
<code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>.</p>
</dd></dl>

<dl class="c type">
<dt id="c.sipWrapper">
<em class="property">type </em><code class="sig-name descname">sipWrapper</code><a class="headerlink" href="#c.sipWrapper" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a C structure that represents a Python wrapped instance whose type
is <a class="reference internal" href="python_api.html#sip.wrapper" title="sip.wrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.wrapper</span></code></a>.  It is an extension of the
<a class="reference internal" href="#c.sipSimpleWrapper" title="sipSimpleWrapper"><code class="xref c c-type docutils literal notranslate"><span class="pre">sipSimpleWrapper</span></code></a> and <code class="docutils literal notranslate"><span class="pre">PyObject</span></code> structures and so may be safely
cast to both.</p>
<p>When the limited Python API is enabled and Python v3.2 or later is being
used then it is only available as an opaque (i.e. incomplete) type.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipWrapper_Check">
int <code class="sig-name descname">sipWrapper_Check</code><span class="sig-paren">(</span>PyObject *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipWrapper_Check" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use the following instead:</p>
<blockquote>
<div><p>PyObject_TypeCheck(obj, sipWrapper_Type)</p>
</div></blockquote>
</div>
<p>This checks if a Python object is a wrapped instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – the Python object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a non-zero value if the Python object is a wrapped instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="c var">
<dt id="c.sipWrapper_Type">
PyTypeObject *<code class="sig-name descname">sipWrapper_Type</code><a class="headerlink" href="#c.sipWrapper_Type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is the type of a <a class="reference internal" href="#c.sipWrapper" title="sipWrapper"><code class="xref c c-type docutils literal notranslate"><span class="pre">sipWrapper</span></code></a> structure and is the C
implementation of <a class="reference internal" href="python_api.html#sip.wrapper" title="sip.wrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.wrapper</span></code></a>.  It may be safely cast to
<a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType"><code class="xref c c-type docutils literal notranslate"><span class="pre">sipWrapperType</span></code></a>.</p>
</dd></dl>

<dl class="c type">
<dt id="c.sipWrapperType">
<em class="property">type </em><code class="sig-name descname">sipWrapperType</code><a class="headerlink" href="#c.sipWrapperType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a C structure that represents a SIP generated type object.  It is
an extension of the <code class="docutils literal notranslate"><span class="pre">PyTypeObject</span></code> structure (which is itself an
extension of the <code class="docutils literal notranslate"><span class="pre">PyObject</span></code> structure) and so may be safely cast to
<code class="docutils literal notranslate"><span class="pre">PyTypeObject</span></code> (and <code class="docutils literal notranslate"><span class="pre">PyObject</span></code>).</p>
<p>When the limited Python API is enabled and Python v3.2 or later is being
used then it is only available as an opaque (i.e. incomplete) type.</p>
</dd></dl>

<dl class="c var">
<dt id="c.sipWrapperType_Type">
PyTypeObject *<code class="sig-name descname">sipWrapperType_Type</code><a class="headerlink" href="#c.sipWrapperType_Type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is the type of a <a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType"><code class="xref c c-type docutils literal notranslate"><span class="pre">sipWrapperType</span></code></a> structure and is the C
implementation of <a class="reference internal" href="python_api.html#sip.wrappertype" title="sip.wrappertype"><code class="xref py py-class docutils literal notranslate"><span class="pre">sip.wrappertype</span></code></a>.</p>
</dd></dl>

<div class="section" id="event-handlers">
<h2>Event Handlers<a class="headerlink" href="#event-handlers" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.3.</span></p>
</div>
<p>The <a class="reference internal" href="python_api.html#module-sip" title="sip"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sip</span></code></a> module will trigger a number of events.  Handwritten code can
supply handlers for these events to allow it to perform additional actions.
Each event has a type, described by the <a class="reference internal" href="#_CPPv412sipEventType" title="sipEventType"><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">sipEventType</span></code></a> enum.  An
event handler is registered using <a class="reference internal" href="#c.sipRegisterEventHandler" title="sipRegisterEventHandler"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipRegisterEventHandler()</span></code></a>.  The
signature of an event handler is specific to the event type.</p>
<dl class="cpp enum">
<dt id="_CPPv412sipEventType">
<span id="_CPPv312sipEventType"></span><span id="_CPPv212sipEventType"></span><em class="property">enum </em><code class="sig-name descname">sipEventType</code><a class="headerlink" href="#_CPPv412sipEventType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is the enum that defines the different event types.</p>
</dd></dl>

<dl class="c function">
<dt id="c.sipRegisterEventHandler">
int <code class="sig-name descname">sipRegisterEventHandler</code><span class="sig-paren">(</span>sipEventType <em>type</em>, <em class="property">const</em> sipTypeDef *<em>td</em>, void *<em>handler</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sipRegisterEventHandler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This registers an event handler which will be called whenever an event is
triggered.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> – the event type for which the handler is registered.</p></li>
<li><p><strong>td</strong> – the generated type structure - the handler will only be invoked for
Python object corresponding to this type or a sub-type.</p></li>
<li><p><strong>handler</strong> – the handler that is called when the event is triggered.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 if there was no error, otherwise -1 is returned (and a Python
exception is raised).</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="generated-type-structures">
<span id="ref-type-structures"></span><h2>Generated Type Structures<a class="headerlink" href="#generated-type-structures" title="Permalink to this headline">¶</a></h2>
<p>SIP generates an opaque type structure for each C structure, C++ class, C++
namespace, named enum or mapped type being wrapped.  These are
<code class="xref c c-type docutils literal notranslate"><span class="pre">sipTypeDef</span></code> structures and are used extensively by the SIP API.</p>
<p>The names of these structure are prefixed by <code class="docutils literal notranslate"><span class="pre">sipType_</span></code>.</p>
<p>For those structures that correspond to C structures, C++ classes, C++
namespaces or named enums the remaining part of the name is the fully
qualified name of the structure, class, namespace or enum name.  Any <code class="docutils literal notranslate"><span class="pre">::</span></code>
scope separators are replaced by an underscore.  For example, the type object
for class <code class="docutils literal notranslate"><span class="pre">Klass</span></code> is <code class="docutils literal notranslate"><span class="pre">sipType_Klass</span></code>.</p>
<p>For those structure that correspond to mapped types the remaining part of the
name is generated by SIP.  The only way for handwritten code to obtain a
pointer to a structure for a mapped type is to use <a class="reference internal" href="#c.sipFindType" title="sipFindType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipFindType()</span></code></a>.</p>
<p>The type structures of all imported types explicitly used by a module are
available to handwritten code.</p>
</div>
<div class="section" id="generated-type-objects">
<span id="ref-type-objects"></span><h2>Generated Type Objects<a class="headerlink" href="#generated-type-objects" title="Permalink to this headline">¶</a></h2>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use the corresponding generated type structure (see
<a class="reference internal" href="#ref-type-structures"><span class="std std-ref">Generated Type Structures</span></a>) and <a class="reference internal" href="#c.sipTypeAsPyTypeObject" title="sipTypeAsPyTypeObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTypeAsPyTypeObject()</span></code></a> instead.</p>
</div>
<p>SIP generates a <a class="reference internal" href="#c.sipWrapperType" title="sipWrapperType"><code class="xref c c-type docutils literal notranslate"><span class="pre">sipWrapperType</span></code></a> type object for each C structure or
C++ class being wrapped.</p>
<p>These objects are named with the structure or class name prefixed by
<code class="docutils literal notranslate"><span class="pre">sipClass_</span></code>.  For example, the type object for class <code class="docutils literal notranslate"><span class="pre">Klass</span></code> is
<code class="docutils literal notranslate"><span class="pre">sipClass_Klass</span></code>.</p>
</div>
<div class="section" id="generated-named-enum-type-objects">
<span id="ref-enum-type-objects"></span><h2>Generated Named Enum Type Objects<a class="headerlink" href="#generated-named-enum-type-objects" title="Permalink to this headline">¶</a></h2>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use the corresponding generated type structure (see
<a class="reference internal" href="#ref-type-structures"><span class="std std-ref">Generated Type Structures</span></a>) and <a class="reference internal" href="#c.sipTypeAsPyTypeObject" title="sipTypeAsPyTypeObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipTypeAsPyTypeObject()</span></code></a> instead.</p>
</div>
<p>SIP generates a type object for each named enum being wrapped.  These are
PyTypeObject structures.  (Anonymous enums are wrapped as Python integers.)</p>
<p>These objects are named with the fully qualified enum name (i.e. including any
enclosing scope) prefixed by <code class="docutils literal notranslate"><span class="pre">sipEnum_</span></code>.  For example, the type object for
enum <code class="docutils literal notranslate"><span class="pre">Enum</span></code> defined in class <code class="docutils literal notranslate"><span class="pre">Klass</span></code> is <code class="docutils literal notranslate"><span class="pre">sipEnum_Klass_Enum</span></code>.</p>
</div>
<div class="section" id="generated-derived-classes">
<span id="ref-derived-classes"></span><h2>Generated Derived Classes<a class="headerlink" href="#generated-derived-classes" title="Permalink to this headline">¶</a></h2>
<p>For most C++ classes being wrapped SIP generates a derived class with the same
name prefixed by <code class="docutils literal notranslate"><span class="pre">sip</span></code>.  For example, the derived class for class <code class="docutils literal notranslate"><span class="pre">Klass</span></code>
is <code class="docutils literal notranslate"><span class="pre">sipKlass</span></code>.</p>
<p>If a C++ class doesn’t have any virtual or protected methods in it or any of
it’s super-class hierarchy, or does not emit any Qt signals, then a derived
class is not generated.</p>
<p>Most of the time handwritten code should ignore the derived classes.  The only
exception is that handwritten constructor code specified using the
<a class="reference internal" href="directives.html#std-directive-MethodCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%MethodCode</span></code></a> directive should call the derived class’s constructor
(which has the same C++ signature) rather then the wrapped class’s constructor.</p>
</div>
<div class="section" id="generated-exception-objects">
<span id="ref-exception-objects"></span><h2>Generated Exception Objects<a class="headerlink" href="#generated-exception-objects" title="Permalink to this headline">¶</a></h2>
<p>SIP generates a Python object for each exception defined with the
<a class="reference internal" href="directives.html#std-directive-Exception"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Exception</span></code></a> directive.</p>
<p>These objects are named with the fully qualified exception name (i.e. including
any enclosing scope) prefixed by <code class="docutils literal notranslate"><span class="pre">sipException_</span></code>.  For example, the type
object for enum <code class="docutils literal notranslate"><span class="pre">Except</span></code> defined in class <code class="docutils literal notranslate"><span class="pre">Klass</span></code> is
<code class="docutils literal notranslate"><span class="pre">sipException_Klass_Except</span></code>.</p>
<p>The objects of all imported exceptions are available to handwritten code.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">C API for Handwritten Code</a><ul>
<li><a class="reference internal" href="#event-handlers">Event Handlers</a></li>
<li><a class="reference internal" href="#generated-type-structures">Generated Type Structures</a></li>
<li><a class="reference internal" href="#generated-type-objects">Generated Type Objects</a></li>
<li><a class="reference internal" href="#generated-named-enum-type-objects">Generated Named Enum Type Objects</a></li>
<li><a class="reference internal" href="#generated-derived-classes">Generated Derived Classes</a></li>
<li><a class="reference internal" href="#generated-exception-objects">Generated Exception Objects</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="annotations.html"
                        title="previous chapter">Annotations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="embedding.html"
                        title="next chapter">Using the C API when Embedding</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="embedding.html" title="Using the C API when Embedding"
             >next</a> |</li>
        <li class="right" >
          <a href="annotations.html" title="Annotations"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SIP v4.19.24 Reference Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">C API for Handwritten Code</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020 Riverbank Computing Limited.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.0.
    </div>
  </body>
</html>