
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Directives &#8212; SIP v4.19.22 Reference Guide</title>
    <link rel="stylesheet" href="_static/riverbank.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    
    <link rel="shortcut icon" href="_static/logo_tn.png"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Annotations" href="annotations.html" />
    <link rel="prev" title="SIP Specification Files" href="specification_files.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="annotations.html" title="Annotations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="specification_files.html" title="SIP Specification Files"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SIP v4.19.22 Reference Guide</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="directives">
<h1>Directives<a class="headerlink" href="#directives" title="Permalink to this headline">¶</a></h1>
<p>In this section we describe each of the directives that can be used in
specification files.  All directives begin with <code class="docutils literal notranslate"><span class="pre">%</span></code> as the first
non-whitespace character in a line.</p>
<p>Some directives have arguments or contain blocks of code or documentation.  In
the following descriptions these are shown in <em>italics</em>.  Optional arguments
are enclosed in [<em>brackets</em>].</p>
<p>Some directives are used to specify handwritten code.  Handwritten code must
not define names that start with the prefix <code class="docutils literal notranslate"><span class="pre">sip</span></code>.</p>
<div class="section" id="revised-directive-syntax">
<h2>Revised Directive Syntax<a class="headerlink" href="#revised-directive-syntax" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">New in version 4.12.</span></p>
</div>
<p>The directive syntax used in older versions has some problems:</p>
<ul class="simple">
<li><p>it is inconsistent in places</p></li>
<li><p>it can be problematic to parse</p></li>
<li><p>it is inflexible.</p></li>
</ul>
<p>SIP v4.12 introduced a revised directive syntax that addresses these problems
and deprecates the old syntax.  Support for the old syntax will be removed in
SIP v5.</p>
<p>The revised syntax is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">Directive</span><span class="p">(</span><span class="n">arg</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">%</span><span class="n">Sub</span><span class="o">-</span><span class="n">directive</span>
    <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A directive may have a number of arguments enclosed in parentheses followed by
a number of sub-directives enclosed in braces.  Individual arguments and
sub-directives may be optional.</p>
<p>Arguments may be specified in any order.  If no arguments are specified then
the parentheses can be omitted.  If a directive has only one compulsory
argument then its value may be specified after the directive name and instead
of the parentheses.</p>
<p>Sub-directives may be specified in any order.  If no sub-directives are
specified then the braces can be omitted.</p>
<p>If a directive is used to specify handwritten code then it may not have
sub-directives.  In this case the syntax is:</p>
<pre class="literal-block">%Directive(arg = value, ...)
    <em>code</em>
%End</pre>
<p>Ordinary C/C++ statements may also have sub-directives.  These will also be
enclosed in braces.</p>
<p>The documentation for each directive describes the revised syntax.  The older
syntax should be used if compatibility with versions of SIP prior to v4.12 is
required.</p>
</div>
<div class="section" id="list-of-directives">
<h2>List of Directives<a class="headerlink" href="#list-of-directives" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block" id="std:directive-%AccessCode">%AccessCode
    <em>code</em>
%End</pre>
<p>This sub-directive is used in the declaration of an instance of a wrapped class
or structure, or a pointer to such an instance.  You use it to provide
handwritten code that overrides the default behaviour.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Klass</span><span class="p">;</span>

<span class="n">Klass</span> <span class="o">*</span><span class="n">klassInstance</span>
<span class="p">{</span>
    <span class="o">%</span><span class="n">AccessCode</span>
        <span class="o">//</span> <span class="n">In</span> <span class="n">this</span> <span class="n">contrived</span> <span class="n">example</span> <span class="n">the</span> <span class="n">C</span><span class="o">++</span> <span class="n">library</span> <span class="n">we</span> <span class="n">are</span> <span class="n">wrapping</span>
        <span class="o">//</span> <span class="n">defines</span> <span class="n">klassInstance</span> <span class="k">as</span> <span class="n">Klass</span> <span class="o">**</span> <span class="p">(</span><span class="n">which</span> <span class="n">SIP</span> <span class="n">doesn</span><span class="s1">&#39;t support) so</span>
        <span class="o">//</span> <span class="n">we</span> <span class="n">explicitly</span> <span class="n">dereference</span> <span class="n">it</span><span class="o">.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">klassInstance</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">klassInstance</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">klassInstance</span><span class="p">;</span>

        <span class="o">//</span> <span class="n">This</span> <span class="n">will</span> <span class="n">get</span> <span class="n">converted</span> <span class="n">to</span> <span class="kc">None</span><span class="o">.</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="o">%</span><span class="n">End</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#std:directive-%GetCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%GetCode</span></code></a>, <a class="reference internal" href="#std:directive-%SetCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%SetCode</span></code></a></p>
</div>
<div class="versionadded" id="std:directive-%API">
<p><span class="versionmodified added">New in version 4.9.</span></p>
</div>
<pre class="literal-block">%API(name = <em>name</em>, version = <em>integer</em>)</pre>
<p>This directive is used to define an API and set its default version number.  A
version number must be greater than or equal to 1.</p>
<p>See <a class="reference internal" href="using.html#ref-incompat-apis"><span class="std std-ref">Managing Incompatible APIs</span></a> for more detail.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">API</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">PyQt4</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded" id="std:directive-%AutoPyName">
<p><span class="versionmodified added">New in version 4.12.</span></p>
</div>
<pre class="literal-block">%AutoPyName(remove_leading = <em>string</em>)</pre>
<p>This is a sub-directive of the <a class="reference internal" href="#std:directive-%Module"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Module</span></code></a> directive used to specify a
rule for automatically providing Python names for classes, enums, functions,
methods, variables and exceptions.  The directive may be specified any number
of times and each rule will be applied in turn.  Rules will not be applied if
an item has been given an explicit Python name.</p>
<p><code class="docutils literal notranslate"><span class="pre">remove_leading</span></code> is a string that will be removed from the beginning of any
C++ or C name.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">Module</span> <span class="n">PyQt4</span><span class="o">.</span><span class="n">QtCore</span>
<span class="p">{</span>
    <span class="o">%</span><span class="n">AutoPyName</span><span class="p">(</span><span class="n">remove_leading</span><span class="o">=</span><span class="s2">&quot;Q&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%BIGetBufferCode">%BIGetBufferCode
    <em>code</em>
%End</pre>
<p>This directive (along with <a class="reference internal" href="#std:directive-%BIReleaseBufferCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%BIReleaseBufferCode</span></code></a>) is used to
specify code that implements the buffer interface of Python v3.  If Python v2
is being used then this is ignored.</p>
<p>The variables that are made available to the handwritten code depend on
whether or not the limited Python API is enabled or not.  The following
variables are made available:</p>
<dl class="simple">
<dt>sipBufferDef *sipBuffer</dt><dd><p>When the use of the limited API is enabled, this is a pointer to a
structure that should be populated by the code.  The <code class="docutils literal notranslate"><span class="pre">bd_buffer</span></code> field
should be set to the address of the buffer.  The <code class="docutils literal notranslate"><span class="pre">bd_length</span></code> field should
be set to the length of the buffer.  The <code class="docutils literal notranslate"><span class="pre">bd_readonly</span></code> field should be
set to a non-zero value if the buffer is read-only.</p>
</dd>
<dt>Py_buffer *sipBuffer</dt><dd><p>When the use of the limited Python API is disabled, this is a pointer to
the Python buffer structure that should be populated by the code.</p>
</dd>
<dt><em>type</em> *sipCpp</dt><dd><p>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</p>
</dd>
<dt>int sipFlags</dt><dd><p>When the use of the limited Python API is disabled, these are the flags
that specify what elements of the <code class="docutils literal notranslate"><span class="pre">sipBuffer</span></code> structure must be
populated.</p>
</dd>
<dt>int sipRes</dt><dd><p>The handwritten code should set this to 0 if there was no error or -1 if
there was an error.</p>
</dd>
<dt>PyObject *sipSelf</dt><dd><p>This is the Python object that wraps the structure or class instance, i.e.
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd>
</dl>
<pre class="literal-block" id="std:directive-%BIGetCharBufferCode">%BIGetCharBufferCode
    <em>code</em>
%End</pre>
<p>This directive (along with <a class="reference internal" href="#std:directive-%BIGetReadBufferCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%BIGetReadBufferCode</span></code></a>,
<a class="reference internal" href="#std:directive-%BIGetSegCountCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%BIGetSegCountCode</span></code></a> and <a class="reference internal" href="#std:directive-%BIGetWriteBufferCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%BIGetWriteBufferCode</span></code></a>) is used
to specify code that implements the buffer interface of Python v2.  If Python
v3 is being used then this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="simple">
<dt><em>type</em> *sipCpp</dt><dd><p>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</p>
</dd>
<dt>void **sipPtrPtr</dt><dd><p>This is the pointer used to return the address of the character buffer.</p>
</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_SSIZE_T</span></code></a> sipRes</dt><dd><p>The handwritten code should set this to the length of the character buffer
or -1 if there was an error.</p>
</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_SSIZE_T</span></code></a> sipSegment</dt><dd><p>This is the number of the segment of the character buffer.</p>
</dd>
<dt>PyObject *sipSelf</dt><dd><p>This is the Python object that wraps the structure or class instance, i.e.
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd>
</dl>
<pre class="literal-block" id="std:directive-%BIGetReadBufferCode">%BIGetReadBufferCode
    <em>code</em>
%End</pre>
<p>This directive (along with <a class="reference internal" href="#std:directive-%BIGetCharBufferCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%BIGetCharBufferCode</span></code></a>,
<a class="reference internal" href="#std:directive-%BIGetSegCountCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%BIGetSegCountCode</span></code></a> and <a class="reference internal" href="#std:directive-%BIGetWriteBufferCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%BIGetWriteBufferCode</span></code></a>) is used
to specify code that implements the buffer interface of Python v2.  If
Python v3 is being used then this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="simple">
<dt><em>type</em> *sipCpp</dt><dd><p>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</p>
</dd>
<dt>void **sipPtrPtr</dt><dd><p>This is the pointer used to return the address of the read buffer.</p>
</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_SSIZE_T</span></code></a> sipRes</dt><dd><p>The handwritten code should set this to the length of the read buffer or
-1 if there was an error.</p>
</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_SSIZE_T</span></code></a> sipSegment</dt><dd><p>This is the number of the segment of the read buffer.</p>
</dd>
<dt>PyObject *sipSelf</dt><dd><p>This is the Python object that wraps the structure or class instance, i.e.
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd>
</dl>
<pre class="literal-block" id="std:directive-%BIGetSegCountCode">%BIGetSegCountCode
    <em>code</em>
%End</pre>
<p>This directive (along with <a class="reference internal" href="#std:directive-%BIGetCharBufferCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%BIGetCharBufferCode</span></code></a>,
<a class="reference internal" href="#std:directive-%BIGetReadBufferCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%BIGetReadBufferCode</span></code></a> and <a class="reference internal" href="#std:directive-%BIGetWriteBufferCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%BIGetWriteBufferCode</span></code></a>) is
used to specify code that implements the buffer interface of Python v2.  If
Python v3 is being used then this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="simple">
<dt><em>type</em> *sipCpp</dt><dd><p>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</p>
</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_SSIZE_T</span></code></a> *sipLenPtr</dt><dd><p>This is the pointer used to return the total length in bytes of all
segments of the buffer.</p>
</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_SSIZE_T</span></code></a> sipRes</dt><dd><p>The handwritten code should set this to the number of segments that make
up the buffer.</p>
</dd>
<dt>PyObject *sipSelf</dt><dd><p>This is the Python object that wraps the structure or class instance, i.e.
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd>
</dl>
<pre class="literal-block" id="std:directive-%BIGetWriteBufferCode">%BIGetWriteBufferCode
    <em>code</em>
%End</pre>
<p>This directive (along with <a class="reference internal" href="#std:directive-%BIGetCharBufferCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%BIGetCharBufferCode</span></code></a>,
<a class="reference internal" href="#std:directive-%BIGetReadBufferCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%BIGetReadBufferCode</span></code></a> and <a class="reference internal" href="#std:directive-%BIGetSegCountCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%BIGetSegCountCode</span></code></a> is used
to specify code that implements the buffer interface of Python v2.  If Python
v3 is being used then this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="simple">
<dt><em>type</em> *sipCpp</dt><dd><p>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</p>
</dd>
<dt>void **sipPtrPtr</dt><dd><p>This is the pointer used to return the address of the write buffer.</p>
</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_SSIZE_T</span></code></a> sipRes</dt><dd><p>The handwritten code should set this to the length of the write buffer or
-1 if there was an error.</p>
</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_SSIZE_T</span></code></a> sipSegment</dt><dd><p>This is the number of the segment of the write buffer.</p>
</dd>
<dt>PyObject *sipSelf</dt><dd><p>This is the Python object that wraps the structure or class instance, i.e.
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd>
</dl>
<pre class="literal-block" id="std:directive-%BIReleaseBufferCode">%BIReleaseBufferCode
    <em>code</em>
%End</pre>
<p>This directive (along with <a class="reference internal" href="#std:directive-%BIGetBufferCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%BIGetBufferCode</span></code></a>) is used to specify
code that implements the buffer interface of Python v3.  If Python v2 is being
used then this is ignored.</p>
<p>The variables that are made available to the handwritten code depend on
whether or not the limited Python API is enabled or not.  The following
variables are made available:</p>
<dl class="simple">
<dt>Py_buffer *sipBuffer</dt><dd><p>When the use of the limited Python API is disabled, this is a pointer to
the Python buffer structure.</p>
</dd>
<dt><em>type</em> *sipCpp</dt><dd><p>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</p>
</dd>
<dt>PyObject *sipSelf</dt><dd><p>This is the Python object that wraps the structure or class instance, i.e.
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd>
</dl>
<div class="deprecated" id="std:directive-%CModule">
<p><span class="versionmodified deprecated">Deprecated since version 4.12: </span>Use the <a class="reference internal" href="#std:directive-%Module"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Module</span></code></a> directive with the <code class="docutils literal notranslate"><span class="pre">language</span></code> argument set
to <code class="docutils literal notranslate"><span class="pre">&quot;C&quot;</span></code> instead.</p>
</div>
<pre class="literal-block">%CModule <em>name</em> [<em>version</em>]</pre>
<p>This directive is used to identify that the library being wrapped is a C
library and to define the name of the module and it’s optional version number.</p>
<p>See the <a class="reference internal" href="#std:directive-%Module"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Module</span></code></a> directive for an explanation of the version
number.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">CModule</span> <span class="n">dbus</span> <span class="mi">1</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%CompositeModule">%CompositeModule(name = <em>dotted-name</em>)
{
    [<a class="reference internal" href="#std:directive-%Docstring"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Docstring</span></code></a>]
};</pre>
<p>A composite module is one that merges a number of related SIP generated
modules.  For example, a module that merges the modules <code class="docutils literal notranslate"><span class="pre">a_mod</span></code>, <code class="docutils literal notranslate"><span class="pre">b_mod</span></code>
and <code class="docutils literal notranslate"><span class="pre">c_mod</span></code> is equivalent to the following pure Python module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">a_mod</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">b_mod</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">c_mod</span> <span class="k">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>Clearly the individual modules should not define module-level objects with the
same name.</p>
<p>This directive is used to specify the name of a composite module.  Any
subsequent <a class="reference internal" href="#std:directive-%Module"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Module</span></code></a> directive is interpreted as defining a
component module.</p>
<p>The optional <a class="reference internal" href="#std:directive-%Docstring"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Docstring</span></code></a> sub-directive is used to specify the
module’s docstring.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">CompositeModule</span> <span class="n">PyQt4</span><span class="o">.</span><span class="n">Qt</span>
<span class="o">%</span><span class="n">Include</span> <span class="n">QtCore</span><span class="o">/</span><span class="n">QtCoremod</span><span class="o">.</span><span class="n">sip</span>
<span class="o">%</span><span class="n">Include</span> <span class="n">QtGui</span><span class="o">/</span><span class="n">QtGuimod</span><span class="o">.</span><span class="n">sip</span>
</pre></div>
</div>
<p>The main purpose of a composite module is as a programmer convenience as they
don’t have to remember which individual module an object is defined in.</p>
<div class="deprecated" id="std:directive-%ConsolidatedModule">
<p><span class="versionmodified deprecated">Deprecated since version 4.16.2: </span>This will not be supported in SIP v5.</p>
</div>
<pre class="literal-block">%ConsolidatedModule(name = <em>dotted-name</em>)
{
    [<a class="reference internal" href="#std:directive-%Docstring"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Docstring</span></code></a>]
};</pre>
<p>A consolidated module is one that consolidates the wrapper code of a number of
SIP generated modules (refered to as component modules in this context).</p>
<p>This directive is used to specify the name of a consolidated module.  Any
subsequent <a class="reference internal" href="#std:directive-%Module"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Module</span></code></a> directive is interpreted as defining a
component module.</p>
<p>The optional <a class="reference internal" href="#std:directive-%Docstring"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Docstring</span></code></a> sub-directive is used to specify the
module’s docstring.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">ConsolidatedModule</span> <span class="n">PyQt4</span><span class="o">.</span><span class="n">_qt</span>
<span class="o">%</span><span class="n">Include</span> <span class="n">QtCore</span><span class="o">/</span><span class="n">QtCoremod</span><span class="o">.</span><span class="n">sip</span>
<span class="o">%</span><span class="n">Include</span> <span class="n">QtGui</span><span class="o">/</span><span class="n">QtGuimod</span><span class="o">.</span><span class="n">sip</span>
</pre></div>
</div>
<p>A consolidated module is not intended to be explicitly imported by an
application.  Instead it is imported by its component modules when they
themselves are imported.</p>
<p>Normally the wrapper code is contained in the component module and is linked
against the corresponding C or C++ library.  The advantage of a consolidated
module is that it allows all of the wrapped C or C++ libraries to be linked
against a single module.  If the linking is done statically then deployment of
generated modules can be greatly simplified.</p>
<p>It follows that a component module can be built in one of two ways, as a
normal standalone module, or as a component of a consolidated module.  When
building as a component the <code class="docutils literal notranslate"><span class="pre">-p</span></code> command line option should be used to
specify the name of the consolidated module.</p>
<pre class="literal-block" id="std:directive-%ConvertFromTypeCode">%ConvertFromTypeCode
    <em>code</em>
%End</pre>
<p>This directive is used as part of the <a class="reference internal" href="#std:directive-%MappedType"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%MappedType</span></code></a> directive (when
it is required) or of a class specification (when it is optional) to specify
the handwritten code that converts an instance of a C/C++ type to a Python
object.</p>
<p>If used as part of a class specification then instances of the class will be
automatically converted to the Python object, even though the class itself has
been wrapped.  This behaviour can be changed on a temporary basis from an
application by calling the <a class="reference internal" href="python_api.html#sip.enableautoconversion" title="sip.enableautoconversion"><code class="xref py py-func docutils literal notranslate"><span class="pre">sip.enableautoconversion()</span></code></a> function, or from
handwritten code by calling the <a class="reference internal" href="c_api.html#c.sipEnableAutoconversion" title="sipEnableAutoconversion"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipEnableAutoconversion()</span></code></a> function.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="simple">
<dt><em>type</em> *sipCpp</dt><dd><p>This is a pointer to the C/C++ instance to be converted.  It will never be
zero as the conversion from zero to <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> is handled before the
handwritten code is called.</p>
</dd>
<dt>PyObject *sipTransferObj</dt><dd><p>This specifies any desired ownership changes to the returned object.  If it
is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the ownership should be left unchanged.  If it is
<code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then ownership should be transferred to Python.  Otherwise
ownership should be transferred to C/C++ and the returned object associated
with <em>sipTransferObj</em>.  The code can choose to interpret these changes in
any way.  For example, if the code is converting a C++ container of wrapped
classes to a Python list it is likely that the ownership changes should be
made to each element of the list.</p>
</dd>
</dl>
<p>The handwritten code must explicitly return a <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code>.  If there was an
error then a Python exception must be raised and <code class="docutils literal notranslate"><span class="pre">NULL</span></code> returned.</p>
<p>The following example converts a <code class="docutils literal notranslate"><span class="pre">QList&lt;QWidget</span> <span class="pre">*&gt;</span></code> instance to a Python
list of <code class="docutils literal notranslate"><span class="pre">QWidget</span></code> instances:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">ConvertFromTypeCode</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">Python</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">the</span> <span class="n">correct</span> <span class="n">length</span><span class="o">.</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">l</span> <span class="o">=</span> <span class="n">PyList_New</span><span class="p">(</span><span class="n">sipCpp</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()))</span> <span class="o">==</span> <span class="n">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">NULL</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Go</span> <span class="n">through</span> <span class="n">each</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">C</span><span class="o">++</span> <span class="n">instance</span> <span class="ow">and</span> <span class="n">convert</span> <span class="n">it</span> <span class="n">to</span> <span class="n">a</span>
    <span class="o">//</span> <span class="n">wrapped</span> <span class="n">QWidget</span><span class="o">.</span>
    <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sipCpp</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">QWidget</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="n">sipCpp</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">wobj</span><span class="p">;</span>

        <span class="o">//</span> <span class="n">Get</span> <span class="n">the</span> <span class="n">Python</span> <span class="n">wrapper</span> <span class="k">for</span> <span class="n">the</span> <span class="n">QWidget</span> <span class="n">instance</span><span class="p">,</span> <span class="n">creating</span> <span class="n">a</span> <span class="n">new</span>
        <span class="o">//</span> <span class="n">one</span> <span class="k">if</span> <span class="n">necessary</span><span class="p">,</span> <span class="ow">and</span> <span class="n">handle</span> <span class="nb">any</span> <span class="n">ownership</span> <span class="n">transfer</span><span class="o">.</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">wobj</span> <span class="o">=</span> <span class="n">sipConvertFromType</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">sipType_QWidget</span><span class="p">,</span> <span class="n">sipTransferObj</span><span class="p">))</span> <span class="o">==</span> <span class="n">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">There</span> <span class="n">was</span> <span class="n">an</span> <span class="n">error</span> <span class="n">so</span> <span class="n">garbage</span> <span class="n">collect</span> <span class="n">the</span> <span class="n">Python</span> <span class="nb">list</span><span class="o">.</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="o">//</span> <span class="n">Add</span> <span class="n">the</span> <span class="n">wrapper</span> <span class="n">to</span> <span class="n">the</span> <span class="nb">list</span><span class="o">.</span>
        <span class="n">PyList_SET_ITEM</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">wobj</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">Return</span> <span class="n">the</span> <span class="n">Python</span> <span class="nb">list</span><span class="o">.</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%ConvertToSubClassCode">%ConvertToSubClassCode
    <em>code</em>
%End</pre>
<p>This directive is fully described in <a class="reference internal" href="using.html#ref-subclass-convertors"><span class="std std-ref">Writing %ConvertToSubClassCode</span></a>.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl>
<dt><em>type</em> *sipCpp</dt><dd><p>This is a pointer to the C++ class instance.  It’s type is the base class
of the convertor.</p>
</dd>
<dt>void **sipCppRet</dt><dd><p>When the sub-class is derived from more than one super-class then it is
possible that the C++ address of the instance as the sub-class is
different to that of the super-class.  If so, then this must be set to the
C++ address of the instance when cast (usually using <code class="docutils literal notranslate"><span class="pre">static_cast</span></code>)
from the super-class to the sub-class.</p>
</dd>
<dt>const sipTypeDef *sipType</dt><dd><p>The handwritten code must set this to the SIP generated type structure
that corresponds to the class instance.  (The type structure for class
<code class="docutils literal notranslate"><span class="pre">Klass</span></code> is <code class="docutils literal notranslate"><span class="pre">sipType_Klass</span></code>.)  If the RTTI of the class instance isn’t
recognised then <code class="docutils literal notranslate"><span class="pre">sipType</span></code> must be set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  The code doesn’t
have to recognise the exact class, only the most specific sub-class that
it can.</p>
<p>The code may also set the value to a type that is apparently unrelated to
the requested type.  If this happens then the whole conversion process is
started again using the new type as the requested type.  This is typically
used to deal with classes that have more than one super-class that are
subject to this conversion process.  It allows the code for one super-class
to switch to the code for another (more appropriate) super-class.</p>
</dd>
<dt>sipWrapperType *sipClass</dt><dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.8: </span>Use <code class="docutils literal notranslate"><span class="pre">sipType</span></code> instead.</p>
</div>
<p>The handwritten code must set this to the SIP generated Python type object
that corresponds to the class instance.  (The type object for class
<code class="docutils literal notranslate"><span class="pre">Klass</span></code> is <code class="docutils literal notranslate"><span class="pre">sipClass_Klass</span></code>.)  If the RTTI of the class instance isn’t
recognised then <code class="docutils literal notranslate"><span class="pre">sipClass</span></code> must be set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  The code doesn’t
have to recognise the exact class, only the most specific sub-class that
it can.</p>
</dd>
</dl>
<p>The handwritten code must not explicitly return.</p>
<p>The following example shows the sub-class conversion code for <code class="docutils literal notranslate"><span class="pre">QEvent</span></code> based
class hierarchy in PyQt:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">QEvent</span>
<span class="p">{</span>
<span class="o">%</span><span class="n">ConvertToSubClassCode</span>
    <span class="o">//</span> <span class="n">QEvent</span> <span class="n">sub</span><span class="o">-</span><span class="n">classes</span> <span class="n">provide</span> <span class="n">a</span> <span class="n">unique</span> <span class="nb">type</span> <span class="n">ID</span><span class="o">.</span>
    <span class="n">switch</span> <span class="p">(</span><span class="n">sipCpp</span><span class="o">-&gt;</span><span class="nb">type</span><span class="p">())</span>
    <span class="p">{</span>
    <span class="n">case</span> <span class="n">QEvent</span><span class="p">::</span><span class="n">Timer</span><span class="p">:</span>
        <span class="n">sipType</span> <span class="o">=</span> <span class="n">sipType_QTimerEvent</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="n">case</span> <span class="n">QEvent</span><span class="p">::</span><span class="n">KeyPress</span><span class="p">:</span>
    <span class="n">case</span> <span class="n">QEvent</span><span class="p">::</span><span class="n">KeyRelease</span><span class="p">:</span>
        <span class="n">sipType</span> <span class="o">=</span> <span class="n">sipType_QKeyEvent</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Skip</span> <span class="n">the</span> <span class="n">remaining</span> <span class="n">event</span> <span class="n">types</span> <span class="n">to</span> <span class="n">keep</span> <span class="n">the</span> <span class="n">example</span> <span class="n">short</span><span class="o">.</span>

    <span class="n">default</span><span class="p">:</span>
        <span class="o">//</span> <span class="n">We</span> <span class="n">don</span><span class="s1">&#39;t recognise the type.</span>
        <span class="n">sipType</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="o">%</span><span class="n">End</span>

    <span class="o">//</span> <span class="n">The</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">the</span> <span class="k">class</span> <span class="nc">specification</span><span class="o">.</span>

<span class="p">};</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%ConvertToTypeCode">%ConvertToTypeCode
    <em>code</em>
%End</pre>
<p>This directive is used to specify the handwritten code that converts a Python
object to a mapped type instance and to handle any ownership transfers.  It is
used as part of the <a class="reference internal" href="#std:directive-%MappedType"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%MappedType</span></code></a> directive and as part of a class
specification.  The code is also called to determine if the Python object is of
the correct type prior to conversion.</p>
<p>When used as part of a class specification it can automatically convert
additional types of Python object.  For example, PyQt uses it in the
specification of the <code class="docutils literal notranslate"><span class="pre">QString</span></code> class to allow Python string objects and
unicode objects to be used wherever <code class="docutils literal notranslate"><span class="pre">QString</span></code> instances are expected.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="simple">
<dt>int *sipIsErr</dt><dd><p>If this is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the code is being asked to check the type of the
Python object.  The check must not have any side effects.  Otherwise the
code is being asked to convert the Python object and a non-zero value
should be returned through this pointer if an error occurred during the
conversion.</p>
</dd>
<dt>PyObject *sipPy</dt><dd><p>This is the Python object to be converted.</p>
</dd>
<dt><em>type</em> **sipCppPtr</dt><dd><p>This is a pointer through which the address of the mapped type instance (or
zero if appropriate) is returned.  Its value is undefined if <code class="docutils literal notranslate"><span class="pre">sipIsErr</span></code>
is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
<dt>PyObject *sipTransferObj</dt><dd><p>This specifies any desired ownership changes to <em>sipPy</em>.  If it is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
then the ownership should be left unchanged.  If it is <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> then
ownership should be transferred to Python.  Otherwise ownership should be
transferred to C/C++ and <em>sipPy</em> associated with <em>sipTransferObj</em>.  The
code can choose to interpret these changes in any way.</p>
</dd>
</dl>
<p>The handwritten code must explicitly return an <code class="docutils literal notranslate"><span class="pre">int</span></code> the meaning of which
depends on the value of <code class="docutils literal notranslate"><span class="pre">sipIsErr</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">sipIsErr</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then a non-zero value is returned if the Python
object has a type that can be converted to the mapped type.  Otherwise zero is
returned.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">sipIsErr</span></code> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then a combination of the following flags is
returned.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_TEMPORARY</span></code> is set to indicate that the returned
instance is a temporary and should be released to avoid a memory
leak.</p></li>
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_DERIVED_CLASS</span></code> is set to indicate that the type of the
returned instance is a derived class.  See
<a class="reference internal" href="c_api.html#ref-derived-classes"><span class="std std-ref">Generated Derived Classes</span></a>.</p></li>
</ul>
</div></blockquote>
<p>The following example converts a Python list of <code class="docutils literal notranslate"><span class="pre">QPoint</span></code> instances to a
<code class="docutils literal notranslate"><span class="pre">QList&lt;QPoint&gt;</span></code> instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>%ConvertToTypeCode
    // See if we are just being asked to check the type of the Python
    // object.
    if (!sipIsErr)
    {
        // Checking whether or not None has been passed instead of a list
        // has already been done.
        if (!PyList_Check(sipPy))
            return 0;

        // Check the type of each element.  We specify SIP_NOT_NONE to
        // disallow None because it is a list of QPoint, not of a pointer
        // to a QPoint, so None isn&#39;t appropriate.
        for (int i = 0; i &lt; PyList_GET_SIZE(sipPy); ++i)
            if (!sipCanConvertToType(PyList_GET_ITEM(sipPy, i),
                                     sipType_QPoint, SIP_NOT_NONE))
                return 0;

        // The type is valid.
        return 1;
    }

    // Create the instance on the heap.
    QList&lt;QPoint&gt; *ql = new QList&lt;QPoint&gt;;

    for (int i = 0; i &lt; PyList_GET_SIZE(sipPy); ++i)
    {
        QPoint *qp;
        int state;

        // Get the address of the element&#39;s C++ instance.  Note that, in
        // this case, we don&#39;t apply any ownership changes to the list
        // elements, only to the list itself.
        qp = reinterpret_cast&lt;QPoint *&gt;(sipConvertToType(
                                                PyList_GET_ITEM(sipPy, i),
                                                sipType_QPoint, 0,
                                                SIP_NOT_NONE,
                                                &amp;state, sipIsErr));

        // Deal with any errors.
        if (*sipIsErr)
        {
            sipReleaseType(qp, sipType_QPoint, state);

            // Tidy up.
            delete ql;

            // There is no temporary instance.
            return 0;
        }

        ql-&gt;append(*qp);

        // A copy of the QPoint was appended to the list so we no longer
        // need it.  It may be a temporary instance that should be
        // destroyed, or a wrapped instance that should not be destroyed.
        // sipReleaseType() will do the right thing.
        sipReleaseType(qp, sipType_QPoint, state);
    }

    // Return the instance.
    *sipCppPtr = ql;

    // The instance should be regarded as temporary (and be destroyed as
    // soon as it has been used) unless it has been transferred from
    // Python.  sipGetState() is a convenience function that implements
    // this common transfer behaviour.
    return sipGetState(sipTransferObj);
%End
</pre></div>
</div>
<p>When used in a class specification the handwritten code replaces the code that
would normally be automatically generated.  This means that the handwritten
code must also handle instances of the class itself and not just the additional
types that are being supported.  This should be done by making calls to
<a class="reference internal" href="c_api.html#c.sipCanConvertToType" title="sipCanConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipCanConvertToType()</span></code></a> to check the object type and
<a class="reference internal" href="c_api.html#c.sipConvertToType" title="sipConvertToType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipConvertToType()</span></code></a> to convert the object.  The
<a class="reference internal" href="c_api.html#c.SIP_NO_CONVERTORS" title="SIP_NO_CONVERTORS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SIP_NO_CONVERTORS</span></code></a> flag <em>must</em> be passed to both these functions to
prevent recursive calls to the handwritten code.</p>
<pre class="literal-block" id="std:directive-%Copying">%Copying
    <em>text</em>
%End</pre>
<p>This directive is used to specify some arbitrary text that will be included at
the start of all source files generated by SIP.  It is normally used to include
copyright and licensing terms.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">Copying</span>
<span class="n">Copyright</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="mi">2015</span> <span class="n">Riverbank</span> <span class="n">Computing</span> <span class="n">Limited</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<div class="versionadded" id="std:directive-%DefaultDocstringFormat">
<p><span class="versionmodified added">New in version 4.13.</span></p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">DefaultDocstringFormat</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;raw&quot;</span> <span class="o">|</span> <span class="s2">&quot;deindented&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>This directive is used to specify the default formatting of docstrings, i.e.
when the <a class="reference internal" href="#std:directive-%Docstring"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Docstring</span></code></a> directive does not specify an explicit format.</p>
<p>See the <a class="reference internal" href="#std:directive-%Docstring"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Docstring</span></code></a> directive for an explanation of the different
formats.  If the directive is not specified then the default format used is
<code class="docutils literal notranslate"><span class="pre">&quot;raw&quot;</span></code>.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">DefaultDocstringFormat</span> <span class="s2">&quot;deindented&quot;</span>
</pre></div>
</div>
<div class="versionadded" id="std:directive-%DefaultDocstringSignature">
<p><span class="versionmodified added">New in version 4.19.7.</span></p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">DefaultDocstringSignature</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;discarded&quot;</span> <span class="o">|</span> <span class="s2">&quot;prepended&quot;</span> <span class="o">|</span> <span class="s2">&quot;appended&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>This directive is used to specify the default positioning of signatures in
docstrings, i.e. when the <a class="reference internal" href="#std:directive-%Docstring"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Docstring</span></code></a> directive is used but does
not specify an explicit positioning.</p>
<p>See the <a class="reference internal" href="#std:directive-%Docstring"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Docstring</span></code></a> directive for an explanation of the different
ways signatures are positioned.  If the directive is not specified then the
default positioning is <code class="docutils literal notranslate"><span class="pre">&quot;discarded&quot;</span></code>.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">DefaultDocstringSignature</span> <span class="s2">&quot;prepended&quot;</span>
</pre></div>
</div>
<div class="highlight-default notranslate" id="std:directive-%DefaultEncoding"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">DefaultEncoding</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ASCII&quot;</span> <span class="o">|</span> <span class="s2">&quot;Latin-1&quot;</span> <span class="o">|</span> <span class="s2">&quot;UTF-8&quot;</span> <span class="o">|</span> <span class="s2">&quot;None&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>This directive is used to specify the default encoding used for <code class="docutils literal notranslate"><span class="pre">char</span></code>,
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> values.  An encoding of
<code class="docutils literal notranslate"><span class="pre">&quot;None&quot;</span></code> means that the value is unencoded.  The default can be overridden
for a particular value using the <a class="reference internal" href="annotations.html#argument-annotation-Encoding"><code class="xref std std-aanno docutils literal notranslate"><span class="pre">Encoding</span></code></a> annotation.</p>
<p>If the directive is not specified then the default encoding of the last
imported module is used, if any.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">DefaultEncoding</span> <span class="s2">&quot;Latin-1&quot;</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%DefaultMetatype">%DefaultMetatype(name = <em>dotted-name</em>)</pre>
<p>This directive is used to specify the Python type that should be used as the
meta-type for any C/C++ data type defined in the same module, and by importing
modules, that doesn’t have an explicit meta-type.</p>
<p>If this is not specified then <code class="docutils literal notranslate"><span class="pre">sip.wrappertype</span></code> is used.</p>
<p>You can also use the <a class="reference internal" href="annotations.html#class-annotation-Metatype"><code class="xref std std-canno docutils literal notranslate"><span class="pre">Metatype</span></code></a> class annotation to specify the
meta-type used by a particular C/C++ type.</p>
<p>See the section <a class="reference internal" href="using.html#ref-types-metatypes"><span class="std std-ref">Types and Meta-types</span></a> for more details.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">DefaultMetatype</span> <span class="n">PyQt4</span><span class="o">.</span><span class="n">QtCore</span><span class="o">.</span><span class="n">pyqtWrapperType</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%DefaultSupertype">%DefaultSupertype(name = <em>dotted-name</em>)</pre>
<p>This directive is used to specify the Python type that should be used as the
super-type for any C/C++ data type defined in the same module that doesn’t have
an explicit super-type.</p>
<p>If this is not specified then <code class="docutils literal notranslate"><span class="pre">sip.wrapper</span></code> is used.</p>
<p>You can also use the <a class="reference internal" href="annotations.html#class-annotation-Supertype"><code class="xref std std-canno docutils literal notranslate"><span class="pre">Supertype</span></code></a> class annotation to specify the
super-type used by a particular C/C++ type.</p>
<p>See the section <a class="reference internal" href="using.html#ref-types-metatypes"><span class="std std-ref">Types and Meta-types</span></a> for more details.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">DefaultSupertype</span> <span class="n">sip</span><span class="o">.</span><span class="n">simplewrapper</span>
</pre></div>
</div>
<div class="deprecated" id="std:directive-%Doc">
<p><span class="versionmodified deprecated">Deprecated since version 4.12: </span>Use the <a class="reference internal" href="#std:directive-%Extract"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Extract</span></code></a> directive instead.</p>
</div>
<pre class="literal-block">%Doc
    <em>text</em>
%End</pre>
<p>This directive is used to specify some arbitrary text that will be extracted
by SIP when the <code class="docutils literal notranslate"><span class="pre">-d</span></code> command line option is used.  The directive can be
specified any number of times and SIP will concatenate all the separate pieces
of text in the order that it sees them.</p>
<p>Documentation that is specified using this directive is local to the module in
which it appears.  It is ignored by modules that <a class="reference internal" href="#std:directive-%Import"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Import</span></code></a> it.  Use
the <a class="reference internal" href="#std:directive-%ExportedDoc"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ExportedDoc</span></code></a> directive for documentation that should be
included by all modules that <a class="reference internal" href="#std:directive-%Import"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Import</span></code></a> this one.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">Doc</span>
<span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">An</span> <span class="n">Example</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
<span class="n">This</span> <span class="n">fragment</span> <span class="n">of</span> <span class="n">documentation</span> <span class="ow">is</span> <span class="n">HTML</span> <span class="ow">and</span> <span class="ow">is</span> <span class="n">local</span> <span class="n">to</span> <span class="n">the</span> <span class="n">module</span> <span class="ow">in</span>
<span class="n">which</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">defined</span><span class="o">.</span>
<span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<div class="versionadded" id="std:directive-%Docstring">
<p><span class="versionmodified added">New in version 4.10.</span></p>
</div>
<pre class="literal-block">%Docstring(format = [&quot;raw&quot; | &quot;deindented&quot;], signature = [&quot;discarded&quot; | &quot;prepended&quot; | &quot;appended&quot;])
    <em>text</em>
%End</pre>
<p>This directive is used to specify explicit docstrings for modules, classes,
functions, methods, typedefs and properties.</p>
<p>The docstring of a class is made up of the docstring specified for the class
itself, with the docstrings specified for each contructor appended.</p>
<p>The docstring of a function or method is made up of the concatenated docstrings
specified for each of the overloads.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Specifying an explicit docstring will mean that SIP will generate less
informative exceptions (i.e. without a full signature) when it fails to
match a set of arguments to any function or method overload.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 4.13.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">format</span></code> may either be <code class="docutils literal notranslate"><span class="pre">&quot;raw&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;deindented&quot;</span></code>.  If it is not specified
then the value specified by any <a class="reference internal" href="#std:directive-%DefaultDocstringFormat"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%DefaultDocstringFormat</span></code></a> directive
is used.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">format</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;raw&quot;</span></code> then the docstring is used as it appears in the
specification file.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">format</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;deindented&quot;</span></code> then any leading spaces common to all
non-blank lines of the docstring are removed.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 4.19.7.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">signature</span></code> may either be <code class="docutils literal notranslate"><span class="pre">&quot;discarded&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;prepended&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;appended&quot;</span></code>.
It is ignored unless applied to the docstring of a class, function or method.
If it is not specified then the value specified by any
<a class="reference internal" href="#std:directive-%DefaultDocstringSignature"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%DefaultDocstringSignature</span></code></a> directive is used.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">signature</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;discarded&quot;</span></code> then the automatically generated function
or method signature is discarded.  In the context of a class’s docstring then
this refers to all of the constructors’ docstrings.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">signature</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;prepended&quot;</span></code> then the automatically generated function
or method signature is placed before the docstring.  In the context of a
class’s docstring then this refers to all of the constructors’ docstrings.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">signature</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;appended&quot;</span></code> then the automatically generated function
or method signature is placed after the docstring.  In the context of a class’s
docstring then this refers to all of the constructors’ docstrings.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Klass</span>
<span class="p">{</span>
<span class="o">%</span><span class="n">Docstring</span>
<span class="n">This</span> <span class="n">will</span> <span class="n">be</span> <span class="n">at</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="n">class</span><span class="s1">&#39;s docstring.</span>
<span class="o">%</span><span class="n">End</span>

<span class="n">public</span><span class="p">:</span>
    <span class="n">Klass</span><span class="p">();</span>
<span class="o">%</span><span class="n">Docstring</span> <span class="s2">&quot;deindented&quot;</span>
    <span class="n">This</span> <span class="n">will</span> <span class="n">be</span> <span class="n">appended</span> <span class="n">to</span> <span class="n">the</span> <span class="n">class</span><span class="s1">&#39;s docstring and will not be indented.</span>

        <span class="n">This</span> <span class="n">will</span> <span class="n">be</span> <span class="n">indented</span> <span class="n">by</span> <span class="n">four</span> <span class="n">spaces</span><span class="o">.</span>
<span class="o">%</span><span class="n">End</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#std:directive-%DefaultDocstringFormat"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%DefaultDocstringFormat</span></code></a>,
<a class="reference internal" href="#std:directive-%DefaultDocstringSignature"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%DefaultDocstringSignature</span></code></a></p>
</div>
<p id="std:directive-%End">This isn’t a directive in itself, but is used to terminate a number of
directives that allow a block of handwritten code or text to be specified.</p>
<pre class="literal-block" id="std:directive-%Exception">%Exception <em>name</em> [(<em>base-exception</em>)]
{
    [<a class="reference internal" href="#std:directive-%TypeHeaderCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%TypeHeaderCode</span></code></a>]
    <a class="reference internal" href="#std:directive-%RaiseCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%RaiseCode</span></code></a>
};</pre>
<p>This directive is used to define new Python exceptions, or to provide a stub
for existing Python exceptions.  It allows handwritten code to be provided
that implements the translation between C++ exceptions and Python exceptions.
The arguments to <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">()</span></code> specifiers must either be names of classes or the
names of Python exceptions defined by this directive.</p>
<p><em>name</em> is the name of the exception.</p>
<p><em>base-exception</em> is the optional base exception.  This may be either one of
the standard Python exceptions or one defined with a previous
<a class="reference internal" href="#std:directive-%Exception"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Exception</span></code></a> directive.</p>
<p>The optional <a class="reference internal" href="#std:directive-%TypeHeaderCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%TypeHeaderCode</span></code></a> sub-directive is used to specify any
external interface to the exception being defined.</p>
<p>The <a class="reference internal" href="#std:directive-%RaiseCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%RaiseCode</span></code></a> sub-directive is used to specify the handwritten
code that converts a reference to the C++ exception to the Python exception.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="ne">Exception</span> <span class="n">std</span><span class="p">::</span><span class="n">exception</span><span class="p">(</span><span class="n">SIP_Exception</span><span class="p">)</span> <span class="o">/</span><span class="n">PyName</span><span class="o">=</span><span class="n">StdException</span><span class="o">/</span>
<span class="p">{</span>
<span class="o">%</span><span class="n">TypeHeaderCode</span>
<span class="c1">#include &lt;exception&gt;</span>
<span class="o">%</span><span class="n">End</span>
<span class="o">%</span><span class="n">RaiseCode</span>
    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">detail</span> <span class="o">=</span> <span class="n">sipExceptionRef</span><span class="o">.</span><span class="n">what</span><span class="p">();</span>

    <span class="n">SIP_BLOCK_THREADS</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">sipException_std_exception</span><span class="p">,</span> <span class="n">detail</span><span class="p">);</span>
    <span class="n">SIP_UNBLOCK_THREADS</span>
<span class="o">%</span><span class="n">End</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In this example we map the standard C++ exception to a new Python exception.
The new exception is called <code class="docutils literal notranslate"><span class="pre">StdException</span></code> and is derived from the standard
Python exception <code class="docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
<p>An exception may be annotated with <a class="reference internal" href="annotations.html#exception-annotation-Default"><code class="xref std std-xanno docutils literal notranslate"><span class="pre">Default</span></code></a> to specify that it should
be caught by default if there is no <code class="docutils literal notranslate"><span class="pre">throw</span></code> clause.</p>
<div class="deprecated" id="std:directive-%ExportedDoc">
<p><span class="versionmodified deprecated">Deprecated since version 4.12: </span>Use the <a class="reference internal" href="#std:directive-%Extract"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Extract</span></code></a> directive instead.</p>
</div>
<pre class="literal-block">%ExportedDoc
    <em>text</em>
%End</pre>
<p>This directive is used to specify some arbitrary text that will be extracted
by SIP when the <code class="docutils literal notranslate"><span class="pre">-d</span></code> command line option is used.  The directive can be
specified any number of times and SIP will concatenate all the separate pieces
of text in the order that it sees them.</p>
<p>Documentation that is specified using this directive will also be included by
modules that <a class="reference internal" href="#std:directive-%Import"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Import</span></code></a> it.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">ExportedDoc</span>
<span class="o">==========</span>
<span class="n">An</span> <span class="n">Example</span>
<span class="o">==========</span>

<span class="n">This</span> <span class="n">fragment</span> <span class="n">of</span> <span class="n">documentation</span> <span class="ow">is</span> <span class="n">reStructuredText</span> <span class="ow">and</span> <span class="n">will</span> <span class="n">appear</span> <span class="ow">in</span> <span class="n">the</span>
<span class="n">module</span> <span class="ow">in</span> <span class="n">which</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">defined</span> <span class="ow">and</span> <span class="nb">all</span> <span class="n">modules</span> <span class="n">that</span> <span class="o">%</span><span class="n">Import</span> <span class="n">it</span><span class="o">.</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%ExportedHeaderCode">%ExportedHeaderCode
    <em>code</em>
%End</pre>
<p>This directive is used to specify handwritten code, typically the declarations
of types, that is placed in a header file that is included by all generated
code for all modules.  It should not include function declarations because
Python modules should not explicitly call functions in another Python module.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#std:directive-%ModuleCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ModuleCode</span></code></a>, <a class="reference internal" href="#std:directive-%ModuleHeaderCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ModuleHeaderCode</span></code></a></p>
</div>
<div class="versionadded" id="std:directive-%ExportedTypeHintCode">
<p><span class="versionmodified added">New in version 4.18.</span></p>
</div>
<pre class="literal-block">%ExportedTypeHintCode
    <em>code</em>
%End</pre>
<p>This directive is used to specify handwritten code, typically the declarations
of types, that is placed in the PEP 484 type hint stub file for any module that
imports it.  Note that it is not included in the stub file for the module
itself.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#std:directive-%TypeHintCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%TypeHintCode</span></code></a></p>
</div>
<div class="versionadded" id="std:directive-%Extract">
<p><span class="versionmodified added">New in version 4.12.</span></p>
</div>
<pre class="literal-block">%Extract(id = <em>name</em> [, order = <em>integer</em>])
    <em>text</em>
%End</pre>
<p>This directive is used to specify part of an extract.  An extract is a
collection of arbitrary text specified as one or more parts each having the
same <code class="docutils literal notranslate"><span class="pre">id</span></code>.  SIP places no interpretation on an identifier, or on the
contents of the extract.  Extracts may be used for any purpose, e.g.
documentation, tests etc.</p>
<p>The part’s optional <code class="docutils literal notranslate"><span class="pre">order</span></code> determines its position relative to the extract’s
other parts.  If the order is not specified then the part is appended to the
extract.</p>
<p>An extract is written to a file using the <a class="reference internal" href="command_line.html#id5"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a> command line
option.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">Extract</span> <span class="n">example</span>
<span class="n">This</span> <span class="n">will</span> <span class="n">be</span> <span class="n">the</span> <span class="n">last</span> <span class="n">line</span> <span class="n">because</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">explicit</span> <span class="n">order</span><span class="o">.</span>
<span class="o">%</span><span class="n">End</span>

<span class="o">%</span><span class="n">Extract</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">example</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">This</span> <span class="n">will</span> <span class="n">be</span> <span class="n">the</span> <span class="n">second</span> <span class="n">line</span><span class="o">.</span>
<span class="o">%</span><span class="n">End</span>

<span class="o">%</span><span class="n">Extract</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">example</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">This</span> <span class="n">will</span> <span class="n">be</span> <span class="n">the</span> <span class="n">first</span> <span class="n">line</span><span class="o">.</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%Feature">%Feature(name = <em>name</em>)</pre>
<p>This directive is used to declare a feature.  Features (along with
<a class="reference internal" href="#std:directive-%Platforms"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Platforms</span></code></a> and <a class="reference internal" href="#std:directive-%Timeline"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Timeline</span></code></a>) are used by the
<a class="reference internal" href="#std:directive-%If"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%If</span></code></a> directive to control whether or not parts of a specification
are processed or ignored.</p>
<p>Features are mutually independent of each other - any combination of features
may be enabled or disabled.  By default all features are enabled.  The
<a class="reference internal" href="command_line.html#cmdoption-sip-x"><code class="xref std std-option docutils literal notranslate"><span class="pre">-x</span></code></a> command line option is used to disable a feature.</p>
<p>If a feature is enabled then SIP will automatically generate a corresponding C
preprocessor symbol for use by handwritten code.  The symbol is the name of
the feature prefixed by <code class="docutils literal notranslate"><span class="pre">SIP_FEATURE_</span></code>.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">Feature</span> <span class="n">FOO_SUPPORT</span>

<span class="o">%</span><span class="n">If</span> <span class="p">(</span><span class="n">FOO_SUPPORT</span><span class="p">)</span>
<span class="n">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<div class="versionadded" id="std:directive-%FinalisationCode">
<p><span class="versionmodified added">New in version 4.15.</span></p>
</div>
<pre class="literal-block">%FinalisationCode
    <em>code</em>
%End</pre>
<p>This directive is used to specify handwritten code that is executed once the
instance of a wrapped class has been created.  The handwritten code is passed a
dictionary of any remaining keyword arguments.  It must explicitly return an
integer result which should be <code class="docutils literal notranslate"><span class="pre">0</span></code> if there was no error.  If an error
occurred then <code class="docutils literal notranslate"><span class="pre">-1</span></code> should be returned and a Python exception raised.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="simple">
<dt>PyObject *sipSelf</dt><dd><p>This is the Python object that wraps the structure or class instance, i.e.
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd>
<dt><em>type</em> *sipCpp</dt><dd><p>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</p>
</dd>
<dt>PyObject *sipKwds</dt><dd><p>This is an optional dictionary of unused keyword arguments.  It may be
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> or refer to an empty dictionary.  If the handwritten code handles
any of the arguments then, if <code class="docutils literal notranslate"><span class="pre">sipUnused</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, those arguments
must be removed from the dictionary.  If <code class="docutils literal notranslate"><span class="pre">sipUnused</span></code> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then
the <code class="docutils literal notranslate"><span class="pre">sipKwds</span></code> dictionary must not be updated.  Instead a new dictionary
must be created that contains any remaining unused keyword arguments and
the address of the new dictionary returned via <code class="docutils literal notranslate"><span class="pre">sipUnused</span></code>.  This rather
complicated API ensures that new dictionaries are created only when
necessary.</p>
</dd>
<dt>PyObject **sipUnused</dt><dd><p>This is an optional pointer to where the handwritten code should save the
address of any new dictionary of unused keyword arguments that it creates.
If it is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then the handwritten code is allowed to update the
<code class="docutils literal notranslate"><span class="pre">sipKwds</span></code> dictionary.</p>
</dd>
</dl>
<pre class="literal-block" id="std:directive-%GCClearCode">%GCClearCode
    <em>code</em>
%End</pre>
<p>Python has a cyclic garbage collector which can identify and release unneeded
objects even when their reference counts are not zero.  If a wrapped C
structure or C++ class keeps its own reference to a Python object then, if the
garbage collector is to do its job, it needs to provide some handwritten code
to traverse and potentially clear those embedded references.</p>
<p>See the section <a class="reference external" href="https://docs.python.org/3/c-api/gcsupport.html">Supporting Cyclic Garbage Collection</a> in the Python documentation
for the details.</p>
<p>This directive is used to specify the code that clears any embedded references.
(See <a class="reference internal" href="#std:directive-%GCTraverseCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%GCTraverseCode</span></code></a> for specifying the code that traverses any
embedded references.)</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="simple">
<dt><em>type</em> *sipCpp</dt><dd><p>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</p>
</dd>
<dt>int sipRes</dt><dd><p>The handwritten code should set this to the result to be returned.</p>
</dd>
</dl>
<p>The following simplified example is taken from PyQt.  The <code class="docutils literal notranslate"><span class="pre">QCustomEvent</span></code>
class allows arbitary data to be attached to the event.  In PyQt this data is
always a Python object and so should be handled by the garbage collector:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">GCClearCode</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Get</span> <span class="n">the</span> <span class="nb">object</span><span class="o">.</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">PyObject</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">sipCpp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">());</span>

    <span class="o">//</span> <span class="n">Clear</span> <span class="n">the</span> <span class="n">pointer</span><span class="o">.</span>
    <span class="n">sipCpp</span><span class="o">-&gt;</span><span class="n">setData</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">Clear</span> <span class="n">the</span> <span class="n">reference</span><span class="o">.</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">Report</span> <span class="n">no</span> <span class="n">error</span><span class="o">.</span>
    <span class="n">sipRes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%GCTraverseCode">%GCTraverseCode
    <em>code</em>
%End</pre>
<p>This directive is used to specify the code that traverses any embedded
references for Python’s cyclic garbage collector.  (See
<a class="reference internal" href="#std:directive-%GCClearCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%GCClearCode</span></code></a> for a full explanation.)</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="simple">
<dt><em>type</em> *sipCpp</dt><dd><p>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</p>
</dd>
<dt>visitproc sipVisit</dt><dd><p>This is the visit function provided by the garbage collector.</p>
</dd>
<dt>void *sipArg</dt><dd><p>This is the argument to the visit function provided by the garbage
collector.</p>
</dd>
<dt>int sipRes</dt><dd><p>The handwritten code should set this to the result to be returned.</p>
</dd>
</dl>
<p>The following simplified example is taken from PyQt’s <code class="docutils literal notranslate"><span class="pre">QCustomEvent</span></code> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">GCTraverseCode</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Get</span> <span class="n">the</span> <span class="nb">object</span><span class="o">.</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">PyObject</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">sipCpp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">());</span>

    <span class="o">//</span> <span class="n">Call</span> <span class="n">the</span> <span class="n">visit</span> <span class="n">function</span> <span class="k">if</span> <span class="n">there</span> <span class="n">was</span> <span class="n">an</span> <span class="nb">object</span><span class="o">.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">sipRes</span> <span class="o">=</span> <span class="n">sipVisit</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">sipArg</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">sipRes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%GetCode">%GetCode
    <em>code</em>
%End</pre>
<p>This sub-directive is used in the declaration of a C++ class variable or C
structure member to specify handwritten code to convert it to a Python object.
It is usually used to handle types that SIP cannot deal with automatically.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="simple">
<dt><em>type</em> *sipCpp</dt><dd><p>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.  It is not made available if the
variable being wrapped is a static class variable.</p>
</dd>
<dt>PyObject *sipPy</dt><dd><p>The handwritten code must set this to the Python representation of the
class variable or structure member.  If there is an error then the code
must raise an exception and set this to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
<dt>PyObject *sipPyType</dt><dd><p>If the variable being wrapped is a static class variable then this is the
Python type object of the class from which the variable was referenced
(<em>not</em> the class in which it is defined).  It may be safely cast to a
PyTypeObject * or a sipWrapperType *.</p>
</dd>
</dl>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">Entity</span>
<span class="p">{</span>
    <span class="o">/*</span>
     <span class="o">*</span> <span class="n">In</span> <span class="n">this</span> <span class="n">contrived</span> <span class="n">example</span> <span class="n">the</span> <span class="n">C</span> <span class="n">library</span> <span class="n">we</span> <span class="n">are</span> <span class="n">wrapping</span> <span class="n">actually</span>
     <span class="o">*</span> <span class="n">defines</span> <span class="n">this</span> <span class="k">as</span> <span class="n">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="n">which</span> <span class="n">SIP</span> <span class="n">cannot</span> <span class="n">handle</span>
     <span class="o">*</span> <span class="n">automatically</span><span class="o">.</span>
     <span class="o">*/</span>
    <span class="n">char</span> <span class="o">*</span><span class="n">buffer</span>
    <span class="p">{</span>
        <span class="o">%</span><span class="n">GetCode</span>
            <span class="n">sipPy</span> <span class="o">=</span> <span class="n">PyString_FromStringAndSize</span><span class="p">(</span><span class="n">sipCpp</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
        <span class="o">%</span><span class="n">End</span>

        <span class="o">%</span><span class="n">SetCode</span>
            <span class="n">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
            <span class="nb">int</span> <span class="n">length</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">PyString_AsStringAndSize</span><span class="p">(</span><span class="n">sipPy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">sipErr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">100</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="o">/*</span>
                 <span class="o">*</span> <span class="n">Raise</span> <span class="n">an</span> <span class="n">exception</span> <span class="n">because</span> <span class="n">the</span> <span class="n">length</span> <span class="n">isn</span><span class="s1">&#39;t exactly</span>
                 <span class="o">*</span> <span class="n">right</span><span class="o">.</span>
                 <span class="o">*/</span>

                <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_ValueError</span><span class="p">,</span>
                        <span class="s2">&quot;an Entity.buffer must be exactly 100 bytes&quot;</span><span class="p">);</span>
                <span class="n">sipErr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="n">sipCpp</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="o">%</span><span class="n">End</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#std:directive-%AccessCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%AccessCode</span></code></a>, <a class="reference internal" href="#std:directive-%SetCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%SetCode</span></code></a></p>
</div>
<div class="versionadded" id="std:directive-%HideNamespace">
<p><span class="versionmodified added">New in version 4.19.</span></p>
</div>
<pre class="literal-block">%HideNamespace(name = <em>name</em>)</pre>
<p>This directive is used to specify that a C++ namespace, which would normally be
wrapped as a Python class, is not wrapped.  The contents of the namespace are
still wrapped but are placed in the module dictionary.  This is usually used
when a library being wrapped uses a single namespace that includes everything
in the library.  In Python the module itself performs the same function as the
namespace and so the namespace would just add an unneccessary extra level of
indirection.</p>
<pre class="literal-block" id="std:directive-%If">%If (<em>expression</em>)
    <em>specification</em>
%End</pre>
<p>where</p>
<pre class="literal-block"><em>expression</em> ::= [<em>ored-qualifiers</em> | <em>range</em>]

<em>ored-qualifiers</em> ::= [<em>qualifier</em> | <em>qualifier</em> <strong>||</strong> <em>ored-qualifiers</em>]

<em>qualifier</em> ::= [<strong>!</strong>] [<em>feature</em> | <em>platform</em>]

<em>range</em> ::= [<em>version</em>] <strong>-</strong> [<em>version</em>]</pre>
<p>This directive is used in conjunction with features (see
<a class="reference internal" href="#std:directive-%Feature"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Feature</span></code></a>), platforms (see <a class="reference internal" href="#std:directive-%Platforms"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Platforms</span></code></a>) and versions
(see <a class="reference internal" href="#std:directive-%Timeline"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Timeline</span></code></a>) to control whether or not parts of a specification
are processed or not.</p>
<p>A <em>range</em> of versions means all versions starting with the lower bound up to
but excluding the upper bound.  If the lower bound is omitted then it is
interpreted as being before the earliest version.  If the upper bound is
omitted then it is interpreted as being after the latest version.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>%Feature SUPPORT_FOO
%Platforms {WIN32_PLATFORM POSIX_PLATFORM MACOS_PLATFORM}
%Timeline {V1_0 V1_1 V2_0 V3_0}

%If (!SUPPORT_FOO)
    // Process this if the SUPPORT_FOO feature is disabled.
%End

%If (POSIX_PLATFORM || MACOS_PLATFORM)
    // Process this if either the POSIX_PLATFORM or MACOS_PLATFORM
    // platforms are enabled.
%End

%If (V1_0 - V2_0)
    // Process this if either V1_0 or V1_1 is enabled.
%End

%If (V2_0 - )
    // Process this if either V2_0 or V3_0 is enabled.
%End

%If (SIP_4_13 - )
    // SIP v4.13 and later will process this.
%End

%If ( - )
    // Always process this.
%End
</pre></div>
</div>
<p>Also note that the only way to specify the logical and of qualifiers is to use
nested <a class="reference internal" href="#std:directive-%If"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%If</span></code></a> directives.</p>
<pre class="literal-block" id="std:directive-%Import">%Import(name = <em>filename</em>)</pre>
<p>This directive is used to import the specification of another module.  This is
needed if the current module makes use of any types defined in the imported
module, e.g. as an argument to a function, or to sub-class.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">name</span></code> cannot be opened then SIP prepends <code class="docutils literal notranslate"><span class="pre">name</span></code> with the name of the
directory containing the current specification file (i.e. the one containing
the <a class="reference internal" href="#std:directive-%Import"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Import</span></code></a> directive) and tries again.  If this also fails then
SIP prepends <code class="docutils literal notranslate"><span class="pre">name</span></code> with each of the directories, in turn, specified by the
<a class="reference internal" href="command_line.html#cmdoption-sip-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a> command line option.</p>
<p>Directory separators must always be <code class="docutils literal notranslate"><span class="pre">/</span></code>.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">Import</span> <span class="n">qt</span><span class="o">/</span><span class="n">qtmod</span><span class="o">.</span><span class="n">sip</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%Include">%Include(name = <em>filename</em> [, optional = [True | False]])</pre>
<p>This directive is used to include contents of another file as part of the
specification of the current module.  It is the equivalent of the C
preprocessor’s <code class="docutils literal notranslate"><span class="pre">#include</span></code> directive and is used to structure a large module
specification into manageable pieces.</p>
<p><a class="reference internal" href="#std:directive-%Include"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Include</span></code></a> follows the same search process as the
<a class="reference internal" href="#std:directive-%Import"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Import</span></code></a> directive when trying to open <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<p>if <code class="docutils literal notranslate"><span class="pre">optional</span></code> is set then SIP will silently continue processing if the file
could not be opened.</p>
<p>Directory separators must always be <code class="docutils literal notranslate"><span class="pre">/</span></code>.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">Include</span> <span class="n">qwidget</span><span class="o">.</span><span class="n">sip</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%InitialisationCode">%InitialisationCode
    <em>code</em>
%End</pre>
<p>This directive is used to specify handwritten code that is embedded in-line
in the generated module initialisation code after the SIP module has been
imported but before the module itself has been initialised.</p>
<p>It is typically used to call <a class="reference internal" href="c_api.html#c.sipRegisterPyType" title="sipRegisterPyType"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipRegisterPyType()</span></code></a>.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">InitialisationCode</span>
    <span class="o">//</span> <span class="n">The</span> <span class="n">code</span> <span class="n">will</span> <span class="n">be</span> <span class="n">executed</span> <span class="n">when</span> <span class="n">the</span> <span class="n">module</span> <span class="ow">is</span> <span class="n">first</span> <span class="n">imported</span><span class="p">,</span> <span class="n">after</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">SIP</span> <span class="n">module</span> <span class="n">has</span> <span class="n">been</span> <span class="n">imported</span><span class="p">,</span> <span class="n">but</span> <span class="n">before</span> <span class="n">other</span> <span class="n">module</span><span class="o">-</span><span class="n">specific</span>
    <span class="o">//</span> <span class="n">initialisation</span> <span class="n">has</span> <span class="n">been</span> <span class="n">completed</span><span class="o">.</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<div class="versionadded" id="std:directive-%InstanceCode">
<p><span class="versionmodified added">New in version 4.14.</span></p>
</div>
<pre class="literal-block">%InstanceCode
    <em>code</em>
%End</pre>
<p>There are a number of circumstances where SIP needs to create an instance of a
C++ class but may not be able to do so.  For example the C++ class may be
abstract or may not have an argumentless public constructor.  This directive is
used in the definition of a class or mapped type to specify handwritten code to
create an instance of the C++ class.  For example, if the C++ class is
abstract, then the handwritten code may return an instance of a concrete
sub-class.</p>
<p>The following variable is made available to the handwritten code:</p>
<dl class="simple">
<dt><em>type</em> *sipCpp</dt><dd><p>This must be set by the handwritten code to the address of an instance of
the C++ class.  It doesn’t matter if the instance is on the heap or not as
it will never be explicitly destroyed.</p>
</dd>
</dl>
<pre class="literal-block" id="std:directive-%License">%License(type = <em>string</em>
        [, licensee = <em>string</em>]
        [, signature = <em>string</em>]
        [, timestamp = <em>string</em>])</pre>
<p>This directive is used to specify the contents of an optional license
dictionary.  The license dictionary is called <code class="xref py py-data docutils literal notranslate"><span class="pre">__license__</span></code> and is stored
in the module dictionary.</p>
<p><code class="docutils literal notranslate"><span class="pre">type</span></code> is the type of the license and its value in the license dictionary is
accessed using the <code class="docutils literal notranslate"><span class="pre">&quot;Type&quot;</span></code> key.  No restrictions are placed on the value.</p>
<p><code class="docutils literal notranslate"><span class="pre">licensee</span></code> is the optional name of the licensee and its value in the license
dictionary is accessed using the <code class="docutils literal notranslate"><span class="pre">&quot;Licensee&quot;</span></code> key.  No restrictions are
placed on the value.</p>
<p><code class="docutils literal notranslate"><span class="pre">signature</span></code> is the license’s optional signature and its value in the license
dictionary is accessed using the <code class="docutils literal notranslate"><span class="pre">&quot;Signature&quot;</span></code> key.  No restrictions are
placed on the value.</p>
<p><code class="docutils literal notranslate"><span class="pre">timestamp</span></code> is the license’s optional timestamp and its value in the license
dictionary is accessed using the <code class="docutils literal notranslate"><span class="pre">&quot;Timestamp&quot;</span></code> key.  No restrictions are
placed on the value.</p>
<p>Note that this directive isn’t an attempt to impose any licensing restrictions
on a module.  It is simply a method for easily embedding licensing information
in a module so that it is accessible to Python scripts.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">License</span> <span class="s2">&quot;GPL&quot;</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%MappedType">template&lt;<em>type-list</em>&gt;
%MappedType <em>type</em>
{
    [<a class="reference internal" href="#std:directive-%TypeHeaderCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%TypeHeaderCode</span></code></a>]
    [<a class="reference internal" href="#std:directive-%ConvertToTypeCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToTypeCode</span></code></a>]
    [<a class="reference internal" href="#std:directive-%ConvertFromTypeCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertFromTypeCode</span></code></a>]
};

%MappedType <em>type</em>
{
    [<a class="reference internal" href="#std:directive-%TypeHeaderCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%TypeHeaderCode</span></code></a>]
    [<a class="reference internal" href="#std:directive-%ConvertToTypeCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToTypeCode</span></code></a>]
    [<a class="reference internal" href="#std:directive-%ConvertFromTypeCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertFromTypeCode</span></code></a>]
};</pre>
<p>This directive is used to define an automatic mapping between a C or C++ type
and a Python type.  It can be used as part of a template, or to map a specific
type.</p>
<p>When used as part of a template <em>type</em> cannot itself refer to a template.  Any
occurrences of any of the type names (but not any <code class="docutils literal notranslate"><span class="pre">*</span></code> or <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) in
<em>type-list</em> will be replaced by the actual type names used when the template is
instantiated.  Template mapped types are instantiated automatically as required
(unlike template classes which are only instantiated using <code class="docutils literal notranslate"><span class="pre">typedef</span></code>).</p>
<p>Any explicit mapped type will be used in preference to any template that maps
the same type, ie. a template will not be automatically instantiated if there
is an explicit mapped type.</p>
<p>The optional <a class="reference internal" href="#std:directive-%TypeHeaderCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%TypeHeaderCode</span></code></a> sub-directive is used to specify the
library interface to the type being mapped.</p>
<p>The optional <a class="reference internal" href="#std:directive-%ConvertToTypeCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertToTypeCode</span></code></a> sub-directive is used to specify
the handwritten code that converts a Python object to an instance of the mapped
type.</p>
<p>The optional <a class="reference internal" href="#std:directive-%ConvertFromTypeCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ConvertFromTypeCode</span></code></a> sub-directive is used to specify
the handwritten code that converts an instance of the mapped type to a Python
object.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>template&lt;Type *&gt;
%MappedType QList
{
%TypeHeaderCode
// Include the library interface to the type being mapped.
#include &lt;qlist.h&gt;
%End

%ConvertToTypeCode
    // See if we are just being asked to check the type of the Python
    // object.
    if (sipIsErr == NULL)
    {
        // Check it is a list.
        if (!PyList_Check(sipPy))
            return 0;

        // Now check each element of the list is of the type we expect.
        // The template is for a pointer type so we don&#39;t disallow None.
        for (int i = 0; i &lt; PyList_GET_SIZE(sipPy); ++i)
            if (!sipCanConvertToType(PyList_GET_ITEM(sipPy, i),
                                     sipType_Type, 0))
                return 0;

        return 1;
    }

    // Create the instance on the heap.
    QList&lt;Type *&gt; *ql = new QList&lt;Type *&gt;;

    for (int i = 0; i &lt; PyList_GET_SIZE(sipPy); ++i)
    {
        // Use the SIP API to convert the Python object to the
        // corresponding C++ instance.  Note that we apply any ownership
        // transfer to the list itself, not the individual elements.
        Type *t = reinterpret_cast&lt;Type *&gt;(sipConvertToType(
                                            PyList_GET_ITEM(sipPy, i),
                                            sipType_Type, 0, 0, 0,
                                            sipIsErr));

        if (*sipIsErr)
        {
            // Tidy up.
            delete ql;

            // There is nothing on the heap.
            return 0;
        }

        // Add the pointer to the C++ instance.
        ql-&gt;append(t);
    }

    // Return the instance on the heap.
    *sipCppPtr = ql;

    // Apply the normal transfer.
    return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
    PyObject *l;

    // Create the Python list of the correct length.
    if ((l = PyList_New(sipCpp-&gt;size())) == NULL)
        return NULL;

    // Go through each element in the C++ instance and convert it to the
    // corresponding Python object.
    for (int i = 0; i &lt; sipCpp-&gt;size(); ++i)
    {
        Type *t = sipCpp-&gt;at(i);
        PyObject *tobj;

        if ((tobj = sipConvertFromType(t, sipType_Type, sipTransferObj)) == NULL)
        {
            // There was an error so garbage collect the Python list.
            Py_DECREF(l);
            return NULL;
        }

        PyList_SET_ITEM(l, i, tobj);
    }

    // Return the Python list.
    return l;
%End
};
</pre></div>
</div>
<p>Using this we can use, for example, <code class="docutils literal notranslate"><span class="pre">QList&lt;QObject</span> <span class="pre">*&gt;</span></code> throughout the
module’s specification files (and in any module that imports this one).  The
generated code will automatically map this to and from a Python list of QObject
instances when appropriate.</p>
<pre class="literal-block" id="std:directive-%MethodCode">%MethodCode
    <em>code</em>
%End</pre>
<p>This directive is used as part of the specification of a global function, class
method, operator, constructor or destructor to specify handwritten code that
replaces the normally generated call to the function being wrapped.  It is
usually used to handle argument types and results that SIP cannot deal with
automatically.</p>
<p>Normally the specified code is embedded in-line after the function’s arguments
have been successfully converted from Python objects to their C or C++
equivalents.  In this case the specified code must not include any <code class="docutils literal notranslate"><span class="pre">return</span></code>
statements.</p>
<p>However if the <a class="reference internal" href="annotations.html#function-annotation-NoArgParser"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">NoArgParser</span></code></a> annotation has been used then the specified
code is also responsible for parsing the arguments.  No other code is generated
by SIP and the specified code must include a <code class="docutils literal notranslate"><span class="pre">return</span></code> statement.</p>
<p>In the context of a destructor the specified code is embedded in-line in the
Python type’s deallocation function.  Unlike other contexts it supplements
rather than replaces the normally generated code, so it must not include code
to return the C structure or C++ class instance to the heap.  The code is only
called if ownership of the structure or class is with Python.</p>
<p>The specified code must also handle the Python Global Interpreter Lock (GIL).
If compatibility with SIP v3.x is required then the GIL must be released
immediately before the C++ call and reacquired immediately afterwards as shown
in this example fragment:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Py_BEGIN_ALLOW_THREADS</span>
<span class="n">sipCpp</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span>
<span class="n">Py_END_ALLOW_THREADS</span>
</pre></div>
</div>
<p>If compatibility with SIP v3.x is not required then this is optional but
should be done if the C++ function might block the current thread or take a
significant amount of time to execute.  (See <a class="reference internal" href="using.html#ref-gil"><span class="std std-ref">The Python Global Interpreter Lock</span></a> and the
<a class="reference internal" href="annotations.html#function-annotation-ReleaseGIL"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">ReleaseGIL</span></code></a> and <a class="reference internal" href="annotations.html#function-annotation-HoldGIL"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">HoldGIL</span></code></a> annotations.)</p>
<p>If the <a class="reference internal" href="annotations.html#function-annotation-NoArgParser"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">NoArgParser</span></code></a> annotation has not been used then the following
variables are made available to the handwritten code:</p>
<dl>
<dt><em>type</em> a0</dt><dd><p>There is a variable for each argument of the Python signature (excluding
any <code class="docutils literal notranslate"><span class="pre">self</span></code> argument) named <code class="docutils literal notranslate"><span class="pre">a0</span></code>, <code class="docutils literal notranslate"><span class="pre">a1</span></code>, etc.  If
<code class="docutils literal notranslate"><span class="pre">use_argument_names</span></code> has been set in the <a class="reference internal" href="#std:directive-%Module"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Module</span></code></a> directive
then the name of the argument is the real name.  The <em>type</em> of the variable
is the same as the type defined in the specification with the following
exceptions:</p>
<ul class="simple">
<li><p>if the argument is only used to return a value (e.g. it is an <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span></code>
without an <a class="reference internal" href="annotations.html#argument-annotation-In"><code class="xref std std-aanno docutils literal notranslate"><span class="pre">In</span></code></a> annotation) then the type has one less level of
indirection (e.g. it will be an <code class="docutils literal notranslate"><span class="pre">int</span></code>)</p></li>
<li><p>if the argument is a structure or class (or a reference or a pointer to a
structure or class) then <em>type</em> will always be a pointer to the structure
or class.</p></li>
</ul>
<p>Note that handwritten code for destructors never has any arguments.</p>
</dd>
<dt>PyObject *a0Wrapper</dt><dd><p>This variable is made available only if the <a class="reference internal" href="annotations.html#argument-annotation-GetWrapper"><code class="xref std std-aanno docutils literal notranslate"><span class="pre">GetWrapper</span></code></a> annotation
is specified for the corresponding argument.  The variable is a pointer to
the Python object that wraps the argument.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">use_argument_names</span></code> has been set in the <a class="reference internal" href="#std:directive-%Module"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Module</span></code></a>
directive then the name of the variable is the real name of the argument
with <code class="docutils literal notranslate"><span class="pre">Wrapper</span></code> appended.</p>
</dd>
<dt><em>type</em> *sipCpp</dt><dd><p>If the directive is used in the context of a class constructor then this
must be set by the handwritten code to the constructed instance.  If it is
set to <code class="docutils literal notranslate"><span class="pre">0</span></code> and no Python exception is raised then SIP will continue to
try other Python signatures.</p>
<p>If the directive is used in the context of a method (but not the standard
binary operator methods, e.g. <code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code>) or a destructor then this is
a pointer to the C structure or C++ class instance.</p>
<p>Its <em>type</em> is a pointer to the structure or class.</p>
<p>Standard binary operator methods follow the same convention as global
functions and instead define two arguments called <code class="docutils literal notranslate"><span class="pre">a0</span></code> and <code class="docutils literal notranslate"><span class="pre">a1</span></code>.</p>
</dd>
<dt>sipErrorState sipError</dt><dd><p>The handwritten code should set this to either <code class="docutils literal notranslate"><span class="pre">sipErrorContinue</span></code> or
<code class="docutils literal notranslate"><span class="pre">sipErrorFail</span></code>, and raise an appropriate Python exception, if an error
is detected.  Its initial value will be <code class="docutils literal notranslate"><span class="pre">sipErrorNone</span></code>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">sipErrorContinue</span></code> is used, SIP will remember the exception as the
reason why the particular overloaded callable could not be invoked.  It
will then continue to try the next overloaded callable.  It is typically
used by code that needs to do additional type checking of the callable’s
arguments.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">sipErrorFail</span></code> is used, SIP will report the exception immediately
and will not attempt to invoke other overloaded callables.</p>
<p><code class="docutils literal notranslate"><span class="pre">sipError</span></code> is not provided for destructors.</p>
</dd>
<dt>int sipIsErr</dt><dd><p>The handwritten code should set this to a non-zero value, and raise an
appropriate Python exception, if an error is detected.  This is the
equivalent of setting <code class="docutils literal notranslate"><span class="pre">sipError</span></code> to <code class="docutils literal notranslate"><span class="pre">sipErrorFail</span></code>.  Its initial value
will be <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">sipIsErr</span></code> is not provided for destructors.</p>
</dd>
<dt><em>type</em> sipRes</dt><dd><p>The handwritten code should set this to the result to be returned.  The
<em>type</em> of the variable is the same as the type defined in the Python
signature in the specification with the following exception:</p>
<ul class="simple">
<li><p>if the argument is a structure or class (or a reference or a pointer to a
structure or class) then <em>type</em> will always be a pointer to the structure
or class.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">sipRes</span></code> is not provided for inplace operators (e.g. <code class="docutils literal notranslate"><span class="pre">+=</span></code> or
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__imul__()</span></code>) as their results are handled automatically, nor for class
constructors or destructors.</p>
</dd>
<dt>PyObject *sipSelf</dt><dd><p>If the directive is used in the context of a class constructor, destructor
or method then this is the Python object that wraps the structure or class
instance, i.e. <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd>
<dt>bool sipSelfWasArg</dt><dd><p>This is only made available for non-abstract, virtual methods.  It is set
if <code class="docutils literal notranslate"><span class="pre">self</span></code> was explicitly passed as the first argument of the method
rather than being bound to the method.  In other words, the call was:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Klass</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>rather than:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<p>If the <a class="reference internal" href="annotations.html#function-annotation-NoArgParser"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">NoArgParser</span></code></a> annotation has been used then only the following
variables are made available to the handwritten code:</p>
<dl class="simple">
<dt>PyObject *sipArgs</dt><dd><p>This is the tuple of arguments.</p>
</dd>
<dt>PyObject *sipKwds</dt><dd><p>This is the dictionary of keyword arguments.</p>
</dd>
</dl>
<p>The following is a complete example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>class Klass
{
public:
    virtual int foo(SIP_PYTUPLE);
%MethodCode
        // The C++ API takes a 2 element array of integers but passing a
        // two element tuple is more Pythonic.

        int iarr[2];

        if (PyArg_ParseTuple(a0, &quot;ii&quot;, &amp;iarr[0], &amp;iarr[1]))
        {
            Py_BEGIN_ALLOW_THREADS
            sipRes = sipSelfWasArg ? sipCpp-&gt;Klass::foo(iarr)
                                   : sipCpp-&gt;foo(iarr);
            Py_END_ALLOW_THREADS
        }
        else
        {
            // PyArg_ParseTuple() will have raised the exception.
            sipIsErr = 1;
        }
%End
};
</pre></div>
</div>
<p>As the example is a virtual method <a class="footnote-reference brackets" href="#id2" id="id1">1</a>, note the use of <code class="docutils literal notranslate"><span class="pre">sipSelfWasArg</span></code> to
determine exactly which implementation of <code class="docutils literal notranslate"><span class="pre">foo()</span></code> to call.</p>
<p>If a method is in the <code class="docutils literal notranslate"><span class="pre">protected</span></code> section of a C++ class then SIP generates
helpers that provide access to method.  However, these are not available if
the Python module is being built with <code class="docutils literal notranslate"><span class="pre">protected</span></code> redefined as <code class="docutils literal notranslate"><span class="pre">public</span></code>.</p>
<p>The following pattern should be used to cover all possibilities:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#if defined(SIP_PROTECTED_IS_PUBLIC)
    sipRes = sipSelfWasArg ? sipCpp-&gt;Klass::foo(iarr)
                           : sipCpp-&gt;foo(iarr);
#else
    sipRes = sipCpp-&gt;sipProtectVirt_foo(sipSelfWasArg, iarr);
#endif
</pre></div>
</div>
<p>If a method is in the <code class="docutils literal notranslate"><span class="pre">protected</span></code> section of a C++ class but is not virtual
then the pattern should instead be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#if defined(SIP_PROTECTED_IS_PUBLIC)</span>
    <span class="n">sipRes</span> <span class="o">=</span> <span class="n">sipCpp</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">(</span><span class="n">iarr</span><span class="p">);</span>
<span class="c1">#else</span>
    <span class="n">sipRes</span> <span class="o">=</span> <span class="n">sipCpp</span><span class="o">-&gt;</span><span class="n">sipProtect_foo</span><span class="p">(</span><span class="n">iarr</span><span class="p">);</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>See <a class="reference internal" href="#std:directive-%VirtualCatcherCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%VirtualCatcherCode</span></code></a> for a description of how SIP
generated code handles the reimplementation of C++ virtual methods in
Python.</p>
</dd>
</dl>
<pre class="literal-block" id="std:directive-%Module">%Module(name = <em>dotted-name</em>
        [, all_raise_py_exception = [True | False]]
        [, call_super_init = [True | False]]
        [, default_VirtualErrorHandler = <em>name</em>]
        [, keyword_arguments = [&quot;None&quot; | &quot;All&quot; | &quot;Optional&quot;]]
        [, language = <em>string</em>]
        [, use_argument_names = [True | False]]
        [, use_limited_api = [True | False]]
        [, version = <em>integer</em>])
{
    [<a class="reference internal" href="#std:directive-%AutoPyName"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%AutoPyName</span></code></a>]
    [<a class="reference internal" href="#std:directive-%Docstring"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Docstring</span></code></a>]
};</pre>
<p>This directive is used to specify the name of a module and a number of other
attributes.  <code class="docutils literal notranslate"><span class="pre">name</span></code> may contain periods to specify that the module is part of
a Python package.</p>
<p><code class="docutils literal notranslate"><span class="pre">all_raise_py_exception</span></code> specifies that all constructors, functions and
methods defined in the module raise a Python exception to indicate that an
error occurred.  It is the equivalent of using the <a class="reference internal" href="annotations.html#function-annotation-RaisesPyException"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">RaisesPyException</span></code></a>
function annotation on every constructor, function and method.</p>
<p><code class="docutils literal notranslate"><span class="pre">call_super_init</span></code> specifies that the <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method of a wrapped class
should automatically call it’s super-class’s <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method passing a
dictionary of any unused keyword arguments.  In other words, wrapped classes
support cooperative multi-inheritance.  This means that sub-classes, and any
mixin classes, should always use call <code class="docutils literal notranslate"><span class="pre">super().__init__()</span></code> and not call any
super-class’s <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method explicitly.</p>
<p><code class="docutils literal notranslate"><span class="pre">default_VirtualErrorHandler</span></code> specifies the handler (defined by the
<a class="reference internal" href="#std:directive-%VirtualErrorHandler"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%VirtualErrorHandler</span></code></a> directive) that is called when a Python
re-implementation of any virtual C++ function raises a Python exception.  If no
handler is specified for a virtual C++ function then <code class="docutils literal notranslate"><span class="pre">PyErr_Print()</span></code> is
called.</p>
<p><code class="docutils literal notranslate"><span class="pre">keyword_arguments</span></code> specifies the default level of support for Python keyword
arguments.  See the <a class="reference internal" href="annotations.html#function-annotation-KeywordArgs"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">KeywordArgs</span></code></a> annotation for an explaination of the
possible values and their effect.  If it is not specified then the value
implied by the (deprecated) <a class="reference internal" href="command_line.html#cmdoption-sip-k"><code class="xref std std-option docutils literal notranslate"><span class="pre">-k</span></code></a> command line option is used.</p>
<p><code class="docutils literal notranslate"><span class="pre">language</span></code> specifies the implementation language of the library being
wrapped.  Its value is either <code class="docutils literal notranslate"><span class="pre">&quot;C++&quot;</span></code> (the default) or <code class="docutils literal notranslate"><span class="pre">&quot;C&quot;</span></code>.</p>
<p>When providing handwritten code as part of either the <a class="reference internal" href="#std:directive-%MethodCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%MethodCode</span></code></a>
or <a class="reference internal" href="#std:directive-%VirtualCatcherCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%VirtualCatcherCode</span></code></a> directives the names of the arguments of
the function or method are based on the number of the argument, i.e. the first
argument is named <code class="docutils literal notranslate"><span class="pre">a0</span></code>, the second <code class="docutils literal notranslate"><span class="pre">a1</span></code> and so on.  <code class="docutils literal notranslate"><span class="pre">use_argument_names</span></code>
is set to specify that the real name of the argument, if any, should be used
instead.  It also affects the name of the variable created when the
<a class="reference internal" href="annotations.html#argument-annotation-GetWrapper"><code class="xref std std-aanno docutils literal notranslate"><span class="pre">GetWrapper</span></code></a> argument annotation is used.</p>
<p><code class="docutils literal notranslate"><span class="pre">use_limited_api</span></code> specifies that the generated code will only use the
limited Python API defined in PEP 384.  It also ensures that the C preprocessor
symbol <code class="docutils literal notranslate"><span class="pre">Py_LIMITED_API</span></code> is defined before the <code class="docutils literal notranslate"><span class="pre">Python.h</span></code> header file is
included.  Python extensions built in this way are independent of the version
of Python being used.  It is ignored for Python v2.</p>
<p><code class="docutils literal notranslate"><span class="pre">version</span></code> is an optional version number that is useful if you (or others)
might create other modules that build on this module, i.e. if another module
might <a class="reference internal" href="#std:directive-%Import"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Import</span></code></a> this module.  Under the covers, a module exports an
API that is used by modules that <a class="reference internal" href="#std:directive-%Import"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Import</span></code></a> it and the API is given a
version number.  A module built on that module knows the version number of the
API that it is expecting.  If, when the modules are imported at run-time, the
version numbers do not match then a Python exception is raised.  The dependent
module must then be re-built using the correct specification files for the base
module.  This is deprecated and ignored in SIP v4.19.</p>
<p>The optional <a class="reference internal" href="#std:directive-%AutoPyName"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%AutoPyName</span></code></a> sub-directive is used to specify a rule
for automatically providing Python names.</p>
<p>The optional <a class="reference internal" href="#std:directive-%Docstring"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Docstring</span></code></a> sub-directive is used to specify the
module’s docstring.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">Module</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">PyQt4</span><span class="o">.</span><span class="n">QtCore</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%ModuleCode">%ModuleCode
    <em>code</em>
%End</pre>
<p>This directive is used to specify handwritten code, typically the
implementations of utility functions, that can be called by other handwritten
code in the module.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">ModuleCode</span>
<span class="o">//</span> <span class="n">Print</span> <span class="n">an</span> <span class="nb">object</span> <span class="n">on</span> <span class="n">stderr</span> <span class="k">for</span> <span class="n">debugging</span> <span class="n">purposes</span><span class="o">.</span>
<span class="n">void</span> <span class="n">dump_object</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject_Print</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">stderr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#std:directive-%ExportedHeaderCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ExportedHeaderCode</span></code></a>, <a class="reference internal" href="#std:directive-%ModuleHeaderCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ModuleHeaderCode</span></code></a></p>
</div>
<pre class="literal-block" id="std:directive-%ModuleHeaderCode">%ModuleHeaderCode
    <em>code</em>
%End</pre>
<p>This directive is used to specify handwritten code, typically the declarations
of utility functions, that is placed in a header file that is included by all
generated code for the same module.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">ModuleHeaderCode</span>
<span class="n">void</span> <span class="n">dump_object</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">o</span><span class="p">);</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#std:directive-%ExportedHeaderCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ExportedHeaderCode</span></code></a>, <a class="reference internal" href="#std:directive-%ModuleCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ModuleCode</span></code></a></p>
</div>
<pre class="literal-block" id="std:directive-%OptionalInclude">%OptionalInclude <em>filename</em></pre>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.12: </span>Use the <a class="reference internal" href="#std:directive-%Include"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Include</span></code></a> directive with the <code class="docutils literal notranslate"><span class="pre">optional</span></code> argument set
to <code class="docutils literal notranslate"><span class="pre">True</span></code> instead.</p>
</div>
<p>This directive is identical to the <a class="reference internal" href="#std:directive-%Include"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Include</span></code></a> directive except that
SIP silently continues processing if <em>filename</em> could not be opened.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">OptionalInclude</span> <span class="n">license</span><span class="o">.</span><span class="n">sip</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%PickleCode">%PickleCode
    <em>code</em>
%End</pre>
<p>This directive is used to specify handwritten code to pickle a C structure or
C++ class instance.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="simple">
<dt><em>type</em> *sipCpp</dt><dd><p>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</p>
</dd>
<dt>PyObject *sipRes</dt><dd><p>The handwritten code must set this to a tuple of the arguments that will
be passed to the type’s <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method when the structure or class
instance is unpickled.  If there is an error then the code must raise an
exception and set this to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
</dl>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span>
<span class="p">{</span>
    <span class="n">Point</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

    <span class="nb">int</span> <span class="n">x</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">y</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>

<span class="o">%</span><span class="n">PickleCode</span>
    <span class="n">sipRes</span> <span class="o">=</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s2">&quot;ii&quot;</span><span class="p">,</span> <span class="n">sipCpp</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">(),</span> <span class="n">sipCpp</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">());</span>
<span class="o">%</span><span class="n">End</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that SIP works around the Python limitation that prevents nested types
being pickled.</p>
<p>Both named and unnamed enums can be pickled automatically without providing any
handwritten code.</p>
<pre class="literal-block" id="std:directive-%Platforms">%Platforms {<em>name</em> <em>name</em> ...}</pre>
<p>This directive is used to declare a set of platforms.  Platforms (along with
<a class="reference internal" href="#std:directive-%Feature"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Feature</span></code></a> and <a class="reference internal" href="#std:directive-%Timeline"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Timeline</span></code></a>) are used by the
<a class="reference internal" href="#std:directive-%If"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%If</span></code></a> directive to control whether or not parts of a specification
are processed or ignored.</p>
<p>Platforms are mutually exclusive - only one platform can be enabled at a time.
By default all platforms are disabled.  The SIP <a class="reference internal" href="command_line.html#cmdoption-sip-t"><code class="xref std std-option docutils literal notranslate"><span class="pre">-t</span></code></a> command
line option is used to enable a platform.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 4.14.</span></p>
</div>
<p>If a platform is enabled then SIP will automatically generate a corresponding C
preprocessor symbol for use by handwritten code.  The symbol is the name of
the platform prefixed by <code class="docutils literal notranslate"><span class="pre">SIP_PLATFORM_</span></code>.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">Platforms</span> <span class="p">{</span><span class="n">WIN32_PLATFORM</span> <span class="n">POSIX_PLATFORM</span> <span class="n">MACOS_PLATFORM</span><span class="p">}</span>

<span class="o">%</span><span class="n">If</span> <span class="p">(</span><span class="n">WIN32_PLATFORM</span><span class="p">)</span>
<span class="n">void</span> <span class="n">undocumented</span><span class="p">();</span>
<span class="o">%</span><span class="n">End</span>

<span class="o">%</span><span class="n">If</span> <span class="p">(</span><span class="n">POSIX_PLATFORM</span><span class="p">)</span>
<span class="n">void</span> <span class="n">documented</span><span class="p">();</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%PostInitialisationCode">%PostInitialisationCode
    <em>code</em>
%End</pre>
<p>This directive is used to specify handwritten code that is embedded in-line
at the very end of the generated module initialisation code.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="simple">
<dt>PyObject *sipModule</dt><dd><p>This is the module object returned by <code class="docutils literal notranslate"><span class="pre">Py_InitModule()</span></code>.</p>
</dd>
<dt>PyObject *sipModuleDict</dt><dd><p>This is the module’s dictionary object returned by <code class="docutils literal notranslate"><span class="pre">Py_ModuleGetDict()</span></code>.</p>
</dd>
</dl>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">PostInitialisationCode</span>
    <span class="o">//</span> <span class="n">The</span> <span class="n">code</span> <span class="n">will</span> <span class="n">be</span> <span class="n">executed</span> <span class="n">when</span> <span class="n">the</span> <span class="n">module</span> <span class="ow">is</span> <span class="n">first</span> <span class="n">imported</span> <span class="ow">and</span>
    <span class="o">//</span> <span class="n">after</span> <span class="nb">all</span> <span class="n">other</span> <span class="n">initialisation</span> <span class="n">has</span> <span class="n">been</span> <span class="n">completed</span><span class="o">.</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%PreInitialisationCode">%PreInitialisationCode
    <em>code</em>
%End</pre>
<p>This directive is used to specify handwritten code that is embedded in-line
at the very start of the generated module initialisation code.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">PreInitialisationCode</span>
    <span class="o">//</span> <span class="n">The</span> <span class="n">code</span> <span class="n">will</span> <span class="n">be</span> <span class="n">executed</span> <span class="n">when</span> <span class="n">the</span> <span class="n">module</span> <span class="ow">is</span> <span class="n">first</span> <span class="n">imported</span> <span class="ow">and</span>
    <span class="o">//</span> <span class="n">before</span> <span class="n">other</span> <span class="n">initialisation</span> <span class="n">has</span> <span class="n">been</span> <span class="n">completed</span><span class="o">.</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<div class="versionadded" id="std:directive-%Property">
<p><span class="versionmodified added">New in version 4.12.</span></p>
</div>
<pre class="literal-block">%Property(name = <em>name</em>, get = <em>name</em> [, set = <em>name</em>])
{
    [<a class="reference internal" href="#std:directive-%Docstring"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Docstring</span></code></a>]
};</pre>
<p>This directive is used to define a Python property.  <code class="docutils literal notranslate"><span class="pre">name</span></code> is the name of
the property.</p>
<p><code class="docutils literal notranslate"><span class="pre">get</span></code> is the Python name of the getter method and must refer to a method in
the same class.</p>
<p><code class="docutils literal notranslate"><span class="pre">set</span></code> is the Python name of the optional setter method and must refer to a
method in the same class.</p>
<p>The optional <a class="reference internal" href="#std:directive-%Docstring"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Docstring</span></code></a> sub-directive is used to specify the
property’s docstring.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Klass</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">get_count</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>
    <span class="n">void</span> <span class="n">set_count</span><span class="p">();</span>

    <span class="o">%</span><span class="n">Property</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">get</span><span class="o">=</span><span class="n">get_count</span><span class="p">,</span> <span class="nb">set</span><span class="o">=</span><span class="n">set_count</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="versionadded" id="std:directive-%PreMethodCode">
<p><span class="versionmodified added">New in version 4.19.1.</span></p>
</div>
<pre class="literal-block">%PreMethodCode
    <em>code</em>
%End</pre>
<p>This directive is used as part of the specification of a global function, class
method, operator, constructor or destructor to specify handwritten code that
is inserted before the default code for calling the wrapped function, or
before the <a class="reference internal" href="#std:directive-%MethodCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%MethodCode</span></code></a> directive if it is also given.</p>
<pre class="literal-block" id="std:directive-%RaiseCode">%RaiseCode
    <em>code</em>
%End</pre>
<p>This directive is used as part of the definition of an exception using the
<a class="reference internal" href="#std:directive-%Exception"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Exception</span></code></a> directive to specify handwritten code that raises a
Python exception when a C++ exception has been caught.  The code is embedded
in-line as the body of a C++ <code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">()</span></code> clause.</p>
<p>The specified code must handle the Python Global Interpreter Lock (GIL) if
necessary.  The GIL must be acquired before any calls to the Python API and
released after the last call as shown in this example fragment:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SIP_BLOCK_THREADS</span>
<span class="n">PyErr_SetNone</span><span class="p">(</span><span class="n">PyErr_Exception</span><span class="p">);</span>
<span class="n">SIP_UNBLOCK_THREADS</span>
</pre></div>
</div>
<p>Finally, the specified code must not include any <code class="docutils literal notranslate"><span class="pre">return</span></code> statements.</p>
<p>The following variable is made available to the handwritten code:</p>
<dl class="simple">
<dt><em>type</em> &amp;sipExceptionRef</dt><dd><p>This is a reference to the caught C++ exception.  The <em>type</em> of the
reference is the same as the type defined in the <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">()</span></code> specifier.</p>
</dd>
</dl>
<p>See the <a class="reference internal" href="#std:directive-%Exception"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Exception</span></code></a> directive for an example.</p>
<pre class="literal-block" id="std:directive-%SetCode">%SetCode
    <em>code</em>
%End</pre>
<p>This sub-directive is used in the declaration of a C++ class variable or C
structure member to specify handwritten code to convert it from a Python
object.  It is usually used to handle types that SIP cannot deal with
automatically.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="simple">
<dt><em>type</em> *sipCpp</dt><dd><p>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.  It is not made available if the
variable being wrapped is a static class variable.</p>
</dd>
<dt>int sipErr</dt><dd><p>If the conversion failed then the handwritten code should raise a Python
exception and set this to a non-zero value.  Its initial value will be
automatically set to zero.</p>
</dd>
<dt>PyObject *sipPy</dt><dd><p>This is the Python object that the handwritten code should convert.</p>
</dd>
<dt>PyObject *sipPyType</dt><dd><p>If the variable being wrapped is a static class variable then this is the
Python type object of the class from which the variable was referenced
(<em>not</em> the class in which it is defined).  It may be safely cast to a
PyTypeObject * or a sipWrapperType *.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#std:directive-%AccessCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%AccessCode</span></code></a>, <a class="reference internal" href="#std:directive-%GetCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%GetCode</span></code></a></p>
</div>
<pre class="literal-block" id="std:directive-%Timeline">%Timeline {<em>name</em> <em>name</em> ...}</pre>
<p>This directive is used to declare a set of versions released over a period of
time.  Versions (along with <a class="reference internal" href="#std:directive-%Feature"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Feature</span></code></a> and <a class="reference internal" href="#std:directive-%Platforms"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Platforms</span></code></a>)
are used by the <a class="reference internal" href="#std:directive-%If"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%If</span></code></a> directive to control whether or not parts of a
specification are processed or ignored.</p>
<p>Versions are mutually exclusive - only one version can be enabled at a time.
The SIP <a class="reference internal" href="command_line.html#cmdoption-sip-t"><code class="xref std std-option docutils literal notranslate"><span class="pre">-t</span></code></a> command line option is used to enable a version.
If a timeline does not have a version explicitly enabled then the latest
version will be enabled automatically.</p>
<p>The <a class="reference internal" href="command_line.html#id1"><code class="xref std std-option docutils literal notranslate"><span class="pre">-B</span></code></a> command line option may be used to define a
<em>backstop</em> for a timeline.  Instead of automatically enabling the latest
version, the version immediately preceeding the backstop is enabled instead.</p>
<p>The <a class="reference internal" href="#std:directive-%Timeline"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Timeline</span></code></a> directive can be used any number of times in a
module to allow multiple libraries to be wrapped in the same module.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 4.12.</span></p>
</div>
<p>SIP automatically defines a timeline containing all versions of SIP since
v4.12.  The name of the version is <code class="docutils literal notranslate"><span class="pre">SIP_</span></code> followed by the individual parts of
the version number separated by an underscore.  SIP v4.12 is therefore
<code class="docutils literal notranslate"><span class="pre">SIP_4_12</span></code> and SIP v4.13.2 is <code class="docutils literal notranslate"><span class="pre">SIP_4_13_2</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 4.14.</span></p>
</div>
<p>If a particular version is enabled then SIP will automatically generate a
corresponding C preprocessor symbol for use by handwritten code.  The symbol is
the name of the version prefixed by <code class="docutils literal notranslate"><span class="pre">SIP_TIMELINE_</span></code>.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">Timeline</span> <span class="p">{</span><span class="n">V1_0</span> <span class="n">V1_1</span> <span class="n">V2_0</span> <span class="n">V3_0</span><span class="p">}</span>

<span class="o">%</span><span class="n">If</span> <span class="p">(</span><span class="n">V1_0</span> <span class="o">-</span> <span class="n">V2_0</span><span class="p">)</span>
<span class="n">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="o">%</span><span class="n">End</span>

<span class="o">%</span><span class="n">If</span> <span class="p">(</span><span class="n">V2_0</span> <span class="o">-</span><span class="p">)</span>
<span class="n">void</span> <span class="n">foo</span><span class="p">(</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="o">%</span><span class="n">End</span>

<span class="o">%</span><span class="n">If</span> <span class="p">(</span><span class="o">-</span> <span class="n">SIP_4_13</span><span class="p">)</span>
<span class="n">void</span> <span class="n">bar</span><span class="p">();</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<pre class="literal-block" id="std:directive-%TypeCode">%TypeCode
    <em>code</em>
%End</pre>
<p>This directive is used as part of the specification of a C structure, a C++
class or a <a class="reference internal" href="#std:directive-%MappedType"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%MappedType</span></code></a> directive to specify handwritten code,
typically the implementations of utility functions, that can be called by other
handwritten code in the structure or class.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Klass</span>
<span class="p">{</span>
<span class="o">%</span><span class="n">TypeCode</span>
<span class="o">//</span> <span class="n">Print</span> <span class="n">an</span> <span class="n">instance</span> <span class="n">on</span> <span class="n">stderr</span> <span class="k">for</span> <span class="n">debugging</span> <span class="n">purposes</span><span class="o">.</span>
<span class="n">static</span> <span class="n">void</span> <span class="n">dump_klass</span><span class="p">(</span><span class="n">const</span> <span class="n">Klass</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s2">&quot;Klass </span><span class="si">%s</span><span class="s2"> at %p</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">(),</span> <span class="n">k</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">%</span><span class="n">End</span>

    <span class="o">//</span> <span class="n">The</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">the</span> <span class="k">class</span> <span class="nc">specification</span><span class="o">.</span>

<span class="p">};</span>
</pre></div>
</div>
<p>Because the scope of the code is normally within the generated file that
implements the type, any utility functions would normally be declared
<code class="docutils literal notranslate"><span class="pre">static</span></code>.  However a naming convention should still be adopted to prevent
clashes of function names within a module in case the SIP <code class="docutils literal notranslate"><span class="pre">-j</span></code> command line
option is used.</p>
<pre class="literal-block" id="std:directive-%TypeHeaderCode">%TypeHeaderCode
    <em>code</em>
%End</pre>
<p>This directive is used to specify handwritten code that defines the interface
to a C or C++ type being wrapped, either a structure, a class, or a template.
It is used within a class definition or a <a class="reference internal" href="#std:directive-%MappedType"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%MappedType</span></code></a> directive.</p>
<p>Normally <em>code</em> will be a pre-processor <code class="docutils literal notranslate"><span class="pre">#include</span></code> statement.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Wrap</span> <span class="n">the</span> <span class="n">Klass</span> <span class="n">class</span><span class="o">.</span>
<span class="k">class</span> <span class="nc">Klass</span>
<span class="p">{</span>
<span class="o">%</span><span class="n">TypeHeaderCode</span>
<span class="c1">#include &lt;klass.h&gt;</span>
<span class="o">%</span><span class="n">End</span>

    <span class="o">//</span> <span class="n">The</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">the</span> <span class="k">class</span> <span class="nc">specification</span><span class="o">.</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="versionadded" id="std:directive-%TypeHintCode">
<p><span class="versionmodified added">New in version 4.18.</span></p>
</div>
<pre class="literal-block">%TypeHintCode
    <em>code</em>
%End</pre>
<p>This directive is used, in the context of a module or an individual class, to
specify handwritten code, typically the import of additional modules, that is
placed in the PEP 484 type hint stub file for the module or class.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#std:directive-%ExportedTypeHintCode"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%ExportedTypeHintCode</span></code></a></p>
</div>
<pre class="literal-block" id="std:directive-%UnitCode">%UnitCode
    <em>code</em>
%End</pre>
<p>This directive is used to specify handwritten code that is included at the very
start of a generated compilation unit (ie. C or C++ source file).  It is
typically used to <code class="docutils literal notranslate"><span class="pre">#include</span></code> a C++ precompiled header file.</p>
<div class="versionadded" id="std:directive-%UnitPostIncludeCode">
<p><span class="versionmodified added">New in version 4.11.</span></p>
</div>
<pre class="literal-block">%UnitPostIncludeCode
    <em>code</em>
%End</pre>
<p>This directive is used to specify handwritten code that is included following
the <code class="docutils literal notranslate"><span class="pre">#include</span></code> of all header files in a generated compilation unit (ie. C or
C++ source file).</p>
<div class="versionadded" id="std:directive-%VirtualCallCode">
<p><span class="versionmodified added">New in version 4.16.7.</span></p>
</div>
<pre class="literal-block">%VirtualCallCode
    <em>code</em>
%End</pre>
<p>For most classes there are corresponding <a class="reference internal" href="c_api.html#ref-derived-classes"><span class="std std-ref">generated derived classes</span></a> that contain reimplementations of the class’s virtual
methods.  These methods (which SIP calls catchers) determine if there is a
corresponding Python reimplementation and call it if so.  If there is no Python
reimplementation then the method in the original class is called instead.</p>
<p>This directive is used to specify handwritten code that replaces the normally
generated call to the original class method if there is no Python
reimplementation.</p>
<p>The following variables are made available to the handwritten code in the
context of a method:</p>
<dl class="simple">
<dt><em>type</em> a0</dt><dd><p>There is a variable for each argument of the C++ signature named <code class="docutils literal notranslate"><span class="pre">a0</span></code>,
<code class="docutils literal notranslate"><span class="pre">a1</span></code>, etc.  If <code class="docutils literal notranslate"><span class="pre">use_argument_names</span></code> has been set in the
<a class="reference internal" href="#std:directive-%Module"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Module</span></code></a> directive then the name of the argument is the real
name.  The <em>type</em> of the variable is the same as the type defined in the
specification.</p>
</dd>
<dt><em>type</em> sipRes</dt><dd><p>The handwritten code should set this to any result to be returned.  The
<em>type</em> of the variable is the same as the type defined in the C++ signature
in the specification.</p>
</dd>
</dl>
<pre class="literal-block" id="std:directive-%VirtualCatcherCode">%VirtualCatcherCode
    <em>code</em>
%End</pre>
<p>This directive is used to specify handwritten code that replaces the normally
generated call to the Python reimplementation of a virtual method and the
handling of any returned results.  It is usually used to handle argument types
and results that SIP cannot deal with automatically.</p>
<p>This directive can also be used in the context of a class destructor to
specify handwritten code that is embedded in-line in the internal derived
class’s destructor.</p>
<p>In the context of a method the Python Global Interpreter Lock (GIL) is
automatically acquired before the specified code is executed and automatically
released afterwards.</p>
<p>In the context of a destructor the specified code must handle the GIL.  The
GIL must be acquired before any calls to the Python API and released after the
last call as shown in this example fragment:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SIP_BLOCK_THREADS</span>
<span class="n">Py_DECREF</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="n">SIP_UNBLOCK_THREADS</span>
</pre></div>
</div>
<p>The following variables are made available to the handwritten code in the
context of a method:</p>
<dl>
<dt><em>type</em> a0</dt><dd><p>There is a variable for each argument of the C++ signature named <code class="docutils literal notranslate"><span class="pre">a0</span></code>,
<code class="docutils literal notranslate"><span class="pre">a1</span></code>, etc.  If <code class="docutils literal notranslate"><span class="pre">use_argument_names</span></code> has been set in the
<a class="reference internal" href="#std:directive-%Module"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Module</span></code></a> directive then the name of the argument is the real
name.  The <em>type</em> of the variable is the same as the type defined in the
specification.</p>
</dd>
<dt>int a0Key</dt><dd><p>There is a variable for each argument of the C++ signature that has a type
where it is important to ensure that the corresponding Python object is not
garbage collected too soon.  This only applies to output arguments that
return <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> terminated strings.  The variable would normally be passed
to <a class="reference internal" href="c_api.html#c.sipParseResult" title="sipParseResult"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipParseResult()</span></code></a> using either the <code class="docutils literal notranslate"><span class="pre">A</span></code> or <code class="docutils literal notranslate"><span class="pre">B</span></code> format
characters.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">use_argument_names</span></code> has been set in the <a class="reference internal" href="#std:directive-%Module"><code class="xref std std-directive docutils literal notranslate"><span class="pre">%Module</span></code></a>
directive then the name of the variable is the real name of the argument
with <code class="docutils literal notranslate"><span class="pre">Key</span></code> appended.</p>
</dd>
<dt>int sipIsErr</dt><dd><p>The handwritten code should set this to a non-zero value, and raise an
appropriate Python exception, if an error is detected.</p>
</dd>
<dt>PyObject *sipMethod</dt><dd><p>This object is the Python reimplementation of the virtual C++ method.  It
is normally passed to <a class="reference internal" href="c_api.html#c.sipCallMethod" title="sipCallMethod"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipCallMethod()</span></code></a>.</p>
</dd>
<dt><em>type</em> sipRes</dt><dd><p>The handwritten code should set this to any result to be returned.  The
<em>type</em> of the variable is the same as the type defined in the C++ signature
in the specification.</p>
</dd>
<dt>int sipResKey</dt><dd><p>This variable is only made available if the result has a type where it is
important to ensure that the corresponding Python object is not garbage
collected too soon.  This only applies to <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> terminated strings.  The
variable would normally be passed to <a class="reference internal" href="c_api.html#c.sipParseResult" title="sipParseResult"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipParseResult()</span></code></a> using
either the <code class="docutils literal notranslate"><span class="pre">A</span></code> or <code class="docutils literal notranslate"><span class="pre">B</span></code> format characters.</p>
</dd>
<dt>sipSimpleWrapper *sipPySelf</dt><dd><p>This variable is only made available if either the <code class="docutils literal notranslate"><span class="pre">a0Key</span></code> or
<code class="docutils literal notranslate"><span class="pre">sipResKey</span></code> are made available.  It defines the context within which keys
are unique.  The variable would normally be passed to
<a class="reference internal" href="c_api.html#c.sipParseResult" title="sipParseResult"><code class="xref c c-func docutils literal notranslate"><span class="pre">sipParseResult()</span></code></a> using the <code class="docutils literal notranslate"><span class="pre">S</span></code> format character.</p>
</dd>
</dl>
<p>No variables are made available in the context of a destructor.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Klass</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">virtual</span> <span class="nb">int</span> <span class="n">foo</span><span class="p">(</span><span class="n">SIP_PYTUPLE</span><span class="p">)</span> <span class="p">[</span><span class="nb">int</span> <span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)];</span>
<span class="o">%</span><span class="n">MethodCode</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">C</span><span class="o">++</span> <span class="n">API</span> <span class="n">takes</span> <span class="n">a</span> <span class="mi">2</span> <span class="n">element</span> <span class="n">array</span> <span class="n">of</span> <span class="n">integers</span> <span class="n">but</span> <span class="n">passing</span> <span class="n">a</span>
        <span class="o">//</span> <span class="n">two</span> <span class="n">element</span> <span class="nb">tuple</span> <span class="ow">is</span> <span class="n">more</span> <span class="n">Pythonic</span><span class="o">.</span>

        <span class="nb">int</span> <span class="n">iarr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="s2">&quot;ii&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iarr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">iarr</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="p">{</span>
            <span class="n">Py_BEGIN_ALLOW_THREADS</span>
            <span class="n">sipRes</span> <span class="o">=</span> <span class="n">sipCpp</span><span class="o">-&gt;</span><span class="n">Klass</span><span class="p">::</span><span class="n">foo</span><span class="p">(</span><span class="n">iarr</span><span class="p">);</span>
            <span class="n">Py_END_ALLOW_THREADS</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">PyArg_ParseTuple</span><span class="p">()</span> <span class="n">will</span> <span class="n">have</span> <span class="n">raised</span> <span class="n">the</span> <span class="n">exception</span><span class="o">.</span>
            <span class="n">sipIsErr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
<span class="o">%</span><span class="n">End</span>
<span class="o">%</span><span class="n">VirtualCatcherCode</span>
        <span class="o">//</span> <span class="n">Convert</span> <span class="n">the</span> <span class="mi">2</span> <span class="n">element</span> <span class="n">array</span> <span class="n">of</span> <span class="n">integers</span> <span class="n">to</span> <span class="n">the</span> <span class="n">two</span> <span class="n">element</span>
        <span class="o">//</span> <span class="nb">tuple</span><span class="o">.</span>

        <span class="n">PyObject</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">sipCallMethod</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sipIsErr</span><span class="p">,</span> <span class="n">sipMethod</span><span class="p">,</span> <span class="s2">&quot;ii&quot;</span><span class="p">,</span> <span class="n">a0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a0</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">Convert</span> <span class="n">the</span> <span class="n">result</span> <span class="n">to</span> <span class="n">the</span> <span class="n">C</span><span class="o">++</span> <span class="nb">type</span><span class="o">.</span>
            <span class="n">sipParseResult</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sipIsErr</span><span class="p">,</span> <span class="n">sipMethod</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sipRes</span><span class="p">);</span>

            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
        <span class="p">}</span>
<span class="o">%</span><span class="n">End</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="versionadded" id="std:directive-%VirtualErrorHandler">
<p><span class="versionmodified added">New in version 4.14.</span></p>
</div>
<pre class="literal-block">%VirtualErrorHandler(name = <em>name</em>)
    <em>code</em>
%End</pre>
<p>This directive is used to define the handwritten code that implements a handler
that is called when a Python re-implementation of a virtual C++ function raises
a Python exception.  If a virtual C++ function does not have a handler the
<code class="docutils literal notranslate"><span class="pre">PyErr_Print()</span></code> function is called.</p>
<p>The handler is called after all tidying up has been completed, with the Python
Global Interpreter Lock (GIL) held and from the thread that raised the
exception.  If the handler wants to change the execution path by, for example,
throwing a C++ exception, it must first release the GIL by calling
<a class="reference internal" href="c_api.html#c.SIP_RELEASE_GIL" title="SIP_RELEASE_GIL"><code class="xref c c-func docutils literal notranslate"><span class="pre">SIP_RELEASE_GIL()</span></code></a>.  It must not call <a class="reference internal" href="c_api.html#c.SIP_RELEASE_GIL" title="SIP_RELEASE_GIL"><code class="xref c c-func docutils literal notranslate"><span class="pre">SIP_RELEASE_GIL()</span></code></a> if the
execution path is not changed.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="simple">
<dt>sipSimpleWrapper *sipPySelf</dt><dd><p>This is the class instance containing the Python reimplementation.</p>
</dd>
<dt>sip_gilstate_t sipGILState</dt><dd><p>This is an opaque value that must be passed to <a class="reference internal" href="c_api.html#c.SIP_RELEASE_GIL" title="SIP_RELEASE_GIL"><code class="xref c c-func docutils literal notranslate"><span class="pre">SIP_RELEASE_GIL()</span></code></a> in
order to release the GIL prior to changing the execution path.</p>
</dd>
</dl>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">VirtualErrorHandler</span> <span class="n">my_handler</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">exception</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">traceback</span><span class="p">;</span>

    <span class="n">PyErr_Fetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exception</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">traceback</span><span class="p">);</span>

    <span class="n">SIP_RELEASE_GIL</span><span class="p">(</span><span class="n">sipGILState</span><span class="p">);</span>

    <span class="n">throw</span> <span class="n">my_exception</span><span class="p">(</span><span class="n">sipPySelf</span><span class="p">,</span> <span class="n">exception</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">);</span>
<span class="o">%</span><span class="n">End</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="annotations.html#function-annotation-NoVirtualErrorHandler"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">NoVirtualErrorHandler</span></code></a>, <a class="reference internal" href="annotations.html#function-annotation-VirtualErrorHandler"><code class="xref std std-fanno docutils literal notranslate"><span class="pre">VirtualErrorHandler</span></code></a>, <a class="reference internal" href="annotations.html#class-annotation-VirtualErrorHandler"><code class="xref std std-canno docutils literal notranslate"><span class="pre">VirtualErrorHandler</span></code></a></p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Directives</a><ul>
<li><a class="reference internal" href="#revised-directive-syntax">Revised Directive Syntax</a></li>
<li><a class="reference internal" href="#list-of-directives">List of Directives</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="specification_files.html"
                        title="previous chapter">SIP Specification Files</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="annotations.html"
                        title="next chapter">Annotations</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="annotations.html" title="Annotations"
             >next</a> |</li>
        <li class="right" >
          <a href="specification_files.html" title="SIP Specification Files"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SIP v4.19.22 Reference Guide</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020 Riverbank Computing Limited.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.2.
    </div>
  </body>
</html>